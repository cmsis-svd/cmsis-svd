<?xml version="1.0" encoding="utf-8"?>
<!-- Generator version: 1.6.0.358 -->
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Cypress Semiconductor</vendor>
  <vendorID>Cypress</vendorID>
  <name>psoc4100smax</name>
  <series>PSoC4100Smax</series>
  <version>1.0</version>
  <description>PSoC4100Smax</description>
  <licenseText>Copyright 2016-2020 Cypress Semiconductor Corporation\n
    SPDX-License-Identifier: Apache-2.0\n
\n
    Licensed under the Apache License, Version 2.0 (the "License");\n
    you may not use this file except in compliance with the License.\n
    You may obtain a copy of the License at\n
\n
      http://www.apache.org/licenses/LICENSE-2.0\n
\n
    Unless required by applicable law or agreed to in writing, software\n
    distributed under the License is distributed on an "AS IS" BASIS,\n
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n
    See the License for the specific language governing permissions and\n
    limitations under the License.</licenseText>
  <cpu>
    <name>CM0PLUS</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>false</mpuPresent>
    <fpuPresent>false</fpuPresent>
    <vtorPresent>1</vtorPresent>
    <nvicPrioBits>2</nvicPrioBits>
    <vendorSystickConfig>0</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>PERI</name>
      <description>Peripheral Interconnect</description>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DIV_CMD</name>
          <description>Divider command register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFF</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>(SEL_TYPE, SEL_DIV) specifies the divider on which the command (DISABLE/ENABLE) is performed.
 
If SEL_DIV is '63' and 'SEL_TYPE' is '3' (default/reset value), no divider is specified and no clock signal(s) are generated.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies the divider type of the divider on which the command is performed:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_SEL_DIV</name>
              <description>(PA_SEL_TYPE, PA_SEL_DIV) pecifies the divider to which phase alignment is performed for the clock enable command. Any enabled divider can be used as reference. This allows all dividers to be aligned with each other, even when they are enabled at different times.
 
If PA_SEL_DIV is '63' and 'PA_SEL_TYPE' is '3', 'clk_hf' is used as reference.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_SEL_TYPE</name>
              <description>Specifies the divider type of the divider to which phase alignment is performed for the clock enable command:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE</name>
              <description>Clock divider disable command (mutually exlusive with ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
The SEL_DIV and SEL_TYPE fields specify which divider is to be disabled.
 
The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN field of the divider to '0' immediately.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Clock divider enable command (mutually exclusive with DISABLE). Typically, SW sets this field to '1' to enable a divider and HW sets this field to '0' to indicate that divider enabling has completed. When a divider is enabled, its integer and fractional (if present) counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the DIV_CMD.DISABLE field.
1: Configure the divider's DIV_XXX_CTL register.
2: Enable the divider using the DIV_CMD_ENABLE field.
 
The SEL_DIV and SEL_TYPE fields specify which divider is to be enabled. The enabled divider may be phase aligned to either 'clk_hf' (typical usage) or to ANY enabled divider.
 
The PA_SEL_DIV and P_SEL_TYPE fields specify the reference divider.
 
The HW sets the ENABLE field to '0' when the enabling is performed and the HW set the DIV_XXX_CTL.EN field of the divider to '1' when the enabling is performed. Note that enabling with phase alignment to a low frequency divider takes time. E.g. To align to a divider that generates a clock of 'clk_hf'/n (with n being the integer divider value INT_DIV+1), up to n cycles may be required to perform alignment. Phase alignment to 'clk_hf' takes affect immediately. SW can set this field to '0' during phase alignment to abort the enabling process.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>PCLK_CTL[%s]</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
 
If SEL_DIV is '63' and 'SEL_TYPE' is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
 
When transitioning a clock between two out of phase dividers, spurious clock control signals may be generated for one 'clk_hf' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV is '63' and 'SEL_TYPE' is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_8_CTL[%s]</name>
          <description>Divider control register (for 8.0 divider)</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT8_DIV</name>
              <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 256].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_CTL[%s]</name>
          <description>Divider control register (for 16.0 divider)</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_5_CTL[%s]</name>
          <description>Divider control register (for 16.5 divider)</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_hf' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
 
For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>63</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_24_5_CTL[%s]</name>
          <description>Divider control register (for 24.5 divider)</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_hf' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT24_DIV</name>
              <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
 
For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL</name>
          <description>Trigger control register</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0FF0F7F</resetMask>
          <fields>
            <field>
              <name>TR_SEL</name>
              <description>Specifies the activated trigger when TR_ACT is '1'. TR_OUT specifies whether the activated trigger is an input trigger or output trigger to the trigger multiplexer. During activation (TR_ACT is '1'), SW should not modify this register field. If the specified trigger is not present, the trigger activation has no effect.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_GROUP</name>
              <description>Specifies the trigger group.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_COUNT</name>
              <description>Amount of cycles a specific trigger is activated. During activation (TR_ACT is '1'), HW decrements this field to '0' using a cycle counter. During activation, SW should not modify this register field. A value of 255 is a special case: HW does NOT decrement this field to '0' and trigger activation is under direct control of TR_ACT: when TR_ACT is '1' the trigger is activated and when TR_ACT is '0' the trigger is deactivated.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_OUT</name>
              <description>Specifies whether trigger activation is for a specific input or ouput trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_OUT_CTL.SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
'0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
'1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_ACT</name>
              <description>SW sets this field to '1' by to activate (set to '1') a trigger as identified by TR_SEL and TR_OUT for TR_COUNT cycles. HW sets this field to '0' when the cycle counter is decremented to '0'. Note: a TR_COUNT value of 255 is a special case and trigger activation is under direct control of the TR_ACT field (the counter is not decremented).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>4</dim>
          <dimIncrement>512</dimIncrement>
          <name>TR_GROUP[%s]</name>
          <description>Peripheral Interconnect trigger group control registers</description>
          <addressOffset>0x00002000</addressOffset>
          <register>
            <dim>128</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_OUT_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F</resetMask>
            <fields>
              <field>
                <name>SEL</name>
                <description>Specifies input trigger. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSIOM</name>
      <description>High Speed IO Matrix (HSIOM)</description>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>13</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>HSIOM port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PORT_SEL</name>
            <description>Port selection register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <description>Selects connection for IO pad 0 route.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <description>SW controlled GPIO.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DSI</name>
                    <description>SW controlled 'out', DSI controlled 'oe_n'.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_DSI</name>
                    <description>DSI controlled 'out' and 'oe_n'.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_GPIO</name>
                    <description>DSI controlled 'out', SW controlled 'oe_n'.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CSD_SENSE</name>
                    <description>CSD sense connection (analog mode)</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CSD_SHIELD</name>
                    <description>CSD shield connection (analog mode)</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA</name>
                    <description>AMUXBUS A connection.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB</name>
                    <description>AMUXBUS B connection. This mode is also used for CSD GPIO charging.  When CSD GPIO charging is enabled in CSD_CONTROL, 'oe_n' is connected to '!csd_charge' signal (and IO pad is also still connected to AMUXBUS B).</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_0</name>
                    <description>Chip specific Active source 0 connection.</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_1</name>
                    <description>Chip specific Active source 1 connection.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_2</name>
                    <description>Chip specific Active source 2 connection.</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_3</name>
                    <description>Chip specific Active source 3 connection.</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LCD_COM</name>
                    <description>LCD common connection. This mode provides DeepSleep functionality  (provided that the LCD block is enabled and properly configured).</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LCD_SEG</name>
                    <description>LCD segment connection. This mode provides DeepSleep functionality  (provided that the LCD block is enabled and properly configured).</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_2</name>
                    <description>Chip specific DeepSleep source 2 connection.</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_3</name>
                    <description>Chip specific DeepSleep source 3 connection.</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <description>Selects connection for IO pad 1 route.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO2_SEL</name>
                <description>Selects connection for IO pad 2 route.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO3_SEL</name>
                <description>Selects connection for IO pad 3 route.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO4_SEL</name>
                <description>Selects connection for IO pad 4 route.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO5_SEL</name>
                <description>Selects connection for IO pad 5 route.</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO6_SEL</name>
                <description>Selects connection for IO pad 6 route.</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO7_SEL</name>
                <description>Selects connection for IO pad 7 route.</description>
                <bitRange>[31:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>PUMP_CTL</name>
          <description>Pump control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>CLOCK_SEL</name>
              <description>Clock select:
'0': External clock.
'1': Internal clock (deprecated).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Pump enabled:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>AMUX_SPLIT_CTL[%s]</name>
          <description>AMUX splitter cell control</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>SWITCH_AA_SL</name>
              <description>T-switch control for Left AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_SR</name>
              <description>T-switch control for Right AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_S0</name>
              <description>T-switch control for AMUXBUSA vssa/ground switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SL</name>
              <description>T-switch control for Left AMUXBUSB switch.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SR</name>
              <description>T-switch control for Right AMUXBUSB switch.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_S0</name>
              <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SRSSLT</name>
      <description>System Resources Lite Subsystem</description>
      <baseAddress>0x40030000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWR_CONTROL</name>
          <description>Power Mode Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8F003F</resetMask>
          <fields>
            <field>
              <name>POWER_MODE</name>
              <description>Current power mode of the device.  Note that this field cannot be read in all power modes on actual silicon.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>RESET state</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>ACTIVE state</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>SLEEP state</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEEP_SLEEP</name>
                  <description>DEEP_SLEEP state</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_SESSION</name>
              <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SESSION</name>
                  <description>No debug session active</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SESSION_ACTIVE</name>
                  <description>Debug session is active</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_READY</name>
              <description>Indicates whether the low power mode regulator is ready to enter DEEPSLEEP mode.  
0: If DEEPSLEEP mode is requested, device will enter SLEEP mode.  When low power regulators are ready, device will automatically enter the originally requested mode.
1: Normal operation.  DEEPSLEEP works as described.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVER_TEMP_EN</name>
              <description>Enables the die over temperature sensor.  Must be enabled when using the TEMP_HIGH interrupt.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVER_TEMP_THRESH</name>
              <description>Over-temperature threshold.
0: TEMP_HIGH condition occurs between 120C and 125C.
1: TEMP_HIGH condition occurs between 60C and 75C (used for testing).</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE</name>
              <description>Spare AHB readback bits that are hooked to PWR_PWRSYS_TRIM1.SPARE_TRIM[1:0] through spare logic equivalent to bitwise inversion.  Engineering only.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EXT_VCCD</name>
              <description>Always write 0 except as noted below. 

PSoC4-S0 and Streetfighter CapSense products may set this bit if Vccd is provided externally (on Vccd pin).  Setting this bit turns off the active regulator and will lead to system reset (BOD) unless both Vddd and Vccd pins are supplied externally.  This register bit only resets for XRES, POR, or a detected BOD.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_KEY_DELAY</name>
          <description>Power System Key&amp;Delay Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF8</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>WAKEUP_HOLDOFF</name>
              <description>Delay to wait for references to settle on wakeup from deepsleep.  BOD is ignored and system does not resume until this delay expires. Note that the same delay on POR is hard-coded.  The default assumes the output of the predivider is 48MHz + 3 percent.  Firmware may scale this setting according to the fastest actual clock frequency that can occur when waking from DEEPSLEEP.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_DDFT_SELECT</name>
          <description>Power DDFT Mode Selection Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DDFT0_SEL</name>
              <description>Select signal for power DDFT output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAKEUP</name>
                  <description>wakeup</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AWAKE</name>
                  <description>awake</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_EN</name>
                  <description>act_power_en</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_UP</name>
                  <description>act_power_up</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_GOOD</name>
                  <description>act_power_good</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_REF_EN</name>
                  <description>srss_adft_control_act_ref_en</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_COMP_EN</name>
                  <description>srss_adft_control_act_comp_en</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_REF_EN</name>
                  <description>srss_adft_control_dpslp_ref_en</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_REG_EN</name>
                  <description>srss_adft_control_dpslp_reg_en</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_COMP_EN</name>
                  <description>srss_adft_control_dpslp_comp_en</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OVER_TEMP_EN</name>
                  <description>pwr_control_over_temp_en</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEPHOLDREQ_N</name>
                  <description>sleepholdreq_n</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ADFT_BUF_EN</name>
                  <description>adft_buf_en</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ATPG_OBSERVE</name>
                  <description>ATPG observe point (no functional purpose)</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GND</name>
                  <description>1'b0</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR</name>
                  <description>1'b1</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DDFT1_SEL</name>
              <description>Select signal for power DDFT output #1</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>WAKEUP</name>
                  <description>wakeup</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AWAKE</name>
                  <description>awake</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_EN</name>
                  <description>act_power_en</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_UP</name>
                  <description>act_power_up</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_POWER_GOOD</name>
                  <description>act_power_good</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_REF_VALID</name>
                  <description>act_ref_valid</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_REG_VALID</name>
                  <description>act_reg_valid</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_COMP_OUT</name>
                  <description>act_comp_out</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACT_TEMP_HIGH</name>
                  <description>act_temp_high</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_COMP_OUT</name>
                  <description>dpslp_comp_out</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DPSLP_POWER_UP</name>
                  <description>dpslp_power_up</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AWAKE_DELAYED</name>
                  <description>awake_delayed</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LPM_READY</name>
                  <description>lpm_ready</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEPHOLDACK_N</name>
                  <description>sleepholdack_n</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>GND</name>
                  <description>1'b0</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PWR</name>
                  <description>1'b1</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_MODE</name>
          <description>Test Mode Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xD0000004</resetMask>
          <fields>
            <field>
              <name>SWD_CONNECTED</name>
              <description>0: SWD not active
1: SWD activated (Line Reset &amp; Connect sequence passed)
(Note: this bit replaces TST_CTRL.SWD_CONNECTED and is present in all M0S8 products except TSG4)</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCK_ALT_XRES</name>
              <description>Relevant only for parts that have the alternate XRES mechanism of overloading a GPIO pin temporarily as alternate XRES during test.  When set, this bit blocks the alternate XRES function, such that the pin can be used for normal I/O or for ddft/adft observation.  See SAS Part-V and Part-IX for details. This register bit only resets for XRES, POR, or a detected BOD.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TEST_KEY_DFT_EN</name>
              <description>This bit is set when a XRES test mode key is shifted in.  It is the value of the test_key_dft_en signal.  When this bit is set, the BootROM will not yield execution to the FLASH image (same function as setting TEST_MODE bit below).</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TEST_MODE</name>
              <description>0: Normal operation mode
1: Test mode (any test mode)
Setting this bit will prevent BootROM from yielding execution to Flash image.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock Select Register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>HFCLK_SEL</name>
              <description>Selects a source for clk_hf and dsi_in[0].  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator or PLL subsystem output</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HFCLK_DIV</name>
              <description>Selects clk_hf predivider value.</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_SEL</name>
              <description>Selects clock source for charge pump clock.  This clock is not guaranteed to be glitch free when changing any of its sources or settings.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GND</name>
                  <description>No clock, connect to gnd</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Use main IMO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>Use clk_hf (using selected source after predivider but before prescaler)</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYSCLK_DIV</name>
              <description>Select clk_sys prescaler value.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>clk_sys= clk_hf/1</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>clk_sys= clk_hf/2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>clk_sys= clk_hf/4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>clk_sys= clk_hf/8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO_CONFIG</name>
          <description>ILO Configuration</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO oscillator.  This bit is hardware set whenever the WDT_DISABLE_KEY is not set to the magic value.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_CONFIG</name>
          <description>IMO Configuration</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for IMO oscillator.  Clearing this bit will disable the IMO.  Don't do this if the system is running off it.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_DFT_SELECT</name>
          <description>Clock DFT Mode Selection Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F7F</resetMask>
          <fields>
            <field>
              <name>DFT_SEL0</name>
              <description>Select signal for DFT output #0</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>clk_ilo: ILO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>clk_imo: IMO primary output</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>clk_eco: ECO output</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>clk_ext: external clock input</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>clk_hf: root of the high-speed clock tree</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>clk_lf:  root of the low-speed clock tree</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYSCLK</name>
                  <description>clk_sys:  root of the CPU/AHB clock tree (gated version of clk_hf)</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PUMPCLK</name>
                  <description>clk_pump: clock provided to charge pumps in FLASH and PA</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRLCLK</name>
                  <description>clk_slpctrl:  clock provided to SleepController</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_DIV0</name>
              <description>DFT Output Divide Down.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Direct Output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_EDGE0</name>
              <description>Edge sensitivity for in-line divider on output #0 (only relevant when DIV0&gt;0).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POSEDGE</name>
                  <description>Use posedge for divider</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEGEDGE</name>
                  <description>Use negedge for divider</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_SEL1</name>
              <description>Select signal for DFT output #1</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>clk_ilo: ILO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>clk_imo: IMO primary output</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>clk_eco: ECO output</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>clk_ext: external clock input</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>clk_hf: root of the high-speed clock tree</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>clk_lf:  root of the low-speed clock tree</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYSCLK</name>
                  <description>clk_sys:  root of the CPU/AHB clock tree (gated version of clk_hf)</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PUMPCLK</name>
                  <description>clk_pump: clock provided to charge pumps in FLASH and PA</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRLCLK</name>
                  <description>clk_slpctrl:  clock provided to SleepController</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_DIV1</name>
              <description>DFT Output Divide Down.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Direct Output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_EDGE1</name>
              <description>Edge sensitivity for in-line divider on output #1 (only relevant when DIV1&gt;0).</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POSEDGE</name>
                  <description>Use posedge for divider</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEGEDGE</name>
                  <description>Use negedge for divider</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_DISABLE_KEY</name>
          <description>Watchdog Disable Key Register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Disables WDT reset when equal to 0xACED8865.  The WDT reset functions normally for any other setting.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_COUNTER</name>
          <description>Watchdog Counter Register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER</name>
              <description>Current value of WDT Counter</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_MATCH</name>
          <description>Watchdog Match Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1000</resetValue>
          <resetMask>0xFFFFF</resetMask>
          <fields>
            <field>
              <name>MATCH</name>
              <description>Match value for Watchdog counter.  Every time WDT_COUNTER reaches MATCH an interrupt is generated.  Two unserviced interrupts will lead to a system reset (i.e. at the third match).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IGNORE_BITS</name>
              <description>The number of MSB bits of the watchdog timer that are NOT checked against MATCH.  This value provides control over the time-to-reset of the watchdog (which happens after 3 successive matches).  Note that certain products may enforce a minimum value for this register through design time configuration.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR</name>
          <description>SRSS Interrupt Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>WDT Interrupt Request.  This bit is set each time WDT_COUNTR==WDT_MATCH.  Clearing this bit also feeds the watch dog.  Missing 2 interrupts in a row will generate brown-out reset.  Due to internal synchronization, it takes 2 SYSCLK cycles to update after a W1C.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TEMP_HIGH</name>
              <description>Regulator over-temp interrupt.  This interrupt can occur when a short circuit exists on the vccd pin or when extreme loads are applied on IO-cells causing the die to overheat.  Firmware is encourage to shutdown all IO cells and then go to DeepSleep mode when this interrupt occurs if protection against such conditions is desired.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_SET</name>
          <description>SRSS Interrupt Set Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x2</resetMask>
          <fields>
            <field>
              <name>TEMP_HIGH</name>
              <description>Writing 1 to this bit internally sets the overtemp interrupt.  This can be observed by reading SRSS_INTR.TEMP_HIGH.  This bit always reads back as zero.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASK</name>
          <description>SRSS Interrupt Mask Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH</name>
              <description>Clearing this bit will not forward the interrupt to the CPU.  It will not, however, disable the WDT reset generation on 2 missed interrupts.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TEMP_HIGH</name>
              <description>Masks REG_OVERTEMP interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE</name>
          <description>Reset Cause Observation Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x19</resetMask>
          <fields>
            <field>
              <name>RESET_WDT</name>
              <description>A WatchDog Timer reset has occurred since last power cycle.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PROT_FAULT</name>
              <description>A protection violation occurred that requires a RESET.  This includes, but is not limited to, hitting a debug breakpoint while in Privileged Mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_SOFT</name>
              <description>Cortex-M0 requested a system reset through it's SYSRESETREQ.  This can be done via a debugger probe or in firmware.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM1</name>
          <description>Bandgap Trim Register</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>REF_VTRIM</name>
              <description>Trims the bandgap reference voltage output.  Used to trim the VBG to the voltage where its temperature curvature is minimal.  Bit [5] is unused within the bandgap block.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM2</name>
          <description>Bandgap Trim Register</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1C</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>REF_ITRIM</name>
              <description>Trims the bandgap reference current output.  Used to trim the IBG to the voltage where its temperature curvature is minimal.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_SELECT</name>
          <description>IMO Frequency Select Register</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>FREQ</name>
              <description>Select operating frequency</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>24_MHZ</name>
                  <description>IMO runs at 24 MHz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>28_MHZ</name>
                  <description>IMO runs at 28 MHz</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>32_MHZ</name>
                  <description>IMO runs at 32 MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>36_MHZ</name>
                  <description>IMO runs at 36 MHz</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>40_MHZ</name>
                  <description>IMO runs at 40 MHz</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>44_MHZ</name>
                  <description>IMO runs at 44 MHz</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>48_MHZ</name>
                  <description>IMO runs at 48 MHz</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM1</name>
          <description>IMO Trim Register</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Frequency trim bits.  These bits are determined at manufacturing time for each FREQ setting (IMO_TRIM2) and stored in SFLASH.  This field is hardware updated during USB osclock mode. This field is mapped to the most significant bits of the IMO trim imo_clk_trim[10:3].  The step size of 1 LSB on this field is approximately 120 kHz.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM2</name>
          <description>IMO Trim Register</description>
          <addressOffset>0xF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>FSOFFSET</name>
              <description>Frequency trim bits.  These bits are not trimmed during manufacturing and kept at 0 under normal operation.  This field is hardware updated during USB osclock mode. This field is mapped to the least significant bits of the IMO trim imo_clk_trim[2:0].  The step size of 1 LSB on this field is approximately 15 kHz.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PWRSYS_TRIM1</name>
          <description>Power System Trim Register</description>
          <addressOffset>0xF14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DPSLP_REF_TRIM</name>
              <description>Trims the DeepSleep reference that is used by the DeepSleep regulator and DeepSleep power comparator.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE_TRIM</name>
              <description>Active-Reference temperature compensation trim (repurposed from spare bits).
Bits [7:6] - trim the Active-Reference IREF temperature coefficient (TC).
  00: TC = 0 (unchanged)
  01: TC = +80ppm/C 
  10: TC = -80ppm/C
  11: TC = -150ppm/C

Bits [5:4] - trim the Active-Reference VREF temperature coefficient (TC).
  00: TC = 0 (unchanged)
  01: TC = -50ppm/C 
  10: TC = -80ppm/C
  11: TC = +150ppm/C</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM3</name>
          <description>IMO Trim Register</description>
          <addressOffset>0xF18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x50</resetValue>
          <resetMask>0x7F</resetMask>
          <fields>
            <field>
              <name>STEPSIZE</name>
              <description>IMO trim stepsize bits.  These bits are determined at manufacturing time to adjust for process variation.  They are used to tune the stepsize of the FSOFFSET and OFFSET trims.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCTRIM</name>
              <description>IMO temperature compesation trim.  These bits are determined at manufacturing time to adjust for temperature dependence. This bits are dependent on frequency and need to be changed using the Cypress provided frequency change algorithm.</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO port control/configuration</description>
      <baseAddress>0x40040000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>13</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>GPIO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>DR</name>
            <description>Port output data register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 output data.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 output data.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>IO pad 2 output data.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>IO pad 3 output data.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>IO pad 4 output data.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>IO pad 5 output data.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>IO pad 6 output data.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>IO pad 7 output data.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PS</name>
            <description>Port IO pad state register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 state:
1: Logic high, if the pin voltage is above the input buffer threshold, logic high.
0: Logic low, if the pin voltage is below that threshold, logic low.
If the drive mode for the pin is set to high Z Analog, the pin state will read 0 independent of the voltage on the pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 state.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>IO pad 2 state.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>IO pad 3 state.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>IO pad 4 state.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>IO pad 5 state.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>IO pad 6 state.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>IO pad 7 state.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Reads of this register return the logical state of the filtered pin.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC</name>
            <description>Port configuration register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFBFFFFFF</resetMask>
            <fields>
              <field>
                <name>DM0</name>
                <description>The GPIO drive mode for IO pad 0.
Note: when initializing IO's that are connected to a live bus (such as I2C), make sure the HSIOM is properly configured (HSIOM_PRT_SELx) before turning the IO on here to avoid producing glitches on the bus.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Mode 0 (analog mode): Output buffer off (high Z). Input buffer off.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INPUT</name>
                    <description>Mode 1: Output buffer off (high Z). Input buffer on.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_PU</name>
                    <description>Mode 2: Strong pull down ('0'), weak/resistive pull up (PU). Input buffer on.
For GPIOV1P2_I2C, Strong pull down only.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_1</name>
                    <description>Mode 3: Weak/resistive pull down (PD), strong pull up ('1'). Input buffer on.
For GPIOV1P2_I2C: Weak pull down only.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_Z</name>
                    <description>Mode 4: Strong pull down ('0'), open drain (pull up off). Input buffer on.
For GPIOV1P2_I2C, Strong pull down only.</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Z_1</name>
                    <description>Mode 5: Open drain (pull down off), strong pull up ('1'). Input buffer on.
Illegal for GPIOV1P2_I2C</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_1</name>
                    <description>Mode 6: Strong pull down ('0'), strong pull up ('1'). Input buffer on.
For GPIOV1P2_I2C, Strong pull down only.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_PU</name>
                    <description>Mode 7: Weak/resistive pull down (PD), weak/resistive pull up (PU). Input buffer on.
For GPIOV1P2_I2C: Weak pull down only.</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DM1</name>
                <description>The GPIO drive mode for IO pad 1.</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM2</name>
                <description>The GPIO drive mode for IO pad 2.</description>
                <bitRange>[8:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM3</name>
                <description>The GPIO drive mode for IO pad 3.</description>
                <bitRange>[11:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM4</name>
                <description>The GPIO drive mode for IO pad 4.</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM5</name>
                <description>The GPIO drive mode for IO pad 5.</description>
                <bitRange>[17:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM6</name>
                <description>The GPIO drive mode for IO pad 6.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM7</name>
                <description>The GPIO drive mode for IO pad 7.</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_VTRIP_SEL</name>
                <description>The GPIO cells include a VTRIP_SEL signal to alter the input buffer voltage. Note: this bit is ignored for SIO ports, the VTRIP_SEL settings in the SIO register are used instead (a separate VTRIP_SEL is provided for each pin pair).
0: input buffer functions as a CMOS input buffer.
1: input buffer functions as a LVTTL input buffer.
For GPIOV1P2 and GPIOV1P_I2C cells, PC.PORT_VTRIP_SEL is unused. Refer to DS register</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLOW</name>
                <description>This field controls the output edge rate of all pins on the port:
'0': fast.
'1': slow.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_HYST_TRIM</name>
                <description>This field is used to improve the hysteresis (to 10 percent of vddio) of the selectable trip point input buffer. The voltage reference comes from the VREFGEN block and is only available when using the VREFGEN block:
'0': &lt;= 2.2 V input signaling Voltage.
'1': &gt; 2.2 V input signaling Voltage.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLEW_CTL</name>
                <description>Slew control. Only used in the O_Z drive mode (mode 4: strong pull down, open drain): This field is intended for I2C functionality. See BROS 001-70428 for more details.</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_0</name>
                    <description>HS mode (100pf &lt; Cb &lt; 400pF, 1.71&lt;VDDD&lt;5.5, Vext&gt;3.0)
FS mode (10pf&lt;Cb&lt;400pf,1.71&lt;VDDD&lt;5.5) (20-160ns)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_1</name>
                    <description>HS mode (Cb&lt;100pf,1.71&lt;VDDD&lt;5.5,Vext&gt;2.8,F=1.7MHz) (10-80ns)
FS+ Mode (Vext&gt;2.8,1.71&lt;VDDD&lt;5.5) (20-120ns)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_2</name>
                    <description>HS mode (100pf&lt;Cb&lt;400pf, 1.71&lt;VDDD&lt;5.5,Vext&lt;3.3) (20-160ns)</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_3</name>
                    <description>HS mode (Cb&lt;100pf,1.71&lt;VDDD&lt;5.5,Vext&lt;=2.8,F=1.7MHz) (10-80ns)
FS+ mode (Vext&lt;=2.8,1.71&lt;VDDD&lt;5.5) (20-120ns)</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PORT_IB_MODE_SEL</name>
                <description>This field selects the input buffer reference. The size (1 or 2 bits) and functionality is dependent on the IO cell.
For GPIOv2 IO cells, bit PORT_IB_MODE_SEL[1] is not used (GPIOv2 IO cell replaces GPIO IO cell):
'0'/'2': CMOS input buffer (PORT_VTRIP_SEL is '0'), LVTTL input buffer (PORT_VTRIP_SEL is '1')
'1'/'3': vcchib.
For GPIO_OVTv2 and SIOv2 IO cells:
'0': CMOS input buffer (PORT_VTRIP_SEL is '0'), LVTTL input buffer (PORT_VTRIP_SEL is '1')
'1': vcchib.
'2': OVT.
'3': Reference (possibly from reference generator cell).
For SIO IO cell, this field is present but not used as the SIO IO cell does not provide input buffer mode select functionality (SIOv2 IO cell will replace SIO IO cell, as soon as it is available).
For GPIOV1P2 and GPIOV1P2_I2C cells, PC.PORT_IB_MODE_SEL unused. Refer to DS register.</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 0.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 1.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 2.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 3.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 4.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 5.</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 6.</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 7.</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Same for the glitch filtered pin (selected by FLT_SELECT).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>Interrupt pending on IO pad 0. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>Interrupt pending on IO pad 1. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>Interrupt pending on IO pad 2. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>Interrupt pending on IO pad 3. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>Interrupt pending on IO pad 4. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>Interrupt pending on IO pad 5. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>Interrupt pending on IO pad 6. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>Interrupt pending on IO pad 7. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Deglitched interrupt pending (selected by FLT_SELECT).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PS_DATA0</name>
                <description>`</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA1</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA2</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA3</name>
                <description>N/A</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA4</name>
                <description>N/A</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA5</name>
                <description>N/A</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA6</name>
                <description>N/A</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA7</name>
                <description>N/A</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_FLT_DATA</name>
                <description>This is a duplicate of the contents of the PS register, provided here to allow reading of both pin state and interrupt state of the port in a single read operation.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIO</name>
            <description>Port SIO configuration register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PAIR_VREG01_EN</name>
                <description>Selects output buffer mode:
0: unregulated output buffer
1: regulated output buffer</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF01_SEL</name>
                <description>Selects input buffer mode:
0: singled ended input buffer
1: differential input buffer</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP01_SEL</name>
                <description>Selects trip-point of input buffer. In single ended input buffer mode (IBUF01_SEL = '0'):
0: input buffer functions as a CMOS input buffer.
1: input buffer functions as a LVTTL input buffer.
In differential input buffer mode (IBUF01_SEL = '1')
'0': trip-point is 0.5*Vddio or 0.5*Voh (depends on VREF_SEL/VOH_SEL)
'1': trip-point is 0.4*Vddio or 1.0*Vref  (depends on VREF_SEL)

Please refer to s8iom0s8 BROS 001-70428, section 4.2.7  for more details.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF01_SEL</name>
                <description>Selects reference voltage Vref for trip-point of input buffer:
0: trip-point reference of SRSS internal referece Vref (1.2V)
1: trip-point reference of SRSS internal referece Vref (1.2V)
2: trip-point reference of AMUXBUS_A
3: trip-point reference of AMUXBUS_B

Please refer to s8iom0s8 BROS 001-70428, section 4.2.7 for more details.</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH01_SEL</name>
                <description>Selects regulated Voh output level and trip point of input buffer for a specific SIO pin pair. Voh depends on the selected reference voltage (VREF_SEL). 
0: Voh = 1*reference; e.g. reference at 1.2V -&gt; Voh = 1.2V 
1: Voh = 1.25*reference; e.g. reference at 1.2V -&gt; Voh = 1.5V
2: Voh = 1.49*reference; e.g. reference at 1.2V -&gt; Voh = ~1.8V
3: Voh = 1.67*reference; e.g. reference at 1.2V -&gt; Voh = 2V
4: Voh = 2.08*reference; e.g. reference at 1.2V -&gt; Voh = 2.5V
5: Voh = 2.5*reference; e.g. reference at 1.2V -&gt; Voh = 3V
6: Voh = 2.78*reference; e.g. reference at 1.2V -&gt; Voh = ~3.3V
7: Voh = 4.16*reference; e.g. reference at 1.2V -&gt; Voh = 5.0V
Note: The upper value on VOH is limited to Vddio - 400mV</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG23_EN</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF23_SEL</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP23_SEL</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF23_SEL</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH23_SEL</name>
                <description>See corresponding definition for IO pads 2 and 3.</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG45_EN</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF45_SEL</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP45_SEL</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF45_SEL</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH45_SEL</name>
                <description>See corresponding definition for IO pads 4 and 5.</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG67_EN</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF67_SEL</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP67_SEL</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF67_SEL</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[28:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH67_SEL</name>
                <description>See corresponding definition for IO pads 6 and 7.</description>
                <bitRange>[31:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC2</name>
            <description>Port configuration register 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>INP_DIS0</name>
                <description>Disables the input buffer for IO pad 0 independent of the port control drive mode (PC.DM). This bit should be set when analog signals are present on the pin and PC.DM != 0 is required to use the output driver.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS1</name>
                <description>Disables the input buffer for IO pad 1.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS2</name>
                <description>Disables the input buffer for IO pad 2.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS3</name>
                <description>Disables the input buffer for IO pad 3.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS4</name>
                <description>Disables the input buffer for IO pad 4.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS5</name>
                <description>Disables the input buffer for IO pad 5.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS6</name>
                <description>Disables the input buffer for IO pad 6.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS7</name>
                <description>Disables the input buffer for IO pad 7.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_SET</name>
            <description>Port output data set register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '1'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_CLR</name>
            <description>Port output data clear register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '0'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_INV</name>
            <description>Port output data invert register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] inverted ('0' =&gt; '1', '1' =&gt; '0').</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DS</name>
            <description>Port drive strength register</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1AAAA</resetValue>
            <resetMask>0x3FFFF</resetMask>
            <fields>
              <field>
                <name>DS0</name>
                <description>The GPIO drive strength for IO pad 0.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>0</name>
                    <description>Refer to s8iom0s8v1p2 BROS Table11.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>1</name>
                    <description>Refer to s8iom0s8v1p2 BROS Table11.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>2</name>
                    <description>Refer to s8iom0s8v1p2 BROS Table11.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>3</name>
                    <description>Refer to s8iom0s8v1p2 BROS Table11.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DS1</name>
                <description>The GPIO drive strength for IO pad 1.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS2</name>
                <description>The GPIO drive strength for IO pad 2.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS3</name>
                <description>The GPIO drive strength for IO pad 3.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS4</name>
                <description>The GPIO drive strength for IO pad 4.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS5</name>
                <description>The GPIO drive strength for IO pad 5.</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS6</name>
                <description>The GPIO drive strength for IO pad 6.</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS7</name>
                <description>The GPIO drive strength for IO pad 7.</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_V1P2_VTRIP_SEL</name>
                <description>For GPIOV1P2:
  0: 1.2V VDDIO 
  1: 1.8V VDDIO
For GPIOV1P_I2C cells:
Used in conjunction with PORT_V1P2_IB_MODE_SEL
   PORT_V1P2_VTRIP_SEL,PORT_V1P2_IB_MODE_SEL
   0,0 - VDDIO 1.2V and VDDI2C 1.2V
   1,1 - VDDIO 1.2V and VDDI2C 1.8V
   0,0 - VDDIO 1.8V and VDDI2C 1.8V
   All other combinations are illegal</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_V1P2_IB_MODE_SEL</name>
                <description>For GPIOV1P2 cell,
0: vtrip_sel register controls the vtrip_sel of the IO cells
1: vddio detect cell output controls the vtrip_sel of the IO cells
For GPIOV1P2_I2C cells, refer to PORT_VTRIP_SEL description for usage.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FILT_CONFIG</name>
            <description>IO filter config register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIM0</name>
                <description>trim bits for 50ns filter on IO pad 0</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM1</name>
                <description>trim bits for 50ns filter on IO pad 1</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM2</name>
                <description>trim bits for 50ns filter on IO pad 2</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM3</name>
                <description>trim bits for 50ns filter on IO pad 3</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM4</name>
                <description>trim bits for 50ns filter on IO pad 4</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM5</name>
                <description>trim bits for 50ns filter on IO pad 5</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM6</name>
                <description>trim bits for 50ns filter on IO pad 6</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM7</name>
                <description>trim bits for 50ns filter on IO pad 7</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT0_EN</name>
                <description>Filter selection for IO pad 0</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT1_EN</name>
                <description>Filter selection for IO pad 1</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT2_EN</name>
                <description>Filter selection for IO pad 2</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT3_EN</name>
                <description>Filter selection for IO pad 3</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT4_EN</name>
                <description>Filter selection for IO pad 4</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT5_EN</name>
                <description>Filter selection for IO pad 5</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT6_EN</name>
                <description>Filter selection for IO pad 6</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT7_EN</name>
                <description>Filter selection for IO pad 7</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>VREFGEN</name>
            <description>Reference generator configuration register</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x11F</resetMask>
            <fields>
              <field>
                <name>REF_SEL</name>
                <description>Reference selection. A reference Voltage vinref is created using a Voltage vddio:
'0': vinref = (0 * 13 + 184)/600 * vddio = 184/600 * vddio.
'1': vinref = (1 * 13 + 184)/600 * vddio = 197/600 * vddio.
'2': vinref = (2 * 13 + 184)/600 * vddio = 210/600 * vddio.
...
'31': vinref = (31 * 13 + 184)/600 * vddio = 587/600 * vddio.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREFGEN_EN</name>
                <description>Reference generator enable:
'0': Disabled.
'1': Enabled.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt port cause register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a shared/combined interrupt line 'gpio_interrupt'. The SW ISR reads the register to deternine which IO port(s) is responsible for the shared/combined interrupt line 'gpio_interrupt'. Once, the IO port(s) is determined, the IO port's INTR register is read to determine the IO pad(s) in the IO port that caused the interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOV1P2_DET</name>
          <description>GPIOV1P2 Detect output</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>DET</name>
              <description>Indicates HI when VDDIO is in 1.8V range, and LOW when VDDIO is in 1.2V range.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PRGIO</name>
      <description>Programmable IO configuration</description>
      <baseAddress>0x40050000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>3</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>Programmable IO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2001400</resetValue>
            <resetMask>0x82001F00</resetMask>
            <fields>
              <field>
                <name>BYPASS</name>
                <description>Bypass of the programmable IO, one bit for each IO pin: BYPASS[i] is for IO pin i. When ENABLED is '1', this field is used. When ENABLED is '0', this field is NOT used and PRGIO is always bypassed.
'0': No bypass (programmable IO fabric is exposed). 
'1': Bypass (programmable IO fabric is hidden).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLOCK_SRC</name>
                <description>Clock ('clk_fabric') and reset ('rst_fabric_n') source selection:
'0': io_data_in[0]/'1'.
...
'7': io_data_in[7]/'1'.
'8': chip_data[0]/'1'.
...
'15': chip_data[7]/'1'.
'16': clk_prgio/rst_sys_act_n. Used for both Active functionality synchronous logic on 'clk_prgio'. This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_prgio_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'17': clk_prgio/rst_sys_dpslp_n. Used for both DeepSleep functionality synchronous logic on 'clk_prgio' (note that 'clk_prgio' is NOT available in DeepSleep and Hibernate power modes).  This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_prgio_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'18': clk_prgio/rst_sys_hib_n. Used for both Hibernate functionality synchronous logic on 'clk_prgio' (note that 'clk_prgio' is NOT available in DeepSleep and Hibernate power modes).  This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_prgio_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'19': clk_lf/rst_lf_dpslp_n (note that 'clk_lf' is only available in DeepSleep power mode). This selection is intended for synchronous operation on'clk_lf'. Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to other 'clk_lf' clocked elements.
'20'-'30': Clock source is constant '0'. Any of these clock sources should be selected when the IP is disabled to ensure low power consumption.
'31': clk_sys/'1'. This selection is NOT intended for 'clk_sys' operation, but for asynchronous operation: three 'clk_sys' cycles after enabling the IP, the IP is fully functional (reset is de-activated). To be used for asynchronous (clockless) fabric functionality.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HLD_OVR</name>
                <description>IO cell hold override functionality. In DeepSleep and Hibernate power modes, the HSIOM holds the IO cell output and output enable signals if Active functionality is connected to the IO pads. This is undesirable if the PRGIO is supposed to deliver DeepSleep or Hibernate output functionality on these IO pads. This field is used to control the hold override functionality from the PRGIO:
'0': The HSIOM controls the IO cell hold override functionality ('hsiom_hld_ovr').
'1': The PRGIO controls the IO cel hold override functionality:
- In bypass mode (ENABLED is '0' or BYPASS[i] is '1'), the HSIOM control is used.
- In NON bypass mode (ENABLED is '1' and BYPASS[i] is '0'), the PRGIO sets hold override to 'pwr_hld_ovr_hib' to enable PRGIO functionality in DeepSleep and Hibernate power modes (but disables it in Stop power mode).

Note that in Hibernate power mode, the PRGIO should not rely on the state of Active or DeepSleep functionality signals from the HSIOM: these signals are clamped to '0' in Hibernate'</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PIPELINE_EN</name>
                <description>Enable for pipeline register:
'0': Disabled (register is bypassed).
'1': Enabled.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Enable for programmable IO. Should only be set to '1' when the programmable IO is completely configured:
'0': Disabled (signals are bypassed; behavior as if BYPASS is 0xFF). When disabled, the fabric (data unit and LUTs) reset is activated.

If the IP is disabled:
- The PIPELINE_EN register field should be set to '1', to ensure low power consumption by preventing combinatorial loops.
- The CLOCK_SRC register field should be set to '20'-'30' (clock is constant '0'), to ensure low power consumption.

'1': Enabled. Once enabled, it takes 3 'clk_fabric' clock cycles till the fabric reset is de-activated and the fabric becomes fully functional. This ensures that the IO pins' input synchronizer states are flushed when the fabric is fully functional.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYNC_CTL</name>
            <description>Synchronization control register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>IO_SYNC_EN</name>
                <description>Synchronization of the IO pin input signals to 'clk_fabric', one bit for each IO pin: IO_SYNC_EN[i] is for IO pin i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHIP_SYNC_EN</name>
                <description>Synchronization of the chip input signals to 'clk_fabric', one bit for each input: CHIP_SYNC_EN[i] is for input i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_SEL[%s]</name>
            <description>LUT component input selection</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT_TR0_SEL</name>
                <description>LUT input signal 'tr0_in' source selection:
'0': Data unit output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR1_SEL</name>
                <description>LUT input signal 'tr1_in' source selection:
'0': LUT 0 output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR2_SEL</name>
                <description>LUT input signal 'tr2_in' source selection. Encoding is the same as for LUT_TR1_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_CTL[%s]</name>
            <description>LUT component control register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT</name>
                <description>LUT configuration. Depending on the LUT opcode LUT_OPC, the internal state lut_reg (captured in a flip-flop) and the LUT input signals tr0_in, tr1_in, tr2_in, the LUT configuration is used to determine the LUT output signal and the next sequential state (lut_reg).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_OPC</name>
                <description>LUT opcode specifies the LUT operation:
'0': Combinatoral output, no feedback.
   tr_out   = LUT[{tr2_in, tr1_in, tr0_in}].
'1': Combinatorial output, feedback.
   tr_out   = LUT[{lut_reg, tr1_in, tr0_in}].
On clock:
    lut_reg &lt;= tr_in2.
'2': Sequential output, no feedback.
   temp    = LUT[{tr2_in, tr1_in, tr0_in}].
   tr_out   = lut_reg.
On clock:
   lut_reg &lt;= temp.
'3': Register with asynchronous set and reset.
   tr_out           = lut_reg.
   enable          = (tr2_in ^ LUT[4]) | LUT[5].
   set               = enable &amp; (tr1_in ^ LUT[2]) &amp; LUT[3].
   clr                = enable &amp; (tr0_in ^ LUT[0]) &amp; LUT[1].
Asynchronously (no clock required):
   lut_reg         &lt;= if (clr) '0' else if (set) '1'</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_SEL</name>
            <description>Data unit component input selection</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_TR0_SEL</name>
                <description>Data unit input signal 'tr0_in' source selection:
'0': Constant '0'.
'1': Constant '1'.
'2': Data unit output.
'10-3': LUT 7 - 0 outputs.
Otherwise: Undefined.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR1_SEL</name>
                <description>Data unit input signal 'tr1_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR2_SEL</name>
                <description>Data unit input signal 'tr2_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA0_SEL</name>
                <description>Data unit input data 'data0_in' source selection:
'0': Constant '0'.
'1': chip_data[7:0].
'2': io_data_in[7:0].
'3': DATA.DATA MMIO register field.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA1_SEL</name>
                <description>Data unit input data 'data1_in' source selection. Encoding is the same as for DU_DATA0_SEL.</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_CTL</name>
            <description>Data unit component control register</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_SIZE</name>
                <description>Size/width of the data unit data operands (in bits) is DU_SIZE+1. E.g., if DU_SIZE is 7, the width is 8 bits.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_OPC</name>
                <description>Data unit opcode specifies the data unit operation:
'1': INCR
'2': DECR
'3': INCR_WRAP
'4': DECR_WRAP
'5': INCR_DECR
'6': INCR_DECR_WRAP
'7': ROR
'8': SHR
'9': AND_OR
'10': SHR_MAJ3
'11': SHR_EQL.
Otherwise: Undefined.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA</name>
            <description>Data register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data unit input data source.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS</name>
      <description>CPU Subsystem</description>
      <baseAddress>0x40100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>ioss_interrupts_gpio_0</name>
        <description>GPIO P0</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_1</name>
        <description>GPIO P1</description>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_2</name>
        <description>GPIO P2</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_3</name>
        <description>GPIO P3</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_gpio</name>
        <description>GPIO All Ports</description>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>lpcomp_interrupt</name>
        <description>LPCOMP trigger interrupt</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>srss_interrupt_wdt</name>
        <description>WDT</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>scb_0_interrupt</name>
        <description>SCB #0</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>scb_1_interrupt</name>
        <description>SCB #1</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>scb_2_interrupt</name>
        <description>SCB #2</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>scb_3_interrupt</name>
        <description>SCB #3</description>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>scb_4_interrupt</name>
        <description>SCB #4</description>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>pass_0_interrupt_ctbs</name>
        <description>CTBm Interrupt (all CTBms)</description>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>wco_interrupt</name>
        <description>WCO WDT Interrupt</description>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_dma</name>
        <description>DMA Interrupt</description>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_spcif</name>
        <description>SPCIF interrupt</description>
        <value>15</value>
      </interrupt>
      <interrupt>
        <name>msc_0_interrupt</name>
        <description>CSD #0 (Primarily Capsense)</description>
        <value>16</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_0</name>
        <description>TCPWM #0, Counter #0</description>
        <value>17</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_1</name>
        <description>TCPWM #0, Counter #1</description>
        <value>18</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_2</name>
        <description>TCPWM #0, Counter #2</description>
        <value>19</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_3</name>
        <description>TCPWM #0, Counter #3</description>
        <value>20</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_4</name>
        <description>TCPWM #0, Counter #4</description>
        <value>21</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_5</name>
        <description>TCPWM #0, Counter #5</description>
        <value>22</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_6</name>
        <description>TCPWM #0, Counter #6</description>
        <value>23</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_7</name>
        <description>TCPWM #0, Counter #7</description>
        <value>24</value>
      </interrupt>
      <interrupt>
        <name>pass_0_interrupt_sar</name>
        <description>SAR</description>
        <value>25</value>
      </interrupt>
      <interrupt>
        <name>canfd_interrupts0_0</name>
        <description>CAN Interrupt</description>
        <value>26</value>
      </interrupt>
      <interrupt>
        <name>canfd_interrupts1_0</name>
        <description>CAN Interrupt</description>
        <value>27</value>
      </interrupt>
      <interrupt>
        <name>crypto_interrupt</name>
        <description>Crypto Interrupt</description>
        <value>28</value>
      </interrupt>
      <interrupt>
        <name>msc_1_interrupt</name>
        <description>CSD #0 (Primarily Capsense)</description>
        <value>29</value>
      </interrupt>
      <interrupt>
        <name>exco_interrupt</name>
        <description>EXCO</description>
        <value>30</value>
      </interrupt>
      <interrupt>
        <name>audioss_interrupt_i2s</name>
        <description>I2S Interrupt</description>
        <value>31</value>
      </interrupt>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>Configuration register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>VECT_IN_RAM</name>
              <description>0': Vector Table is located at 0x0000:0000 in flash
'1': Vector Table is located at 0x2000:0000 in SRAM
Note that vectors for RESET and FAULT are always fetched from ROM. Value in flash/RAM is ignored for these vectors.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSREQ</name>
          <description>SYSCALL control register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30000000</resetValue>
          <resetMask>0xF800FFFF</resetMask>
          <fields>
            <field>
              <name>SYSCALL_COMMAND</name>
              <description>Opcode of the system call being requested.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_RESET_VECT_REL</name>
              <description>Disable Reset Vector fetch relocation:
'0': CPU accesses to locations 0x0000:0000 - 0x0000:0007 are redirected to ROM.
'1': CPU accesses to locations 0x0000:0000 - 0x0000:0007 are made to flash.
Note that this field defaults to '0' on reset, ensuring actual reset vector fetches are always made to ROM. Note that this field does not affect DAP accesses. Flash DfT routines may set this bit to '1' to enable uninhibited read-back of programmed data in the first flash page.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRIVILEGED</name>
              <description>Indicates whether the system is in privileged ('1') or user mode ('0'). Only CPU SW executing from ROM can set this field to '1' when ROM_ACCESS_EN is '1' (the CPU is executing a SystemCall NMI interrupt handler). Any other write to this field sets is to '0'. This field is used as the AHB-Lite hprot[1] signal to implement Cypress proprietary user/privileged modes. These modes are used to enable/disable access to specific MMIO registers and memory regions.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ROM_ACCESS_EN</name>
              <description>Indicates that executing from Boot ROM is enabled. HW sets this field to '1', on reset or when the SystemCall NMI vector is fetched from Boot ROM. HW sets this field to '0', when the CPU is NOT executing from either Boot or System ROM. This bit is used for debug purposes only.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HMASTER_0</name>
              <description>Indicates the source of the write access to the SYSREQ register.
'0': CPU write access.
'1': DAP write access.
HW sets this field when the SYSREQ register is written to and SYSCALL_REQ is '0' (the last time it is set is when SW sets SYSCALL_REQ from '0' to '1').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSCALL_REQ</name>
              <description>CPU/DAP writes a '1' to this field to request a SystemCall. The HMASTER_0 field indicates the source of the write access. Setting this field to '1' immediate results in a NMI. The SystemCall NMI interrupt handler sets this field to '0' after servicing the request.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSARG</name>
          <description>SYSARG control register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SYSCALL_ARG</name>
              <description>Argument to System Call specified in SYSREQ. Semantics of argument depends on system call made. Typically a pointer to a parameter block.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PROTECTION</name>
          <description>Protection control register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF</resetValue>
          <resetMask>0xC000000F</resetMask>
          <fields>
            <field>
              <name>PROTECTION_MODE</name>
              <description>Current protection mode; this field is available as a global signal everywhere in the system. Writes to this field are ignored when PROTECTION_LOCK is '1':
0b1xxx: BOOT
0b01xx: KILL
0b001x: PROTECTED
0b0001: OPEN
0b0000: VIRGIN (also used for DEAD mode, but then FLASH_LOCK is also set)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_LOCK</name>
              <description>Setting this bit will force SPCIF.ADDRESS.AXA to be ignored, which prevents SM Flash from being erased or overwritten. It is used to indicate the DEAD protection mode. Writes to this field are ignored when PROTECTION_LOCK is '1'</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PROTECTION_LOCK</name>
              <description>Setting this field will block (ignore) any further writes to the PROTECTION_MODE field in this register. Once '1', this field cannot be cleared.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_ROM</name>
          <description>ROM privilege register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF00FF</resetMask>
          <fields>
            <field>
              <name>BROM_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of the Boot ROM partition starts in increments of 256 Bytes.
'0':  Entire Boot ROM is Privileged.
'1':  First 256 Bytes are User accessable.
...
BROM_PROT_LIMIT &gt;= 'Boot ROM partition capacity': Entire Boot ROM partition is user mode accessible.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SROM_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of System ROM partition starts in increments of 256 Bytes. The limit is wrt. the start of the ROM memory (start of the Boot ROM partition).
SROM_PROT_LIMIT * 256 Byte &lt;= 'Boot ROM partition capacity':  Entire System ROM is Privileged.
SROM_PROT_LIMIT * 256 Byte &gt; 'Boot ROM partition capacity':  First SROM_PROT_LIMIT * 256 - 'Boot ROM partition capacity' Bytes are User accessable.
...
SROM_PROT_LIMIT &gt;= 'ROM capacity': Entire System ROM is user mode accessible.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_RAM</name>
          <description>RAM privilege register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>RAM_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of SRAM starts in increments of 256 Bytes.
'0':  Entire SRAM is Privileged.
'1':  First 256 Bytes are User accessable.

Any number larger than the size of the SRAM indicates that the entire SRAM is user mode accessible.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_FLASH</name>
          <description>Flash privilege register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>FLASH_PROT_LIMIT</name>
              <description>Indicates the limit where the privileged area of flash starts in increments of 256 Bytes.
'0':  Entire flash is Privileged.
'1':  First 256 Bytes are User accessable.

Any number larger than the size of the flash indicates that the entire flash is user mode accessible. Note that SuperVisory rows are always User accessable.

If FLASH_PROT_LIMIT defines a non-empty privileged area, the boot ROM will assume that a system call table exists at the beginning of the Flash privileged area and use it for all SystemCalls made using SYSREQ.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WOUNDING</name>
          <description>Wounding register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7770000</resetMask>
          <fields>
            <field>
              <name>RAM_WOUND</name>
              <description>Indicates the amount of accessible RAM 0 memory capacitty in this part. The value in this field is effectively write-once (it is only possible to set bits, not clear them). The remainder portion of SRAM is not accessible and will return an AHB-Lite bus error.
'0': entire memory accessible
'1': first 1/2 of the memory accessible
'2': first 1/4 of the memory accessible
'3': first 1/8 of the memory accessible
'4': first 1/16 of the memory accessible
'5': first 1/32 of the memory accessible
'6': first 1/64 of the memory accessible
'7': first 1/128 of the memory accessible</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_WOUND</name>
              <description>Indicates the amount of accessible flash in this part. The value in this field is effectively write-once (it is only possible to set bits, not clear them). The remainder portion of flash is not accessible and will return an AHB-Lite bus error.
'0': entire memory accessible
'1': first 1/2 of the memory accessible
'2': first 1/4 of the memory accessible
'3': first 1/8 of the memory accessible
'4': first 1/16 of the memory accessible
'5': first 1/32 of the memory accessible
'6': first 1/64 of the memory accessible
'7': first 1/128 of the memory accessible (used for the DEAD protection mode)</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAM1_WOUND</name>
              <description>Wounding of RAM 1 (see description of RAM_WOUND).</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_SEL</name>
          <description>Interrupt multiplexer select register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSI</name>
              <description>Specifies interrupt source:
'0': Fixed Function.
'1': DSI.
When changing the source of a specific interrupt, it is advised to temporarily disable the interrupt using the CM0 NVIC's CLRENA and SETENA interrupt enable clear and set registers to prevent a spurious interrupt activation. In addition, the CM0 NVIC's CLRPEND interrupt pending clear register should be used clear a pending interrupt before re-enabling the interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MODE</name>
          <description>DSI interrupt pulse mode register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSI_INT_PULSE</name>
              <description>Specifies DSI interrupt format:
'0': level sensitive; i.e. no pulse generator.
'1': pulse generator on rising edge.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NMI_MODE</name>
          <description>DSI NMI pulse mode register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>DSI_NMI_PULSE</name>
              <description>Specifies DSI NMI format:
'0': level sensitive; i.e. no pulse generator.
'1': pulse generator on rising edge.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_CTL</name>
          <description>FLASH control register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30113</resetMask>
          <fields>
            <field>
              <name>FLASH_WS</name>
              <description>Amount of ROM wait states:
'0': 0 wait states (fast flash: [0, 24] MHz system frequency, slow flash: [0, 16] MHz system frequency)
'1': 1 wait state (fast flash: [24, 48] MHz system frequency, slow flash: [16, 32] MHz system frequency)
'2': 2 wait states (slow flash: [32, 48] MHz system frequency)
'3': 3 wait states (can be used to give more time for flash access if 2 wait states are not sufficient)</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
'0': disabled. This is a desirable seeting when FLASH_WS is '0' or when predictable execution behavior is required.
'1': enabled.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_INVALIDATE</name>
              <description>1': Invalidates the content of the flash controller's buffers.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ROM_CTL</name>
          <description>ROM control register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30001</resetMask>
          <fields>
            <field>
              <name>ROM_WS</name>
              <description>Amount of ROM wait states:
'0': 0 wait states. Use this setting for newer, faster ROM design. Use this setting for older, slower ROM design and frequencies in the range [0, 24] MHz.
'1': 1 wait state. Use this setting for older, slower ROM design and frequencies in the range &lt;24, 48] MHz.

CPUSSv2 supports two types of ROM memory: an older, slower design (operating at up to 24 MHz) and a newer, faster design (operating at up to 48 MHz). The older design requires 1 wait state for frequencies above 24 MHz. The newer design never requires wait states. All chips after Street Fighter will use the newer design. As a result, all chips after Street Fighter can always use 0 wait states.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_CTL</name>
          <description>RAM control register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CTL</name>
          <description>DMA controller register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PRIV_RAM1</name>
          <description>RAM 1 privilege register</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1FF</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>RAM_PROT_LIMIT</name>
              <description>See description of PRIV_RAM.RAM_PROT_LIMIT. Note that the reset value is 0x1ff, indicating that the complete RAM 1 memory capacity is User accessable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_CTL</name>
          <description>RAM 1 control register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy (for RAM controller 1):
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MTB_CTL</name>
          <description>MTB control register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>CPU_HALT_TSTOP_EN</name>
              <description>1': Enable CPU Halt to stop MTB trace. ('HALTED' output of CM0+ can stop the trace when high/'1')
'0': 'HALTED' output of CM0+ can not strop trace.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>24</dim>
          <dimIncrement>4</dimIncrement>
          <name>SL_CTL[%s]</name>
          <description>Slave control register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
'0': CPU priority
'1': DMA priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DMAC</name>
      <description>DataWire/DMA Controller</description>
      <baseAddress>0x40101000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>0': IP is disabled. Non-retainable MMIO registers and logic functionality are reset (retainable MMIO registers are NOT reset):
- INTR register is set to '0'.
- DW/DMA functionality is aborted.
- DW/DMA controller input/pending triggers are de-activated.
- DW/DMA controller output triggers are de-activated.
Disabling the IP has the same effect as an active 'rst_sys_act_n' reset in DeepSleep power mode. To prevent a loss of active (pending) DW/DMA triggers when disabling the IP or when transitioning from Active to DeepSleep power mode, the STATUS.ACTIVE and STATUS_CH_ACT.CH fields can be used.

Note that most MMIO registers are retainable, and a transition from DeepSleep to Active/Sleep power modes makes the DW/DMA controller operational, and ready to react to DW/DMA input triggers that are activated after the transition. Triggers are Active/Sleep functionality.
'1': IP is enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x87000000</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Specifies the index of the currently active data transfer. This value increases from '0' to CONTROL.DATA_NR.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_ADDR</name>
              <description>Specifies the channel number of the currently active channel. E.g. if we have 32 channels, the channel number address with CH_ADDR_WIDTH is LOG2 (32) = 5, and this field is a 5-bit field. If channel 7 is active, STATUS.ACTIVE is '1' and STATUS.CH_ADDR is '7'.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the data transfer engine. 
'0': DEFAULT state.
'1': Loading descriptor (SRC, DST, CONTROL and STATUS words).
'2': Loading data element from source location.
'3': Storing data element to destination location.
'4': Storing descriptor (STATUS word).
'5': Wait for trigger de-activation.
'6': Storing descriptor with error response (STATUS word).</description>
              <bitRange>[26:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRIO</name>
              <description>Specifies the priority of the currently active channel.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Specifies the descriptor of the channel is currently in use.
'0' - PING descriptor 
'1' - PONG descriptor</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Specifies if there is a currently active (pending) channel in the data transfer engine: 
'0': no currently active channel.
'1': currently active channel.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS_SRC_ADDR</name>
          <description>Source address status register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Base address or current address of source location of currently active channel. The specific address information is cycle dependent. This field is provided for debug purposes. Functionally, no assumption should be made on whether the base or current address is provided. The specifics of the currently active channel are available through STATUS. Note while reading the STATUS, STATUS_SRC_ADDR and STATUS_DST_ADDR registers, the transfer engine may have moved from one active channel to another.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS_DST_ADDR</name>
          <description>Destination address register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Base address or current address of destination location of currently active channel. The specific address information is cycle dependent. This field is provided for debug purposes. Functionally, no assumption should be made on whether the base or current address is provided. The specifics of the currently active channel are available through STATUS. Note while reading the STATUS, STATUS_SRC_ADDR and STATUS_DST_ADDR registers, the transfer engine may have moved from one active channel to another.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS_CH_ACT</name>
          <description>Channel activation status register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Channel activation status. Bit i is associated to channel i, with i = 0, ..., CH_NR-1.

Software reads this field to get information on all actively pending channels (either in pending or in the data transfer engine).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>32</dim>
          <dimIncrement>4</dimIncrement>
          <name>CH_CTL[%s]</name>
          <description>Channel control register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>PRIO</name>
              <description>Channel priority, with '0' representing the highest priority and '3' representing the lowest priority. Priority decoding uses the channel priority to determine the highest priority activated channel. If multiple activated channels have the same highest priority, the channel with the lowest index i, is considered the highest priority activated channel.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Each channel has two descriptor structures for double buffering purposes. As the controller operates on one structure, the main CPU can operate on the other structure. The descriptor structures are identified as PING ('0') and PONG ('1'). This field identifies the descriptor structure that is currently in use by the controller.

Software sets this field to the desired descriptor structure.

Hardware inverts the field value on the completion of a descriptor structure when CONTROL.FLIPPING of the current descriptor structure is set to '1'.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>'0': channel disabled. The channel's trigger is ignored and the channel cannot be activated. If the activated channel is disabled, the data transfer(s) are aborted. 
'1': channel enabled.

Software sets this field to '1' to enable a specific channel.

Hardware sets this field to '0' on erroneous channel behavior (the specific error is specified by STATUS.RESP in the channel's descriptor structure).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x7F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x7F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x7F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Mask for corresponding field in INTR register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x7FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Logical BITWISE AND of corresponding request and mask fields.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>16</dim>
          <dimIncrement>32</dimIncrement>
          <name>DESCR[%s]</name>
          <description>Descriptors</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>PING_SRC</name>
            <description>Ping source address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Base address of source location. The effective source location is calculated by adding on offset (derived from PING.STATUS.CURR_DATA_NR) to this base address.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PING_DST</name>
            <description>Ping destination address</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Base address of destination location. The effective destination location is calculated by adding on offset (derived from PING.STATUS.CURR_DATA_NR) to this base address.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PING_CTL</name>
            <description>Ping control word</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA_NR</name>
                <description>Number of data elements that are transferred by a single descriptor.
In DW mode (OPCODE is '0') each trigger initiates the transfer of a single data element. This field specifies the source and/or destination buffer size in data elements: buffer size = DATA_NR+1. The buffer is typically associated to a memory structure.
In DMA mode (OPCODE is '1' or '2') each trigger initiates the transfer of DATA_NR+1 data elements.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_SIZE</name>
                <description>Specifies the data element size:
'0': Byte (8 bits).
'1': Halfword (16 bits).
'2': Word (32 bits).
DATA_SIZE, SRC_TRANSFER_SIZE and DST_TRANSFER_SIZE together determine how data elements are transferred. The following are the 9 legal settings:
- DATA is 8 bit, SRC is 8 bit, DST is 8 bit
- DATA is 8 bit, SRC is 32 bit (higher 24 bits are dropped), DST is 8 bit
- DATA is 8 bit, SRC is 8 bit, DST is 32 bit (higher 24 bits are made '0')
- DATA is 8 bit, SRC is 32 bit (higher 24 bits are dropped), DST is 32 bit (higher 24 bits are made '0')
- DATA is 16 bit, SRC is 16 bit, DST is 16 bit
- DATA is 16 bit, SRC is 32 bit (higher 16 bits are dropped), DST is 16 bit
- DATA is 16 bit, SRC is 16 bit, DST is 32 bit (higher 16 bits are made '0')
- DATA is 16 bit, SRC is 32 bit (higher 16 bits are dropped), DST is 32 bit (higher 16 bits are made '0')
- DATA is 32 bit, SRC is 32 bit, DST is 32 bit</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_TRANSFER_SIZE</name>
                <description>Specifies the bus transfer size to the destination location:
'0': As specified by DATA_SIZE.
'1': Word (32 bits).
Distinguishing bus transfer size from data element size allows for destination components with data elements that are smaller than their 32-bit bus interface width. E.g., a DAC destination has a 32-bit bus transfer size, but only requires a 16-bit data element.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_ADDR_INCR</name>
                <description>Specifies whether the destination location address is incremented by the DST_TRANSFER_SIZE after each single data element transfer or not.
'0' : No increment, typically used for transmit (TX) FIFO structures.
'1': Increment, typically used for memory structures.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_TRANSFER_SIZE</name>
                <description>Specifies the bus transfer size to the source location:
'0': As specified by DATA_SIZE.
'1': Word (32 bits).
Distinguishing bus transfer size from data element size allows for source components with data elements that are smaller than their 32-bit bus interface width. E.g., an ADC source has a 32-bit bus transfer size, but only provides a 16-bit data element.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_ADDR_INCR</name>
                <description>Specifies whether the source location address is incremented by the SRC_TRANSFER_SIZE after each single data element transfer or not.
'0': No increment, typically used for receive (RX) FIFO structures.
'1': Increment, typically used for memory structures.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAIT_FOR_DEACT</name>
                <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.
'0': Do not wait for de-activation (for pulse sensitive triggers).
'1': Wait for up to 4 cycles.
'2': Wait for up to 8 cycles.
'3': Wait indefinitely. This option may result in DW/DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INV_DESCR</name>
                <description>'1': On completion of the current descriptor structure, the VALID bit of the descriptor's STATUS word is set to '0'.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SET_CAUSE</name>
                <description>'1': On completion of the current descriptor structure, the interrupt cause field of the channel is set to '1' (INTR.CH[i]).</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREEMPTABLE</name>
                <description>'1': Transfer is preemptable. In DMA mode (OPCODE is '1' or '2'), multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLIPPING</name>
                <description>'1': On completion of the current descriptor structure, the current descriptor identifier CH_CTLi.PING_PONG is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OPCODE</name>
                <description>Specifies the specific data transfer (only when the VALID bit of the descriptor's STATUS word is '1'):

'0': A single trigger initiates a single data element transfer (DW mode). This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).

'1': A single trigger initiates a single descriptor transfer (DMA mode). This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.

'2': A single trigger initiates a descriptor list transfer (DMA mode). This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CH_CTLi.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).

After completerion of the opcode (and waiting for de-activation, the channel's output trigger is activated).</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PING_STATUS</name>
            <description>Ping status word</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>CURR_DATA_NR</name>
                <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field:
- When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.
- When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.
- In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.
HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'. 

This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESPONSE</name>
                <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).
'0'/NO_ERROR: No error. Setting this response does NOT set the interrupt cause bit to '1'. STATUS.VALID is NOT affected. CH_CTLi.ENABLED is NOT affected. CH_CTLi.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.
'1'/DONE: Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CH_CTLi.ENABLED is NOT affected. CH_CTLi.PING_PONG is updated if CONTROL.FLIPPING is '1'.
'2'/SRC_BUS_ERROR: Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CH_CTLi.ENABLED is set to '0'. CH_CTLi.PING_PONG is not updated (it identifies the descriptor that caused the error).
'3'/DST_BUS_ERROR: Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CH_CTLi.ENABLED is set to '0'. CH_CTLi.PING_PONG is not updated (it identifies the descriptor that caused the error).
'4'/SRC_MISAL: Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CH_CTLi.ENABLED is set to '0'. CH_CTLi.PING_PONG is not updated (it identifies the descriptor that caused the error).
'5'/DST_MISAL: Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CH_CTLi.ENABLED is set to '0'. CH_CTLi.PING_PONG is not updated (it identifies the descriptor that caused the error).
'6'/INVALID_DESCR: Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CH_CTLi.ENABLED is set to '0'. CH_CTLi.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>'0': Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code (and the interrupt cause bit is set to '1').
'1': Valid.

Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'.

Software sets this field to '1' when a descriptor is initialized.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PONG_SRC</name>
            <description>Pong source address</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>See description of PING_SRC.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PONG_DST</name>
            <description>Pong destination address</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>See description of PING_DST.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PONG_CTL</name>
            <description>Pong control word</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA_NR</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_SIZE</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_TRANSFER_SIZE</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_ADDR_INCR</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_TRANSFER_SIZE</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_ADDR_INCR</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAIT_FOR_DEACT</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INV_DESCR</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SET_CAUSE</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREEMPTABLE</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLIPPING</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OPCODE</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PONG_STATUS</name>
            <description>Pong status word</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>CURR_DATA_NR</name>
                <description>See description of PING_STATUS.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESPONSE</name>
                <description>See description of PING_STATUS.</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>See description of PING_STATUS.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPCIF</name>
      <description>Flash Control Interface</description>
      <baseAddress>0x40110000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GEOMETRY</name>
          <description>Flash/NVL geometry information</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>FLASH</name>
              <description>Regular flash capacity in 256 Byte multiples (chip dependent). If multiple flash macros are present, this field provides the flash capacity of all flash macros together:
'0': 256 Bytes.
'1': 2*256 Bytes.
...
'16383': 16384*256 Bytes.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SFLASH</name>
              <description>Supervisory flash capacity in 256 Byte multiples (chip dependent). If multiple flash macros are present, this field provides the supervisory flash capacity of all flash macros together:
'0': 256 Bytes.
'1': 2*256 Bytes.
...
'63': 64*256 Bytes.</description>
              <bitRange>[19:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_FLASH</name>
              <description>Number of flash macros (chip dependent):
'0': 1 flash macro
'1': 2 flash macros
'2': 3 flash macros
'3': 4 flash macros</description>
              <bitRange>[21:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FLASH_ROW</name>
              <description>Page size in 64 Byte multiples (chip dependent):
'0': 64 byte
'1': 128 byte
'2': 192 byte
'3': 256 byte

The page size is used to detemine the number of Bytes in a page for Flash page based operations (e.g. PGM_PAGE).

Note: the field name FLASH_ROW is misleading, as this field specifies the number of Bytes in a page, rather than the number of Bytes in a row. In a single plane flash macro architecture, a page consists of a single row. However, in a multi plane flash macro architecture, a page consists of multiple rows from different planes.</description>
              <bitRange>[23:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NVL</name>
              <description>NVLatch size in Byte multiples (chip dependent):
'0': 0 Bytes
'1': 1 Byte
...
'127': 127 Bytes</description>
              <bitRange>[30:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DE_CPD_LP</name>
              <description>0': SRAM busy wait loop has not been copied.
'1': Busy wait loop has been written into SRAM.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NVL_WR_DATA</name>
          <description>NVL write data register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data to be written to NVLatch array</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>SPCIF interrupt request register</description>
          <addressOffset>0x7F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Timer counter value reaches '0'. Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>SPCIF interrupt set request register</description>
          <addressOffset>0x7F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Write INTR_SET field with '1' to set corresponding INTR field.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>SPCIF interrupt mask register</description>
          <addressOffset>0x7F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Mask for corresponding field in INTR register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>SPCIF interrupt masked request register</description>
          <addressOffset>0x7FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Logical and of corresponding request and mask fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TCPWM</name>
      <description>Timer/Counter/PWM</description>
      <baseAddress>0x40200000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>TCPWM control register 0.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_ENABLED</name>
              <description>Counter enables for counters 0 up to CNT_NR-1.
'0': counter disabled.
'1': counter enabled.
Counter static configuration information (e.g. CTRL.MODE, all TR_CTRL0, TR_CTRL1, and TR_CTRL2 register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
- the associated counter triggers in the CMD register are set to '0'.
- the counter's interrupt cause fields in counter's INTR register.
- the counter's status fields in counter's STATUS register..
- the counter's trigger outputs ('tr_overflow', 'tr_underflow' and 'tr_compare_match').
- the counter's line outputs ('line_out' and 'line_compl_out').</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>TCPWM command register.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_CAPTURE</name>
              <description>Counters SW capture trigger. When written with '1', a capture trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.COUNTER_ENABLED, the field is immediately set to '0'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_RELOAD</name>
              <description>Counters SW reload trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_STOP</name>
              <description>Counters SW stop trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_START</name>
              <description>Counters SW start trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>TCPWM Counter interrupt cause register.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_INT</name>
              <description>Counters interrupt signal active. If the counter is disabled through CTRL.COUNTER_ENABLED, the associated interrupt field is immediately set to '0'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>64</dimIncrement>
          <name>CNT[%s]</name>
          <description>Timer/Counter/PWM Counter Module</description>
          <addressOffset>0x00000100</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Counter control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x737FF0F</resetMask>
            <fields>
              <field>
                <name>AUTO_RELOAD_CC</name>
                <description>Specifies switching of the CC and buffered CC values. This field has a function in TIMER, PWM, PWM_DT and PWM_PR modes.
Timer mode:
'0': never switch.
'1': switch on a compare match event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_RELOAD_PERIOD</name>
                <description>Specifies switching of the PERIOD and buffered PERIOD values. This field has a function in PWM, PWM_DT and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with and actively pending siwtch event.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_SYNC_KILL</name>
                <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the 'dt_line_out' and 'dt_line_compl_out' signals till the next terminal count event (synchronous kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the 'dt_line_out' and 'dt_line_compl_out' signals when present. In asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET. 

This field has a function in PWM and PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_STOP_ON_KILL</name>
                <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit control field. In PWM_DT mode, this field is used to determine the dead time: amount of dead time cycles in the counter clock domain. In all other modes, the lower 3 bits of this field determine pre-scaling of the selected counter clock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UP_DOWN_MODE</name>
                <description>Determines counter direction.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>COUNT_UP</name>
                    <description>Count up (to PERIOD). An overflow event is generated when the counter reaches PERIOD. A terminal count event is generated when the counter reaches PERIOD.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_DOWN</name>
                    <description>Count down (to '0'). An underflow event is generated when the counter reaches '0'. A terminal count event is generated when the counter reaches '0'.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN1</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter reaches PERIOD. An underflow event is generated when the counter reaches '0'. A terminal count event is generated when the counter reaches '0'.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN2</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter reaches PERIOD. An underflow event is generated when the counter reaches '0'. A terminal count event is generated when the counter reaches '0' AND when the counter reaches PERIOD (this counter direction can be used for PWM functionality with asymmetrical updates).</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONE_SHOT</name>
                <description>When '0', counter runs continuous. When '1', counter is turned off by hardware when a terminal count event is generated.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>QUADRATURE_MODE</name>
                <description>In QUAD mode selects quadrature encoding mode (X1/X2/X4).
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert 'dt_line_out' and 'dt_line_compl_out'.  Inversion is the last step in generation of 'dt_line_out' and 'dt_line_compl_out'; i.e. a disabled output line 'dt_line_out' has the value QUADRATURE_MODE[0] and a disabled output line 'dt_line_compl_out' has the value QUADRATURE_MODE[1].</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>X1</name>
                    <description>X1 encoding (QUAD mode)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X2</name>
                    <description>X2 encoding (QUAD mode)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X4</name>
                    <description>X4 encoding (QUAD mode)</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Counter mode.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMER</name>
                    <description>Timer mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAPTURE</name>
                    <description>Capture mode</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>QUAD</name>
                    <description>Quadrature encoding mode</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <description>Pulse width modulation (PWM) mode</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_DT</name>
                    <description>PWM with deadtime insertion mode</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_PR</name>
                    <description>Pseudo random pulse width modulation</description>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Counter status register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000FF01</resetMask>
            <fields>
              <field>
                <name>DOWN</name>
                <description>When '0', counter is counting up. When '1', counter is counting down. In QUAD mode, this field indicates the direction of the latest counter change: '0' when last incremented and '1' when last decremented.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for dead time insertion. In all other modes, this counter is used for pre-scaling the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RUNNING</name>
                <description>When '0', the counter is NOT running. When '1', the counter is running.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTER</name>
            <description>Counter count register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>16-bit counter value. It is advised to not write to this field when the counter is running.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC</name>
            <description>Counter compare/capture register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC_BUFF</name>
            <description>Counter buffered compare/capture register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>Additional buffer for counter CC register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Counter period register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period value: upper value of the counter. When the counter should count for n cycles, this field should be set to n-1.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD_BUFF</name>
            <description>Counter buffered period register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Additional buffer for counter PERIOD register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL0</name>
            <description>Counter trigger control register 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_SEL</name>
                <description>Selects one of the 16 input triggers as a capture trigger. Input trigger 0 is always '0' and input trigger 1 is always '1'. Input trigger 2 is the first external trigger line (tcpwm.tr_in[0]).

In the PWM, PWM_DT and PWM_PR modes this trigger is used to switch the values if the compare and period registers with their buffer counterparts.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT_SEL</name>
                <description>Selects one of the 16 input triggers as a count trigger. In QUAD mode, this is the first phase (phi A). Default setting selects input trigger 1, which is always '1'.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD_SEL</name>
                <description>Selects one of the 16 input triggers as a reload trigger. In QUAD mode, this is the index or revolution pulse. In this mode, it will update the counter with the value in the TCPWM_CNTn_PERIOD register.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STOP_SEL</name>
                <description>Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT modes, the blocking of the output signals can be  asynchronous (STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE) in which case it extends till the next terminal count event.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_SEL</name>
                <description>Selects one of the 16 input triggers as a start trigger. In QUAD mode, this is the second phase (phi B).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL1</name>
            <description>Counter trigger control register 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3FF</resetValue>
            <resetMask>0x3FF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_EDGE</name>
                <description>A capture event will copy the counter value into the CC register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNT_EDGE</name>
                <description>A counter event will increase or decrease the counter by '1'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RELOAD_EDGE</name>
                <description>A reload event will initialize the counter. When counting up, the counter is initialized to '0'. When counting down, the counter is initialized with PERIOD.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP_EDGE</name>
                <description>A stop event, will stop the counter; i.e. it will no longer be running. Stopping will NOT disable the counter.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START_EDGE</name>
                <description>A start event will start the counter; i.e. the counter will become running. Starting does NOT enable the counter. A start event will not initialize the counter whereas the reload event does.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL2</name>
            <description>Counter trigger control register 2</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3F</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>CC_MATCH_MODE</name>
                <description>Determines the effect of a compare match event (COUNTER equals CC register) on the 'line_out' output signals.  Note that INVERT is especially useful for center aligned pulse width modulation.
To generate a duty cycle of 0 percent, the counter CC register should be set to '0'. For a 100 percent duty cycle, the counter CC register should be set to larger than the counter PERIOD register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERFLOW_MODE</name>
                <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD) on the 'line_out' output signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UNDERFLOW_MODE</name>
                <description>Determines the effect of a counter underflow event (COUNTER reaches '0') on the 'line_out' output signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register.</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Terminal count event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Counter matches CC register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register.</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register.</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>LCD</name>
      <description>LCD Controller Block</description>
      <baseAddress>0x40210000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ID</name>
          <description>ID &amp; Revision</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1F0F0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>the ID of LCD controller peripheral is 0xF0F0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>the version number is 0x0001</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DIVIDER</name>
          <description>LCD Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SUBFR_DIV</name>
              <description>Input clock frequency divide value, to generate the 1/4 sub-frame period. The sub-frame period is  4*(SUBFR_DIV+1) cycles long.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEAD_DIV</name>
              <description>Length of the dead time period in cycles.  When set to  zero, no dead time period exists.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CONTROL</name>
          <description>LCD Configuration Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000F7F</resetMask>
          <fields>
            <field>
              <name>LS_EN</name>
              <description>Low speed (LS) generator enable
1: enable
0: disable</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HS_EN</name>
              <description>High speed (HS) generator enable
1: enable
0: disable</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LCD_MODE</name>
              <description>HS/LS Mode selection</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LS</name>
                  <description>Select Low Speed (32kHz) Generator (Works in Active, Sleep and DeepSleep power modes).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HS</name>
                  <description>Select High Speed (system clock) Generator (Works in Active and Sleep power modes only).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TYPE</name>
              <description>LCD driving waveform type configuration.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>TYPE_A</name>
                  <description>Type A - Each frame addresses each COM pin only once with a balanced (DC=0) waveform.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TYPE_B</name>
                  <description>Type B - Each frame addresses each COM pin twice in sequence with a positive and negative waveform that together are balanced (DC=0).</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OP_MODE</name>
              <description>Driving mode configuration</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PWM</name>
                  <description>PWM Mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CORRELATION</name>
                  <description>Digital Correlation Mode</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIAS</name>
              <description>PWM bias selection</description>
              <bitRange>[6:5]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HALF</name>
                  <description>1/2 Bias</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>THIRD</name>
                  <description>1/3 Bias</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FOURTH</name>
                  <description>1/4 Bias (not supported by LS generator)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FIFTH</name>
                  <description>1/5 Bias (not supported by LS generator)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>COM_NUM</name>
              <description>The number of COM connections minus 2. So:
0: 2 COM's
1: 3 COM's
...
13: 15 COM's
14: 16 COM's
15: undefined</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LS_EN_STAT</name>
              <description>LS enable status bit.  This bit is a copy of LS_EN that is synchronized to the low speed clock domain and back to the system clock domain. Firmware can use this bit to observe whether LS_EN has taken effect in the low speed clock domain.  Firmware should never change the configuration for the LS generator without ensuring this bit is 0.
The following procedure should be followed to disable the LS generator:
1. If LS_EN=0 we are done.  Exit the procedure.
2. Check that LS_EN_STAT=1.  If not, wait until it is. This will catch the case of a recent enable (LS_EN=1) that has not taken effect yet.
3. Set LS_EN=0.
4. Wait until LS_EN_STAT=0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA0[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA1[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 5-8 (COM5 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA2[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 9-12 (COM9 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>DATA3[%s]</name>
          <description>LCD Pin Data Registers</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 13-16 (COM13 is lsb).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WCO</name>
      <description>32KHz Oscillator</description>
      <baseAddress>0x40220000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>WCO Configuration Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x470002</resetValue>
          <resetMask>0xC0FF0007</resetMask>
          <fields>
            <field>
              <name>LPM_EN</name>
              <description>Force block into Low Power Mode:
0: Do not force low power mode (LPM) on
1: Force low power mode (LPM) on</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_AUTO</name>
              <description>Automatically control low power mode (only relevant when LPM_EN=0):
0: Do not enter low power mode (LPM) in DeepSleep
1: Enter low power mode (LPM) in DeepSleep. The logic monitors !act_power_en to determine the device has entered DeepSleep.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXT_INPUT_EN</name>
              <description>Disables the load resistor and allows external clock input for pad_xin</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENBUS</name>
              <description>Test Mode Control bits
enbus[7] - N/A
enbus[6] - 1=enable both primary Beta Multipliers
enbus[5] - N/A
enbus[4] - N/A
enbus[3] - Load Resistor Control
enbus[2] - Load Resistor Control
enbus[1] - Load Resistor Control
enbus[0] - Load Resistor Control</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPLL_ENABLE</name>
              <description>Enable DPLL operation. The Oscillator is specified to be stable after 500 ms thus the DPLL should be asserted no sooner than that after IP_ENABLE is set.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IP_ENABLE</name>
              <description>Master enable for IP - disables both WCO and DPLL</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>WCO Status Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>OUT_BLNK_A</name>
              <description>Indicates that output has transitioned - This bit is intended for Test Mode Only and is not a reliable indicator.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DPLL</name>
          <description>WCO DPLL Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3FC00000</resetValue>
          <resetMask>0x3FFF07FF</resetMask>
          <fields>
            <field>
              <name>DPLL_MULT</name>
              <description>Multiplier to determine IMO frequency in multiples of the WCO frequency

Fimo = (DPLL_MULT + 1)  * Fwco</description>
              <bitRange>[10:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPLL_LF_IGAIN</name>
              <description>DPLL Loop Filter Integral Gain Setting
0x0 - 0.0625
0x1 - 0.125
0x2 - 0.25
0x3 - 0.5
0x4 - 1.0
0x5 - 2.0
0x6 - 4.0
0x7 - 8.0</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPLL_LF_PGAIN</name>
              <description>DPLL Loop Filter Proportionial Gain Setting
0x0 - 0.0625
0x1 - 0.125
0x2 - 0.25
0x3 - 0.5
0x4 - 1.0
0x5 - 2.0
0x6 - 4.0
0x7 - 8.0</description>
              <bitRange>[21:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DPLL_LF_LIMIT</name>
              <description>Maximum IMO offset allowed (used to prevent DPLL dynamics from selecting an IMO frequency that the logic cannot support)</description>
              <bitRange>[29:22]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CTRLOW</name>
          <description>Watchdog Counters 0/1</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_CTR0</name>
              <description>Current value of WDT Counter 0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WDT_CTR1</name>
              <description>Current value of WDT Counter 1</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CTRHIGH</name>
          <description>Watchdog Counter 2</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_CTR2</name>
              <description>Current value of WDT Counter 2</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_MATCH</name>
          <description>Watchdog counter match values</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_MATCH0</name>
              <description>Match value for Watchdog Counter 0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_MATCH1</name>
              <description>Match value for Watchdog Counter 1</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CONFIG</name>
          <description>Watchdog Counters Configuration</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xDF010F0F</resetMask>
          <fields>
            <field>
              <name>WDT_MODE0</name>
              <description>Watchdog Counter Action on Match (WDT_CTR0=WDT_MATCH0).</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Do nothing</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INT</name>
                  <description>Assert WDT_INTx</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Assert WDT Reset - Not Supported - here for backwards compatibility</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INT_THEN_RESET</name>
                  <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt. Not supported - here for Backwards compatibility.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WDT_CLEAR0</name>
              <description>Clear Watchdog Counter when WDT_CTR0=WDT_MATCH0. In other words WDT_CTR0 divides LFCLK by (WDT_MATCH0+1).
0: Free running counter
1: Clear on match</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_CASCADE0_1</name>
              <description>Cascade Watchdog Counters 0,1.  Counter 1 increments the cycle after WDT_CTR0=WDT_MATCH0.
0: Independent counters
1: Cascaded counters</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_MODE1</name>
              <description>Watchdog Counter Action on Match (WDT_CTR1=WDT_MATCH1).</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Do nothing</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INT</name>
                  <description>Assert WDT_INTx</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Assert WDT Reset - Not Supported - here for backwards compatibility</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INT_THEN_RESET</name>
                  <description>Assert WDT_INTx, assert WDT Reset after 3rd unhandled interrupt  - Not supported - here for backwards compatibility.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WDT_CLEAR1</name>
              <description>Clear Watchdog Counter when WDT_CTR1=WDT_MATCH1. In other words WDT_CTR1 divides LFCLK by (WDT_MATCH1+1).
0: Free running counter
1: Clear on match</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_CASCADE1_2</name>
              <description>Cascade Watchdog Counters 1,2.  Counter 2 increments the cycle after WDT_CTR1=WDT_MATCH1.  It is allowed to cascade all three WDT counters.
0: Independent counters
1: Cascaded counters.  When cascading all three counters, WDT_CLEAR1 must be 1</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_MODE2</name>
              <description>Watchdog Counter 2 Mode.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Free running counter with no interrupt requests</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INT</name>
                  <description>Free running counter with interrupt request when a specified bit in CTR2 toggles (see WDT_BITS2)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WDT_BITS2</name>
              <description>Bit to observe for WDT_INT2:
0: Assert when bit0 of WDT_CTR2 toggles (one int every tick)
..
31: Assert when bit31 of WDT_CTR2 toggles (one int every 2^31 ticks)</description>
              <bitRange>[28:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFCLK_SEL</name>
              <description>N/A</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CONTROL</name>
          <description>Watchdog Counters Control</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0F0F</resetMask>
          <fields>
            <field>
              <name>WDT_ENABLE0</name>
              <description>Enable Counter 0
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)
Note: This field takes considerable time (up to 3 LFCLK cycles) to take effect.  It must not be changed more than once in that period.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_ENABLED0</name>
              <description>Indicates actual state of counter.  May lag WDT_ENABLE0 by up to 3 LFCLK cycles.  After changing WDT_ENABLE0, do not enter DEEPSLEEP mode until this field acknowledges the change.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WDT_INT0</name>
              <description>WDT Interrupt Request.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  Clearing this bit also prevents Reset from happening when WDT_MODEx=3.  After W1C, WDT_CONTROL must be read for the hardware to internally remove the clear flag.  Failure to do this may result in missing the next interrupt.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_RESET0</name>
              <description>Resets counter 0 back to 0000.  Hardware will reset this bit after counter was reset.  This will take several LFCLK cycles to take effect.  Wait until the reset completes before enabling the WDT.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_ENABLE1</name>
              <description>Enable Counter 1
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)
Note: This field takes considerable time (up to 3 LFCLK cycles) to take effect.  It must not be changed more than once in that period.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_ENABLED1</name>
              <description>Indicates actual state of counter.  May lag WDT_ENABLE1 by up to 3 LFCLK cycles.  After changing WDT_ENABLE1, do not enter DEEPSLEEP mode until this field acknowledges the change.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WDT_INT1</name>
              <description>WDT Interrupt Request.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.    After W1C, WDT_CONTROL must be read for the hardware to internally remove the clear flag.  Failure to do this may result in missing the next interrupt.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_RESET1</name>
              <description>Resets counter 1 back to 0000.  Hardware will reset this bit after counter was reset.  This will take several LFCLK cycles to take effect.  Wait until the reset completes before enabling the WDT.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_ENABLE2</name>
              <description>Enable Counter 2
0: Counter is disabled (not clocked)
1: Counter is enabled (counting up)
Note: This field takes considerable time (up to 3 LFCLK cycles) to take effect.  It must not be changed more than once in that period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_ENABLED2</name>
              <description>Indicates actual state of counter.  May lag WDT_ENABLE2 by up to 3 LFCLK cycles.  After changing WDT_ENABLE2, do not enter DEEPSLEEP mode until this field acknowledges the change.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WDT_INT2</name>
              <description>WDT Interrupt Request.  This bit is set by hardware as configured by this registers.  This bit must be cleared by firmware.  After W1C, WDT_CONTROL must be read for the hardware to internally remove the clear flag.  Failure to do this may result in missing the next interrupt.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WDT_RESET2</name>
              <description>Resets counter 2 back to 0000_0000.  Hardware will reset this bit after counter was reset.  This will take several LFCLK cycles to take effect.  Wait until the reset completes before enabling the WDT.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDT_CLKEN</name>
          <description>Watchdog Counters Clock Enable</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CLK_WCO_EN_FOR_WDT</name>
              <description>Enables the WCO clock for use by the WDT logic. Wait at least 4 WCO clock cycles for a change to take effect. Must be 0 when switching WDT_CONFIG.LFCLK_SEL. Should be 0 if CLK_ILO_EN_FOR_WDT=1</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_ILO_EN_FOR_WDT</name>
              <description>Enables the ILO clock for use by the WDT logic. Wait at least 4 ILO clock cycles for a change to take effect. Must be 0 when switching WDT_CONFIG.LFCLK_SEL. Should be 0 if CLK_WCO_EN_FOR_WDT=1.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM</name>
          <description>WCO Trim Register</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x11</resetValue>
          <resetMask>0x37</resetMask>
          <fields>
            <field>
              <name>XGM</name>
              <description>Amplifier GM setting - Used when WCO.LPM_AUTO=0 or when LPM_AUTO=1 and not in DeepSleep mode.
0x0 - 3370 nA
0x1 - 2620 nA
0x2 - 2250 nA
0x3 - 1500 nA
0x4 - 1870 nA
0x5 - 1120 nA
0x6 -  750 nA
0x7 -      0 nA</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LPM_GM</name>
              <description>GM setting for LPM (bandwidth = DC/ms)  - Used when WCO.LPM_AUTO=0 or when LPM_AUTO=1 and not in DeepSleep mode.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCB0</name>
      <description>Serial Communications Block (SPI/UART/I2C)</description>
      <headerStructName>SCB</headerStructName>
      <baseAddress>0x40240000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x300400F</resetValue>
          <resetMask>0x9303D70F</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') address matching (I2C) or selection (SPI). In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.

In UART mode this field should be '0'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>Internally clocked mode ('0') or externally clocked mode ('1') operation. In internally clocked mode, the serial interface protocols run off the peripheral clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).

In UART mode this field should be '0'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>Non EZ mode ('0') or EZ mode ('1'). In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames mot separated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of up to 256 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.

In UART mode this field should be '0'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_RESP_MODE</name>
              <description>Determines CMD_RESP mode of operation:
'0': CMD_RESP mode disabled.
'1': CMD_RESP mode enabled (also requires EC_AM_MODE and EC_OP_MODE to be set to '1').</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEM_WIDTH</name>
              <description>Determines the number of bits per FIFO data element, depending on physical SRAM cell data width.
On M0S8/MXS40S platform, the SRAM data width is 16 bit, so WORD (2) is not supported.
On MXS40E platform, the SRAM data width is 32 bits.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BYTE</name>
                  <description>8-bit FIFO data elements. 
This mode provides the biggest amount of FIFO entries, but  TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 7].</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALFWORD</name>
                  <description>16-bit FIFO data elements. 
TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH are restricted to [0, 15].</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WORD</name>
                  <description>32-bit FIFO data elements. 
This mode provides the smallest amount of FIFO entries, but TX_CTRL.DATA_WIDTH and RX_CTRL.DATA_WIDTH can be in a range of [0, 31].</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').

In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when ADDR_ACCEPT is '1' for both I2C read and write transfers.

In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Only used in externally clocked mode. If the externally clocked logic and the MMIO SW accesses to EZ memory coincide/collide, this bit determines whether a SW access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, MMIO read operations return 0xffff:ffff and MMIO write operations are ignored. Colliding accesses are registered as interrupt causes: field BLOCKED of MMIO registers INTR_TX and INTR_RX.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C</name>
                  <description>Inter-Integrated Circuits (I2C) mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <description>Serial Peripheral Interface (SPI) mode.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART</name>
                  <description>Universal Asynchronous Receiver/Transmitter (UART) mode.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EC_ACCESS</name>
              <description>used to enable I2CS_EC or SPIS_EC access to internal SRAM memory.
0: enable clock_scb_en, has no effect on ec_busy_pp
1: disable clock_scb_en, enable ec_busy_pp (grant I2CS_EC or SPIS_EC access)

Before going to deepsleep this field should be set to 1. 
when waking up from DeepSleep power mode, and PLL is locked (clk_scb is at expected frequency), this filed should be set to 0.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>IP enabled ('1') or not ('0'). The proper order in which to initialize the IP is as follows:
- Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
- Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
- Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
- Program CTRL to enable IP, select the specific operation mode and oversampling factor.
Generally hen the IP is enabled, no control information should be changed. Changes should be made AFTER disabling the IP, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the IP is re-enabled. Note that disabling the IP will cause re-initialization of the design and associated state is lost (e.g. FIFO content).

Specific to SPI master case,  when SCB is idle,  below registers can be changed without disabling SCB block,
      TX_CTRL
      TX_FIFO_CTRL
      RX_CTRL
      RX_FIFO_CTRL
      SPI_CTRL.SSEL,</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_CTRL</name>
          <description>Command/response control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF01FF</resetMask>
          <fields>
            <field>
              <name>BASE_RD_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. Address is used by a I2C CMD_RESP mode read transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode read transfer (CTRL.MODE is SPI): at the start of a read transfer BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASE_WR_ADDR</name>
              <description>I2C/SPI write base address for CMD_RESP mode. Address is used by a I2C CMD_RESP mode write transfer (CTRL.MODE is I2C) or a SPI CMD_RESP mode write transfer (CTRL.MODE is SPI): at the start of a write transfer BASE_WE_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_STATUS</name>
          <description>Command/response status</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>CURR_RD_ADDR</name>
              <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address). 

The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 

This field is reliable during when there is no bus transfer. This field is potentially unreliable when there is a bus transfer bus transfer: when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_WR_ADDR</name>
              <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address).

The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).

This field is reliable during when there is no bus transfer. This field is potentially unreliable when there is a bus transfer bus transfer: when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUS_BUSY</name>
              <description>Indicates whether there is an ongoing bus transfer to the IP.
'0': no ongoing bus transfer.
'1': ongoing bus transfer.

For SPI, the field is '1' when the slave is selected.

For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUSY</name>
              <description>Indicates whether the CURR_RD_ADDR and CURR_WR_ADDR fields in this register are reliable (when CMD_RESP_EC_BUSY is '0') or not reliable (when CMD_RESP_EC_BUSY is '1'). Note:
- When there is no ongoing bus transfer, CMD_RESP_EC_BUSY is '0' (reliable).
- When there is a ongoing bus transfer, CMD_RESP_EC_BUSY is '0' (reliable), when the CURR_RD_ADDR and CURR_WR_ADDR are not being updated by the HW.
- When there is a ongoing bus transfer, CMD_RESP_EC_BUSY is '1' (not reliable), when the CURR_RD_ADDR or CURR_WR_ADDR are being updated by the HW. 
   Note that this update lasts one I2C clock cycle, or two SPI clock cycles.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRL</name>
          <description>SPI control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000010</resetValue>
          <resetMask>0x8F017F3F</resetMask>
          <fields>
            <field>
              <name>SSEL_CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.

When continuous transfers are enabled individual data frame transfers are not necessarily separated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.

When continuous transfers are not enabled individual data frame transfers are always separated by slave deselection: data frames are always separated by slave deselection.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode.

When '1', the data frame start indication is a pulse on the SELECT line that precedes the transfer of the first data frame bit.

When '0', the data frame start indication is a pulse on the SELECT line that coincides with the transfer of the first data frame bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>Indicates the clock phase. This field, together with the CPOL field, indicates when MOSI data is driven and MISO data is captured:
- Motorola mode 0. CPOL is '0', CPHA is '0': MOSI  is driven on a falling edge of SCLK. MISO is captured on a rising edge of SCLK.
- Motorola mode 1. CPOL is '0', CPHA is '1': MOSI  is driven on a rising edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 2. CPOL is '1', CPHA is '0': MOSI  is driven on a rising edge of SCLK. MISO is captured on a falling edge of SCLK.
- Motorola mode 3. CPOL is '1', CPHA is '1': MOSI  is driven on a falling edge of SCLK. MISO is captured on a rising edge of SCLK.

In SPI Motorola submode, all four CPOL/CPHA modes are valid.
in SPI NS submode, only CPOL=0 CPHA=0 mode is valid.
in SPI TI submode, only CPOL=0 CPHA=1 mode is valid.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>Indicates the clock polarity. This field, together with the CPHA field, indicates when MOSI data is driven and MISO data is captured:
- CPOL is '0': SCLK is '0' when not transmitting data.
- CPOL is '1': SCLK is '1' when not transmitting data.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_MISO_SAMPLE</name>
              <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.

When '0', the default applies (for Motorola as determined by CPOL and CPHA, for Texas Instruments on the falling edge of SCLK and for National Semiconductors on the rising edge of SCLK). 

When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>Only applicable in master mode. 
'0': SCLK is generated, when the SPI master is enabled and data is transmitted.
'1': SCLK is generated, when the SPI master is enabled. This mode is useful for slave devices that use SCLK for functional operation other than just SPI functionality.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>Slave select polarity. SSEL_POLARITY0 applies to the outgoing SPI slave select signal 0 (master mode) and to the incoming SPI slave select signal (slave mode). For Motorola and National Semiconductors submodes: 
'0': slave select is low/'0' active.
'1': slave select is high/'1' active.
For Texas Instruments submode:
'0': high/'1' active precede/coincide pulse.
'1': low/'0' active precede/coincide pulse.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>Slave select polarity.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>Slave select polarity.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>Slave select polarity.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_SETUP_DEL</name>
              <description>Indicates the SPI SELECT setup delay (between SELECT activation and SCLK clock edge to sample the first MOSI bit).
'0': 0.75 SPI clock cycles
'1': 1.75 SPI clock cycles
Only applies in SPI MOTOROLA submode and when SCLK_CONTINUOUS=0, CTRL.OVS&gt;=3.

above are ideal case at SCB block level, and there is inaccuracy of one clk_scb cycle.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_HOLD_DEL</name>
              <description>Indicates the SPI SELECT hold delay (between SPI clock edge to sample the last MOSI bit, and SELECT deactivation).
'0': 0.75 SPI clock cycles 
'1': 1.75 SPI clock cycles 
Only applies in SPI MOTOROLA submode and when SCLK_CONTINUOUS=0, CTRL.OVS&gt;=3.

above are ideal case at SCB block level, and there is inaccuracy of one clk_scb cycle.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_INTER_FRAME_DEL</name>
              <description>Indicates the SPI SELECT inter-dataframe delay (between SELECT deactivation and SELECT activation).
'0': 1.5 SPI clock cycles
'1': 2.5 SPI clock cycles
Only applies in SPI MOTOROLA submode and when SPI_CTRL.SSEL_CONTINUOUS=0, CTRL.OVS&gt;=3.

above are ideal case at SCB block level, and there is inaccuracy of one clk_scb cycle.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
'0': the SPI master MISO line 'spi_miso_in' is connected to the SPI MISO pin.
'1': the SPI master MISO line 'spi_miso_in' is connected to the SPI master MOSI line 'spi_mosi_out'. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPI_MOTOROLA</name>
                  <description>SPI Motorola submode. In master mode, when not transmitting data (SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_TI</name>
                  <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive; i.e. no pulse is generated.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_NS</name>
                  <description>SPI National Semiconductors submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SSEL</name>
              <description>Selects one of the four incoming/outgoing SPI slave select signals:
- 0: Slave 0, SSEL[0].
- 1: Slave 1, SSEL[1].
- 2: Slave 2, SSEL[2].
- 3: Slave 3, SSEL[3].
The IP should be disabled when changes are made to this field.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master ('1') or slave ('0') mode. In master mode, transmission will commence on availability of data frames in the TX FIFO. In slave mode, when selected and there is no data frame in the TX FIFO, the slave will transmit all '1's. In both master and slave modes, received data frames will be lost if the RX FIFO is full.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_STATUS</name>
          <description>SPI status</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_TX_CTRL</name>
          <description>SPI transmitter control</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10030</resetMask>
          <fields>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0').</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MOSI_IDLE_HIGH</name>
              <description>SPI master MOSI output level when SELECT output inactive,
0: retain the level of last data bit
1: change to high,
   (MOSI level is high, before the first data bit time, and after data bit time, defined SSEL/SCLK driving edge with CPOL/CPHA)</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_RX_CTRL</name>
          <description>SPI receiver control</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x130</resetMask>
          <fields>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0').</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behavior when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x3010000</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). When '0', the transmitter TX line 'uart_tx_out' is connected to the TX pin and the receiver RX line 'uart_rx_in' is connected to the RX pin. When '1', the transmitter TX line 'uart_tx_out' is connected to the receiver RX line 'uart_rx_in'. A similar connections scheme is followed for 'uart_rts_out' and 'uart_cts_in'.

This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART_STD</name>
                  <description>Standard UART submode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_SMARTCARD</name>
                  <description>SmartCard (ISO7816) submode. Support for negative acknowledgement (NACK) on the receiver side and retransmission on the transmitter side.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_IRDA</name>
                  <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TX_CTRL</name>
          <description>UART transmitter control</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x137</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_CTRL</name>
          <description>UART receiver control</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0002</resetValue>
          <resetMask>0x10F3777</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.

Note that in case of a stop bits error, the successive data frames may get lost as the receiver needs to resynchronize its start bit detection. The amount of lost data frames depends on both the amount of stop bits, the idle ('1') time between data frames and the data frame value.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the receiver expects an even parity. When '1', the receiver expects an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity checking enabled ('1') or not ('0'). Only applicable in standard UART submode. In SmartCard submode, parity checking is always enabled through hardware. In IrDA submode, parity checking is always disabled through hardware.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal 'uart_rx_in'. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behavior when a parity check fails. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost. Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERROR</name>
              <description>Behavior when an error is detected in a start or stop period. When '0', received data is send to the RX FIFO. When '1', received data is dropped and lost.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>Multi-processor mode. When '1', multi-processor mode is enabled. In this mode, RX_CTRL.DATA_WIDTH should indicate a 9-bit data frame. In multi-processor mode, the 9th received bit of a data frame separates addresses (bit is '1') from data (bit is '0'). A received address is matched with RX_MATCH.DATA and RX_MATCH.MASK. In the case of a match, subsequent received data are sent to the RX FIFO. In the case of NO match, subsequent received data are dropped.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minimum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>Only applicable in standard UART submode. When '1', the receiver skips start bit detection for the first received data frame. Instead, it synchronizes on the first received data frame bit, which should be a '1'. This functionality is intended for wake up from DeepSleep when receiving a data frame. The transition from idle ('1') to START ('0') on the RX line is used to wake up the CPU. The transition detection (and the associated wake up functionality) is performed by the GPIO2 IP. The woken up CPU will enable the SCB's UART receiver functionality. Once enabled, it is assumed that the START bit is ongoing (the CPU wakeup and SCB enable time should be less than the START bit period). The SCB will synchronize to a '0' to '1' transition, which indicates the first data frame bit is received (first data frame bit should be '1'). After synchronization to the first data frame bit, the SCB will resume normal UART functionality: subsequent data frames will be synchronized on the receipt of a START bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>Break width. BREAK_WIDTH + 1 is the minimum width in bit periods of a break. During a break the transmitted/received line value is '0'. This feature is useful for standard UART submode and LIN submode ('break field' detection). Once, the break is detected, the INTR_RX.BREAK_DETECT bit is set to '1'. Note that break detection precedes baud rate detection, which is used to synchronize/refine the receiver clock to the transmitter clock. As a result, break detection operates with an unsynchronized/unrefined receiver clock. Therefore, the receiver's definition of a bit period is imprecise and the setting of this field should take this imprecision into account. The LIN standard also accounts for this imprecision: a LIN start bit followed by 8 data bits allows for up to 9 consecutive '0' bit periods during regular transmission, whereas the LIN break detection should be at least 13 consecutive '0' bit periods. This provides for a margin of 4 bit periods. Therefore, the default value of this field is set to 10, representing a minimal break field with of 10+1 = 11 bit periods; a value in between the 9 consecutive bit periods of a regular transmission and the 13 consecutive bit periods of a break field. This provides for slight imprecisions of the receiver clock wrt. the transmitter clock. There should not be a need to program this field to any value other than its default value.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_LEVEL</name>
              <description>0: low level pulse detection, like Break field in LIN protocol
1: high level pulse detection, like IFS field in CXPI protocol, or idle line state in UART</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_STATUS</name>
          <description>UART receiver status</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BR_COUNTER</name>
              <description>Amount of peripheral clock periods that constitute the transmission of a 0x55 data frame (sent least significant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of peripheral clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FLOW_CTRL</name>
          <description>UART flow control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30100FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal 'uart_rts_out' is activated. By setting this field to '0', flow control is effectively SW disabled (may be useful for debug purposes).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal 'uart_rts_out':
'0': RTS is low/'0' active; 'uart_rts_out' is '0' when active and 'uart_rts_out' is '1' when inactive.
'1': RTS is high/'1' active; 'uart_rts_out' is '1' when active and 'uart_rts_out' is '0' when inactive.

During IP reset (Hibernate system power mode), 'uart_rts_out' is '1'. This represents an inactive state assuming a low/'0' active polarity.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal 'uart_cts_in':
'0': CTS is low/'0' active; 'uart_cts_in' is '0' when active and 'uart_cts_in' is '1' when inactive.
'1': CTS is high/'1' active; 'uart_cts_in' is '1' when active and 'uart_cts_in' is '0' when inactive.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal 'uart_cts_in' by the UART transmitter:
'0': Disabled. The UART transmitter ignores 'uart_cts_in', and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
'1': Enabled. The UART transmitter uses 'uart_cts_in' to qualify the transmission of data. It transmits when 'uart_cts_in' is active and a data frame is available for transmission in the TX FIFO or the TX shift register.

If UART_CTRL.LOOPBACK is '1', 'uart_cts_in' is connected to 'uart_rts_out' in the IP (both signals are subjected to signal polarity changes as indicated by RTS_POLARITY and CTS_POLARITY).</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL</name>
          <description>I2C control</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFB88</resetValue>
          <resetMask>0xC001FBFF</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 peripheral clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the IP clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 IP clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 IP clock cycles and &lt;= 16 IP clock cycles.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 peripheral clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 

The field is mainly used in master mode. In slave mode, there is a frequency requirement for the IP clock wrt. the regular (no stretching) interface (IF) low time to guarantee functional correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 IP clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 IP clock cycles and &lt;= 16 IP clock cycles.

in slave mode, this field is used to define number of clk_scb cycles for tSU-DAT timing (from ACK/NACK/data ready, to SCL rising edge (released from I2C slave clock stretching))</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>When '1', a received data element by the master is immediately ACK'd when the receiver FIFO is not full.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>for I2C master, the NACKed byte should be properly received. it write  the data byte, before ACK/NACK decision. 

When '1', 
if a received data element byte is written, and the receiver FIFO become full, the master send out NACK .  
if the reciever FIFO is full (the received data byte cannot be written), it stretch SCL(extend SCL low phase) until the receiver FIFO changes to not full, to write the last byte, then send out NACK.

When '0', clock stretching is used instead (till the receiver FIFO is no longer full).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>When '1', a received general call slave address is immediately NACK'd (no ACK or clock stretching) and treated as a non matching slave address. This is useful for slaves that do not need any data supplied within the general call structure.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>When '1', a received (matching) slave address is immediately ACK'd when the receiver FIFO is not full. In EZ mode, this field should be set to '1'.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>When '1', a received data element by the slave is immediately ACK'd when the receiver FIFO is not full. In EZ mode, this field should be set to '1'.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>For internally clocked logic (EC_AM is '0' and EC_OP is '0') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when:
- EC_AM is '0', EC_OP is '0' and non EZ mode.
Functionality is as follows:
- 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full). 

For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
- EC_AM is '1' and EC_OP is '0'.
- EC_AM is '1' and general call address match.
- EC_AM is '1' and non EZ mode.
Functionality is as follows:
- 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities: 1). the internally clocked logic is enabled (we are in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 2). the internally clocked logic is not enabled (we are in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
- 0: clock stretching is performed (till the internally clocked logic takes over). The internally clocked logic will handle the ongoing transfer as soon as it is enabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description>For internally clocked logic only. Only used when:
- non EZ mode.
Functionality is as follows:
- 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. When '0', the I2C SCL and SDA lines are connected to the I2C SCL and SDA pins. When '1', I2C SCL and SDA lines are routed internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>Slave mode enabled ('1') or not ('0').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>Master mode enabled ('1') or not ('0'). Note that both master and slave modes can be enabled at the same time. This allows the IP to address itself.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>I2C status</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1000035</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If the IP is disabled, BUS_BUSY is '0'. After enabling the IP, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).

For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).

For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_EZ_ADDR or CURR_EZ_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_EZ_ADDR and CURR_EZ_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2CS_IC_BUSY</name>
              <description>Indicates whether the internally clocked slave logic is being accessed by external I2C master. 
--set at ADDR_MATCH
--clear at START/RESET, STOP detection, or BUS_ERROR
This bit can be used by SW to determine whether I2CS_IC is busy before entering DeepSleep.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>I2C slave read transfer ('1') or I2C slave write transfer ('0'). When the I2C slave is inactive/idle or receiving START, REPEATED START, STOP or an address, this field is '0''.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>I2C master read transfer ('1') or I2C master write transfer ('0'). When the I2C master is inactive/idle or transmitting START, REPEATED START, STOP or an address, this field is '0''.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>I2C slave current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when I2C_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>I2C slave base EZ address. Address as provided by an I2C write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HS_MODE</name>
              <description>this is to indicate I2C Hs-mode transfer,
it is set, after 'Start, master-code, NACK'' pattern,
   for I2CM,    at SCL falling edge, (INTR_M.I2C_HS_ENTER triggers),
   for I2CS_IC, at SCL falling edge, (INTR_S.I2C_HS_ENTER triggers),
   for I2CS_EC, at SCL rising  edge, after 2-DFF synchronization delay, when CTRL.EC_AM =1, AND CTRL.EC_ACCESS =0, 
it is cleared when Stop pattern is detected,
   for I2CM,    INTR_M.I2C_HS_EXIT triggers,
   for I2CS_IC, INTR_S.I2C_HS_EXIT triggers,
   for I2CS_EC, there is no respective interrupt.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_M_CMD</name>
          <description>I2C master command</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_START_ON_IDLE</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>for I2C master, the NACKed byte should be properly received. it write  the data byte, before ACK/NACK decision. 

When '1', attempt to transmit a negative acknowledgement (NACK).
if the reciever FIFO is full (the received data byte cannot be written), it stretch SCL(extend SCL low phase) until the receiver FIFO changes to not full, to write the last byte, then send out NACK. 

When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
 I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_S_CMD</name>
          <description>I2C slave command</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x107</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_TX_ONES_ON_EMPTY</name>
              <description>When '1', attempt to send ones when TX_FIFO is empty. 

Once hardware starts to send ones, it will continue send ones until NACK is received, regardless of TX_FIFO status (even if new data is written into TX_FIFO).

This bit is used to avoid stretching SCL, which is not expected for some master devices.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_STRETCH_HS</name>
              <description>When '1', attempt to stretch SCL at time t1, SCL falling edge after 'START, Master-code, NACK' pattern is detected. 

When I2C_CTRL.HS_ENABLED is set, it should be set; after wakeup from DeepSleep power mode, it should also be set.

When INTR_S.I2C_HS_ENTER triggers, firmware configure clk_scb to meet I2C Hs-mode timing requirements, then firmware can clear this bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CFG</name>
          <description>I2C configuration</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2A1013</resetValue>
          <resetMask>0x303F1313</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_sda_in' 50 ns filter. 
for M0S8 platform, see s8i2cs BROS (001-59539) for more details on the trim bit values.
For MXS40 platform, only the Least Significant Bit (LSB) is used, see s40iolib BROS (002-02511) for more details on the trim bit values.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>Selection of 'i2c_sda_in' filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>Trim bits for 'i2c_scl_in' 50 ns filter. 
for M0S8 platform, see s8i2cs BROS (001-59539) for more details on the trim bit values.
For MXS40 platform, only the Least Significant Bit (LSB) is used, see s40iolib BROS (002-02511) for more details on the trim bit values.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>Selection of 'i2c_scl_in' filter delay:
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 0. 
for M0S8 platform, see s8i2cs BROS (001-59539) for more details on the trim bit values.
For MXS40 platform, only the Least Significant Bit (LSB) is used, see s40iolib BROS (002-02511) for more details on the trim bit values.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 1. 
for M0S8 platform, see s8i2cs BROS (001-59539) for more details on the trim bit values.
For MXS40 platform, only the Least Significant Bit (LSB) is used, see s40iolib BROS (002-02511) for more details on the trim bit values.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>Trim bits for 'i2c_sda_out' 50 ns filter 2. 
for M0S8 platform, see s8i2cs BROS (001-59539) for more details on the trim bit values.
For MXS40 platform, only the Least Significant Bit (LSB) is used, see s40iolib BROS (002-02511) for more details on the trim bit values.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>Selection of cumulative 'i2c_sda_out' filter delay:
'0': 0 ns.
'1': 50 ns (filter 0 enabled).
'2': 100 ns (filters 0 and 1 enabled).
'3': 150 ns (filters 0, 1 and 2 enabled).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STRETCH_CTRL</name>
          <description>I2C stretch control</description>
          <addressOffset>0x74</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>STRETCH_THRESHOLD</name>
              <description>stretch threthold.
Typically it is the SCL turaound delay (including IO cell delay, SCL rise time, analog filter delay), in number of clk_scb cycles.

When STRETCH_COUNT is higher than this STRETCH_THRESHOLD, STRETCH_DETECTED will be set.

STRETCH_DETECTED should be less than 'HOVS-2', HOVS means I2C_CTRL.HIGH_PHASE_OVS, or I2C_CTRL_HS.HOVS_HS.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STRETCH_STATUS</name>
          <description>I2C stretch status</description>
          <addressOffset>0x78</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x13F</resetMask>
          <fields>
            <field>
              <name>STRETCH_COUNT</name>
              <description>stretch count.
Started when I2C device start to drive high phase on internal SCL output signal, stalled when it detected high level on SCL input signal.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STRETCH_DETECTED</name>
              <description>stretch detected.
Set when I2C rising edge comes later than expected (suppressed by another master or slave), and STRETCH_COUNT is higher than STRETCH_THRESHOLD.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYNC_DETECTED</name>
              <description>synchronization detected.
Set when I2C falling edge comes in earler than expected (suppressed by another I2C master during synchronization).</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STRETCHING</name>
              <description>I2C SCL is stretched by this block (DUT),
for I2C master, this can happen when  TX FIFO is empty, or RX_FIFO is full, or ACK/NACK is not decided, or RESTART/STOP is not decided.
For I2C slave, this can heppend,  TX FIFO is empty, or RX_FIFO is full, or ACK/NACK is not decided.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL_HS</name>
          <description>I2C control for High-Speed mode</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x88</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>HOVS_HS</name>
              <description>Serial I2C interface high phase oversampling factor for I2C Hs-mode. HOVS_HS + 1 peripheral clock periods constitute the high phase of a bit period. 

Hardware switch from I2C_CTRL.HIGH_PHASE_OVS to this value automacitcally, at time t1; and switch back time tFS (when STOP  detected).

Firmware configure clk_scb frequency properly between t1 and tH.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOVS_HS</name>
              <description>Serial I2C interface low phase oversampling factor for I2C Hs-mode. LOVS_HS + 1 peripheral clock periods constitute the low phase of a bit period. 

Hardware switch from I2C_CTRL.LOW_PHASE_OVS to this value automacitcally, at time t1; and switch back time tFS (when STOP  detected).

Firmware configure clk_scb frequency properly between t1 and tH.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HS_ENABLED</name>
              <description>0': I2C Hs-mode is disabled,
'1': I2C Hs-mode is enabled,

when I2C Hs-mode is disabled and the IP is in I2C slave mode, hardware response to incoming Hs-mode transfers are undefined.

When I2C Hs-mode is disabled and the IP is in I2C master mode, firmware should not generate Hs-mode transfers.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>Transmitter control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20107</resetValue>
          <resetMask>0x3011F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width, depending on CTRL.MEM_WIDTH. 
DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. 
This number does not include start, parity and stop bits. 
For UART mode, the valid range is [3, 8]. 
For SPI, the valid range is [3, 31]. 
For I2C the only valid value is 7.
In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPEN_DRAIN</name>
              <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
'0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
'1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').

The open drain mode is supported for:
- UART mode, 'uart_tx' IO cell (SPI slave).
- SPI mode, 'spi_miso' IO cell.

this bit is not applicable to I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OPEN_DRAIN_SCL</name>
              <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
'0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.

'1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').

this bit is applicable to I2C SCL only.
I2C SDA always work in open-drain mode.

this is not applicable to M0S8, which does not need special control in SCB for open-drain drive mode.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event INTR_TX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is transmitted next (when the protocol state machine is not transmitting a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>Transmitter FIFO write</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used.

A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTRL</name>
          <description>Receiver control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x31F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width, depending on CTRL.MEM_WIDTH. 
DATA_WIDTH + 1 is the expected amount of bits in received data frame. 
This number does not include start, parity and stop bits. 
For UART mode, the valid range is [3, 8]. 
For SPI, the valid range is [3, 31]. 
For I2C the only valid value is 7. 
In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptibility to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTRL</name>
          <description>Receiver FIFO control</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event INTR_RX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>Receiver FIFO status</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR  (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MATCH</name>
          <description>Slave address and mask</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Slave device address.

In UART multi-processor mode, all 8 bits are used.

In I2C slave mode, only bits 7 down to 1 are used. This reflects the organization of the first transmitted byte in a I2C transfer: the first 7 bits represent the address of the addressed slave, and the last 1 bit is a read/write indicator ('0': write, '1': read).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>Slave device address mask. This field is a mask that specifies which of the ADDR field bits in the ADDR field take part in the matching of the slave address: MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>Receiver FIFO read</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used.

This register has a side effect when read by software: a data frame is removed from the FIFO. This may be undesirable during debug; i.e. a read during debug should NOT have a side effect. To this end, the IP uses the AHB-Lite 'hmaster[0]' input signal. When this signal is '1' in the address cycle of a bus transfer, a read transfer will not have a side effect. As a result, a read from this register will not remove a data frame from the FIFO. As a result, a read from this register behaves as a read from the SCB_RX_FIFO_RD_SILENT register.

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>Receiver FIFO read silent</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.MEM_WIDTH is '0', only DATA[7:0] are used and when CTRL.MEM_WIDTH is '1', only DATA[15:0] are used

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Active clocked interrupt signal</description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>M</name>
              <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S</name>
              <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request</description>
          <addressOffset>0xE80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match).

Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (I2C STOP).

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask</description>
          <addressOffset>0xE88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASKED</name>
          <description>Externally clocked I2C interrupt masked</description>
          <addressOffset>0xE8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request</description>
          <addressOffset>0xEC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.

Only used when EC_AM is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (SPI deselection).

Only available in EZ and CMD_RESP mode and when EC_OP is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.

Only used in EZ and CMD_RESP modes and when EC_OP is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask</description>
          <addressOffset>0xEC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked</description>
          <addressOffset>0xECC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M</name>
          <description>Master interrupt request</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.

The Firmware should clear the TX FIFO, to re-do this transfer.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>entered I2C Hs-mode, at time t1, SCL falling edge after 'START, 8-bit master code (0000_1XXX), NACK' sequence.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>exited I2C Hs-mode, after STOP detection.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_SET</name>
          <description>Master interrupt set request</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASK</name>
          <description>Master interrupt mask</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASKED</name>
          <description>Master interrupt masked request</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3000317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S</name>
          <description>Slave interrupt request</description>
          <addressOffset>0xF40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3010FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine abort the ongoing transfer. 

The Firmware should clear the TX FIFO, to re-do this transfer.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C slave negative acknowledgement received. Set to '1', when the slave receives a NACK (typically after the slave transmitted TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C slave acknowledgement received. Set to '1', when the slave receives a ACK (typically after the slave transmitted TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>I2C STOP event for I2C write transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address.

In non EZ mode, the event is detected on any I2C write transfer intended for this slave. Note that a I2C write address intended for the slave (address is matching and a it is a write transfer) will result in a I2C_WRITE_STOP event independent of whether the I2C address is ACK'd or NACK'd.

In EZ mode, the event is detected only on I2C write transfers that have EZ data written to the memory structure (an I2C write transfer that only communicates an I2C address and EZ address, will not result in this event being detected).

this is not applicable when address in previous transfer is master-code.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C STOP event for I2C (read or write) transfer intended for this slave (address matching is performed). Set to '1', when STOP or REPEATED START event is detected. The REPEATED START event is included in this interrupt cause such that the I2C transfers separated by a REPEATED START can be distinguished and potentially treated separately by the Firmware. Note that the second I2C transfer (after a REPEATED START) may be to a different slave address.

The event is detected on any I2C transfer intended for this slave. Note that a I2C address intended for the slave (address is matching) will result in a I2C_STOP event independent of whether the I2C address is ACK'd or NACK'd.

this is not applicable when address in previous transfer is master-code.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.

In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed  (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>I2C slave matching address received. If CTRL.ADDR_ACCEPT, the received address (including the R/W bit) is available in the RX FIFO. In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the event is detected.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>I2C slave general call address received.  If CTRL.ADDR_ACCEPT, the received address 0x00 (including the R/W bit) is available in the RX FIFO.   In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') and internally clocked operation (CTRL.EC_OP_MODE is '0'), this field is set when the event is detected.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C slave bus error (unexpected detection of START or STOP condition). This should not occur, it represents erroneous I2C bus behavior. In case of a bus error, the I2C slave state machine abort the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>SPI slave deselected after a write EZ SPI transfer occurred.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>SPI slave deselected after any EZ SPI transfer occurred.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>SPI slave deselected at an unexpected time in the SPI transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_RESTART</name>
              <description>I2C slave RESTART received. 
Set to '1', when REPEATED START event is detected.

In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed  (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. 

this is not applicable when address in previous transfer is master-code.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>entered I2C Hs-mode, at time t1, SCL falling edge after 'START, 8-bit master code (0000_1XXX), NACK' sequence.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>exited I2C Hs-mode, after STOP detection.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_SET</name>
          <description>Slave interrupt set request</description>
          <addressOffset>0xF44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3010FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_RESTART</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASK</name>
          <description>Slave interrupt mask</description>
          <addressOffset>0xF48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3010FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_RESTART</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASKED</name>
          <description>Slave interrupt masked request</description>
          <addressOffset>0xF4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3010FFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_RESTART</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_HS_ENTER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_HS_EXIT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX</name>
          <description>Transmitter interrupt request</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Less entries in the TX FIFO than the value specified by TX_FIFO_CTRL.TRIGGER_LEVEL. 

Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>TX FIFO is not full. Dependent on CTRL.MEM_WIDTH: (FF_DATA_NR = EZ_DATA_NR/2)
MEM_WIDTH is '0': # entries != FF_DATA_NR.
MEM_WIDTH is '1': # entries != FF_DATA_NR/2.
MEM_WIDTH is '2': # entries != FF_DATA_NR/4.

Only used in FIFO mode.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>TX FIFO is empty; i.e. it has 0 entries.

Only used in FIFO mode.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full TX FIFO.

Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when the IP is ready to transfer data and EMPTY is '1'.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite write transfer can not get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>UART transmitter received a negative acknowledgement in SmartCard mode. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>UART transmitter done event. This happens when the IP is done transferring all data in the TX FIFO, and the last stop field is transmitted (both TX FIFO and transmit shifter register are empty). Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>UART lost arbitration: the value driven on the TX line is not the same as the value observed on the RX line. This condition event is useful when transmitter and receiver share a TX/RX line. This is the case in LIN or SmartCard modes. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_SET</name>
          <description>Transmitter interrupt set request</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASK</name>
          <description>Transmitter interrupt mask</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX</name>
          <description>Receiver interrupt request</description>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>More entries in the RX FIFO than the value specified by RX_FIFO_CTRL.TRIGGER_LEVEL.

Only used in FIFO mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>RX FIFO is not empty.

Only used in FIFO mode.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>RX FIFO is full. Note that received data frames are lost when the RX FIFO is full. Dependent on CTRL.MEM_WIDTH: (FF_DATA_NR = EZ_DATA_NR/2)
MEM_WIDTH is '0': # entries == FF_DATA_NR.
MEM_WIDTH is '1': # entries == FF_DATA_NR/2.
MEM_WIDTH is '2': # entries == FF_DATA_NR/4.

Only used in FIFO mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Attempt to write to a full RX FIFO. Note: in I2C mode, the OVERFLOW is set when a data frame is received and the RX FIFO is full, independent of whether it is ACK'd or NACK'd.

Only used in FIFO mode.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty RX FIFO.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>AHB-Lite read transfer can not get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Frame error in received data frame. Set to '1', when event is detected. Write with '1' to clear bit. This can be either a start or stop bit(s) error:
Start bit error: after the detection of the beginning of a start bit period (RX line changes from '1' to '0'), the middle of the start bit period is sampled erroneously (RX line is '1').  Note: a start bit error is detected BEFORE a data frame is received.
Stop bit error: the RX line is sampled as '0', but a '1' was expected. Note: a stop bit error may result in failure to receive successive data frame(s). Note: a stop bit error is detected AFTER a data frame is received.

A stop bit error is detected after a data frame is received, and the UART_RX_CTL.DROP_ON_FRAME_ERROR field specifies whether the received frame is dropped or send to the RX FIFO. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '1', the received data frame is dropped. If UART_RX_CTL.DROP_ON_FRAME_ERROR is '0', the received data frame is send to the RX FIFO. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO; i.e. the RX FIFO does not have error flags to tag erroneous data frames.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Parity error in received data frame. Set to '1', when event is detected. Write with '1' to clear bit. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '1', the received frame is dropped. If UART_RX_CTL.DROP_ON_PARITY_ERROR is '0', the received frame is send to the RX FIFO. In SmartCard submode, negatively acknowledged data frames generate a parity error. Note that Firmware can only identify the erroneous data frame in the RX FIFO if it is fast enough to read the data frame before the hardware writes a next data frame into the RX FIFO.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>LIN baudrate detection is completed.  The receiver software uses the UART_RX_STATUS.BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Break detection is successful: the line is '0' for UART_RX_CTRL.BREAK_WIDTH + 1 bit period. Can occur at any time to address unanticipated break fields; i.e. 'break-in-data' is supported. This feature is supported for the UART standard and LIN submodes. For the UART standard submodes, ongoing receipt of data frames is NOT affected; i.e. Firmware is expected to take the proper action. For the LIN submode, possible ongoing receipt of a data frame is stopped and the (partially) received data frame is dropped and baud rate detection is started. Set to '1', when event is detected. Write with '1' to clear bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_SET</name>
          <description>Receiver interrupt set request</description>
          <addressOffset>0xFC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASK</name>
          <description>Receiver interrupt mask</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASKED</name>
          <description>Receiver interrupt masked request</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB1</name>
      <baseAddress>0x40250000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB2</name>
      <baseAddress>0x40260000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB3</name>
      <baseAddress>0x40270000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB4</name>
      <baseAddress>0x40280000</baseAddress>
    </peripheral>
    <peripheral>
      <name>MSC0</name>
      <description>MultiSense Controller</description>
      <headerStructName>MSC</headerStructName>
      <baseAddress>0x40290000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Configuration and Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x100000</resetValue>
          <resetMask>0x81131111</resetMask>
          <fields>
            <field>
              <name>SENSE_EN</name>
              <description>Enables the sense modulator output. 
'0': All switches, static or dynamic, are open.
'1': Switches can be closed/open as per MMIO setting and Sequencer FSM.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSCCMP_EN</name>
              <description>MSC Comparator Enable.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SYNC_EN</name>
              <description>Control bit to create external channel sync clock.
'0': msc_ext_sync_clk_out (and _out_en) tied 0.
'1': Generate msc_ext_sync_clk_out using clock_sync_pos_en and set msc_ext_sync_clk_out_en = 1.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXT_FRAME_START_EN</name>
              <description>Control bit to enable external frame start of Sequencer FSM via GPIO. 
'0': FSM is only sensitive to START_FRAME bit.
'1': FSM sensitive to external frame start (and not sensitive to START_FRAME). This external start can be a new or pending external frame start event or an indication from the LP-AoC FSM.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OPERATING_MODE</name>
              <description>Sequencer FSM Operating Mode
'0': CPU Mode.
'1': Chained-Scan DMA Mode. 
'2': Autonomous Scan Multi Sensor Mode.
'3': Low Power Always-On-Capsense Mode.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPU</name>
                  <description>Frame scan configurations are stored in system RAM. 
Start of frame initiated by CPU via AHB. 
After each scan in frame, the end of scan interrupt is raised. The CPU extracts results and programs and starts the next scan. 
End of frame interrupt is produced so CPU can extract and process data.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CS_DMA</name>
                  <description>Frame scan configurations are stored in system RAM. 
CPU writes into DMA registers to start a DMA transfer. i.e. CPU/firmware initiates a DMA transfer to write first scan configuration.
The rest of the scans in the frame are chained via trigger to DMA.
End of frame interrupt is produced so CPU can extract and process data.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AS_MS</name>
                  <description>Frame scan configurations are stored in IP RAM. 
Start of frame initiated by CPU via AHB.
The rest of the scans are chained autonomously by Sequencer FSM. 
End of frame interrupt is produced so CPU can extract and process data.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LP_AOC</name>
                  <description>Frame scan configurations are stored in IP RAM. 
Start of frame initiated by LP-AOC timer expire.
Rest of the scans are chained autonomously by Sequencer FSM. No end of frame interrupt, no data processing by CPU. 
Wake up interrupt fired upon valid signal detection (LP-AOC FSM).</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_MODE</name>
              <description>Shield buffer operating mode select.
'0': High bandwidth mode.
'1': Shield mode.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HIGH_BW_MODE</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SHIELD_MODE</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_MSC_RATIO</name>
              <description>Control bit for logic that creates clk_msc from clk_hf.
'0': Divided. clk_hf :: clk_msc is at least 2:1 divide ratio. Ratio controlled by clock_msc_pos_en and clock_msc_neg_en provided by PERI.
'1': Pass-through. clk_hf :: clk_msc is 1:1.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIVIDED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PASSTHROUGH</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Master enable of the MSCv3 IP.  Must be set to '1' for any operation to function.
When '0' all analog components are off and all switches are open.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPARE</name>
          <description>Spare MMIO</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>SPARE</name>
              <description>Spare MMIO (Hard IP).</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCAN_CTL1</name>
          <description>Scan Control 1</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF713F</resetMask>
          <fields>
            <field>
              <name>NUM_AUTO_RESAMPLE</name>
              <description>If Sequencer detects a bad conversion and NUM_AUTO_RESAMPLE != 0, it will not store the bad result. Instead, it will automatically re-sample using current configuration without firmware intervention. This process repeats until a good conversion is produced or until the programmed maximum. If bad samples are produces for each programmed re-sample attempt, the final bad sample is stored.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESCAN_DEBUG_MODE</name>
              <description>If this bit is set all results (good and bad) generated by NUM_AUTO_RESAMPLE are stored. Debug feature.

Firmware Rule: Usable setting for NUM_AUTO_RESAMPLE is limited depending on the size of the result FIFO. Size of this FIFO determined by CONFIG_NR and SAMPLE_NR. If CONFIG_NR = 0, FIFO size is SAMPLE_NR. If CONFIG_NR &gt; 0, FIFO size is SAMPLE_NR * CONFIG_NR. NUM_AUTO_RESAMPLE must be less than or equal to the FIFO size in debug mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUM_SAMPLES</name>
              <description>Number of samples (minus 1) to be scanned. NUM_SAMPLES &gt; 1 results in autonomous scan same sensor (AS-SS) behaviour.

Firmware Rule: Usable setting for NUM_SAMPLES is limited depending on the size of the result FIFO. Size of this FIFO determined by CONFIG_NR and SAMPLE_NR. If CONFIG_NR = 0, FIFO size is SAMPLE_NR. If CONFIG_NR &gt; 0, FIFO size is SAMPLE_NR * CONFIG_NR. NUM_SAMPLES must be less than or equal to the FIFO size in debug mode.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAW_COUNT_MODE</name>
              <description>Control bit to handle behaviour when RAW_COUNT exceeds 0xFFFF.
'0': Saturate. In this scenario, RAW_COUNT is clamped at 0xFFFF and RESULT_FIFO_RD.OVERFLOW is set.
'1': Overflow. In this scenario, RAW_COUNT rolls over and RESULT_FIFO_RD.OVERFLOW is set. This mode allows more sensitive tuning if measuring baseline capacitance is a don't care (e.g. SAR use case).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SATURATE</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OVERFLOW</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_CONV_PH_SEL</name>
              <description>Debug counter conversion chop phase select for DEBUG_CONV_COUNT. Must be between 0 and NUM_CONV.

The number of conversions (or chop phases) for a given scan is controlled by NUM_CONV. Although only discrete values are possible for NUM_CONV, any conversion index up to this number may be selected up to NUM_CONV. For example if NUM_CONV = 7 (number of conversions is 8), then DEBUG_CONG_PH_SEL can be any value between 0 and 7 to select the particular conversion that the count is required for.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_START_PTR</name>
              <description>Pointer to first sensor configuration of a frame. Hardware increments a local pointer from this start point. In LP-AoC mode, hardware returns to this pointer after the frame is complete prior to starting the next frame (after a timeout).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCAN_CTL2</name>
          <description>Scan Control 2</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x10103FF</resetMask>
          <fields>
            <field>
              <name>NUM_EPI_CYCLES</name>
              <description>Number of clk_mod cycles to be run during EPILOGUE. Note that setting this register to 0 is an illegal configuration. This guarantees at least 1 clk_mod cycle during EPILOGUE (required to help timing closure in Sequencer FSM).</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CHOP_POL</name>
              <description>Polarity of first chop phase. Hardware updates chop control locally from this point (via inversion and following CHOP_EVEN_HOLD_EN programming also).</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CHOP_EVEN_HOLD_EN</name>
              <description>Use this bit to hold the chop value at the end of every even chop phase of NUM_CONV.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT_CTL1</name>
          <description>Initialisation Control 1</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FFF0FFF</resetMask>
          <fields>
            <field>
              <name>NUM_INIT_CMOD_12_RAIL_CYCLES</name>
              <description>Duration of the coarse initialisation phase (e.g. connecting Cmod1 to vdda and Cmod2 to vssa in full-wave mode). Programmed in terms of clk_mod cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_INIT_CMOD_12_SHORT_CYCLES</name>
              <description>Duration of the coarse short phase (shorting Cmod1 and Cmod2 in full-wave mode). Programmed in terms of clk_mod cycles. Should be set to zero in the case of half-wave mode.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PER_SAMPLE</name>
              <description>Decides if coarse initialisation is done per sample when NUM_SAMPLES &gt; 0 (i.e. more than one sample per scan). Applies to CMOD_SEL selected Cmod.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT_CTL2</name>
          <description>Initialisation Control 2</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF0FFF</resetMask>
          <fields>
            <field>
              <name>NUM_INIT_CMOD_34_RAIL_CYCLES</name>
              <description>Duration of the coarse initialisation phase (e.g. connecting Cmod3 to vdda and Cmod4 to vssa in full-wave mode). Programmed in terms of clk_mod cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_INIT_CMOD_34_SHORT_CYCLES</name>
              <description>Duration of the coarse short phase (shorting Cmod3 and Cmod4 in full-wave mode). Programmed in terms of clk_mod cycles. Should be set to zero in the case of half-wave mode.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT_CTL3</name>
          <description>Initialisation Control 3</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8FFF</resetMask>
          <fields>
            <field>
              <name>NUM_PRO_OFFSET_CYCLES</name>
              <description>Maximum number of clk_mod cycles to be assigned for the PRO_OFFSET state. If NUM_PRO_OFFSET_TRIPS are observed before this timeout, exit at that point.

Programming combinations:
a) OFFSET_CYCLES == 0 &amp;&amp; OFFSET_TRIPS == 0 -&gt; Skip PRO_OFFSET
b) OFFSET_CYCLES == 0 &amp;&amp; OFFSET_TRIPS &gt; 0 -&gt; wait in PRO_OFFSET for OFFSET_TRIPS
c) OFFSET_CYCLES &gt; 0 &amp;&amp; OFFSET_TRIPS == 0 -&gt; wait in PRO_OFFSET for OFFSET_CYCLES
d) OFFSET_CYCLES &gt; 0 &amp;&amp; OFFSET_TRIPS &gt; 0 -&gt; wait in PRO_OFFSET for the first of OFFSET_CYCLES and OFFSET_TRIPS.

Note that if OFFSET_TRIPS &gt; 0:
i) SW_COTCA and SW_COCB autonomously adjust as per their description after each comparator trip apart from the last trip. Expect OFFSET_TRIPS-1 adjustments in PRO_OFFSET.
ii) If FINE_MODE == COMPENSATION SW_CFTCA and SW_CFTCB autonomously swap settings after each comparator trip apart from the last trip. Expect OFFSET_TRIPS-1 adjustments in PRO_OFFSET.
iii) For both sets of switches above, after the last trip the switches revert to their programmed MMIO setting when exiting PRO_OFFSET.

If OFFSET_TRIPS == 0 and OFFSET_CYCLES &gt; 0:
Intention is that PRO_OFFSET be a fixed duration. The autonomous behaviour for this case is the same as the OFFSET_TRIPS &gt; 0 case, except that the number of trips (and hence the number of adjustments for (i) and (ii) above) are unknown in advance. At the end of OFFSET_CYCLES, the switches revert to their programmed MMIO setting when exiting PRO_OFFSET.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_PRO_OFFSET_TRIPS</name>
              <description>Number of comparator trips required to be observed in PRO_OFFSET before proceeding to dummy cycles.

Note that a 'trip' is defined as a change of state of the comparator (either a 0 to 1 or a 1 to 0 transition). A trip at the very start of PRO_OFFSET is considered a trip with respect to this count.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMOD_SEL</name>
              <description>Select which Cmod are used and the cycle thresholds to be used for coarse initialisation. Note this field affects which Cmod switches are autonomously initialised by hardware as well as influencing the cycle counters as per INIT_MODE.
'0' || '2': Use NUM_INIT_CMOD_12_RAIL_CYCLES and NUM_INIT_CMOD_12_SHORT_CYCLES
'1' || '3': Use NUM_INIT_CMOD_34_RAIL_CYCLES and NUM_INIT_CMOD_34_SHORT_CYCLES

Firmware Rule: Firmware must program the appropriate SNS_SW_SEL_CMODx.ENABLED bits to match the Cmod selected with CMOD_SEL. Firmware must also set a valid INIT_MODE with CMOD_SEL.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CMOD_12</name>
                  <description>Used for full-wave</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CMOD_34</name>
                  <description>Used for full-wave</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CMOD_1</name>
                  <description>Used for half-wave</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CMOD_3</name>
                  <description>Used for half-wave</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INIT_MODE</name>
              <description>Determines autonomous initialisation behaviour during INIT_CMOD.
0: Decode CMOD_SEL.
    CMOD_12: S1CV = 1, S2CG = 1
    CMOD_34: S3CV = 1, S4CG = 1
    CMOD_1: S1CV = 1
    CMOD_3: S3CV = 1
1: Decode CMOD_SEL. Should be CMOD_1 or CMOD_3. Firmware Rule: Firmware should also close CBSO, FSP and one of BGRF/RMF/MBF to select type of reference.
    CMOD_1: C1CB = 1
    CMOD_3: C3CB = 1</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>REFERENCE_VDDA</name>
                  <description>Used for full and half wave when Vdda is reference.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REFERENCE_VREF</name>
                  <description>Used for half-wave when Vref is reference.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT_CTL4</name>
          <description>Initialisation Control 4</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF00FF</resetMask>
          <fields>
            <field>
              <name>NUM_PRO_DUMMY_SUB_CONVS</name>
              <description>Number of sub-conversions (dummy cycles) to be run during PRO_DUMMY.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_PRO_WAIT_CYCLES</name>
              <description>Number of clk_mod cycles to be run during PRO_WAIT.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SENSE_DUTY_CTL</name>
          <description>Sense Clock Duty Cycle Control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xBFF0FFF</resetMask>
          <fields>
            <field>
              <name>PHASE_WIDTH</name>
              <description>Control width (clk_mod cycles) of ph0 and ph2 OR ph1 and ph3. If set to zero, Fs is divided equally between all phases. This field is only applicable when LFSR_MODE = DIRECT_CLOCK.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_SHIFT_CYCLES</name>
              <description>Phase shift cycle control for ph0X and ph1X. 

Must be &gt; 0 if PHASE_SHIFT_EN = 1.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_WIDTH_SEL</name>
              <description>Select which phases the PHASE_WIDTH applies to:
'0': PHASE_WIDTH corresponds to width of ph0 and ph2.
'1': PHASE_WIDTH corresponds to width of ph1 and ph3.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PH0_AND_PH2</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_AND_PH3</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SENSE_PERIOD_CTL</name>
          <description>Sense Clock Period Control</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x84C</resetValue>
          <resetMask>0xF0FFF</resetMask>
          <fields>
            <field>
              <name>LFSR_POLY</name>
              <description>Programmable polynomial to be used for the sense LFSR. For example (default):
G(x) = X^12 + X^7 + X^4 + X^3 + 1
LFSR_POLY = 0x84C (1000_0100_1100).
Note that LFSR_POLY[i] = 1 if X^(i+1) is included in the polynomial. The +1 feedback term is implied and doesn't need a programmable bit.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_SCALE</name>
              <description>Shift the LFSR output left by LSFR_SCALE bits before adding to SENSE_DIV. This scaling is only applicable in spread spectrum mode.
Note that the clock divider including the dithering term must fit in 12 bits, otherwise the result is undefined.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FILTER_CTL</name>
          <description>Filter Control</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1010000</resetMask>
          <fields>
            <field>
              <name>BIT_FORMAT</name>
              <description>Determines how the synchronised comparator output is interpreted by the filter pipeline.

Firmware Rule: When FILTER_MODE = CIC1, BIT_FORMAT should be UNSIGNED.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>Input values [0,+1]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>Input values [-1,+1]. In this scenario a value of 0 is interpreted as -1.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTER_MODE</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CIC1</name>
                  <description>Use the standard first order counter low pass filter (equivalent to CIC1).

Scan Time = 2^M
Number of CIC1 sub-samples = 1
Time for first valid CIC1 sub-sample = 2^M
Number of valid CIC1 sub-samples = 1
CIC1 Scan Resolution = 2^M = N</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CIC2</name>
                  <description>Use CIC2 Filter. Advantage of CIC2 over CIC1 is a higher resolution result for an equivalent scan time. All valid sub-samples are averaged to achieve an overall sample result for the scan. Interrupt is fired for every valid sub-sample to facilitate debug of the individual sub-samples.

Scan Time = 2^M
Number of CIC2 sub-samples = (2^M)/N
Time for first valid CIC2 sub-sample = 2N
Number of valid CIC2 sub-samples = ((2^M)/N) - 1
CIC2 Scan Resolution = N^2</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CCOMP_CDAC_CTL</name>
          <description>Compensation CAPDAC Control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FF00</resetMask>
          <fields>
            <field>
              <name>SEL_CO_PRO_OFFSET</name>
              <description>Select value for Compensation CAPDAC size during PRO_OFFSET until the first comparator trip is observed. Otherwise SEL_CO applies.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EPILOGUE_EN</name>
              <description>Control on whether Ccomp is active during EPILOGUE for final balancing in a conversion.

Note that for this bit to enable Ccomp during EPILOGUE, need SEL_CO &gt; 0 or FINE_MODE = COMPENSATION.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DITHER_CDAC_CTL</name>
          <description>Flatspot/Dither CAPDAC Switch Control</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8E0000</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>SEL_FL</name>
              <description>Select value for  Dither/Flatspot CAPDAC size.

If dithering is enabled (FL_EN = 1), this is the seed value for the LFSR. If dithering is disabled, this value is presented directly to the hard IP as the CAPDAC code.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_POLY_FL</name>
              <description>Dither/Flatspot CAPDAC LFSR polynomial. Uses same encoding as the spread spectrum polynomial LFSR_POLY. For example (default):
G(x) = X^8 + X^4 + X^3 + X^2 + 1
LFSR_POLY_FL = 0x8E (1000_1110).
Note that LFSR_POLY_FL[i] = 1 if X^(i+1) is included in the polynomial. The +1 feedback term is implied and doesn't need a programmable bit.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSW_CTL</name>
          <description>Control Mux Switch Control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSW_FUNC_MODE</name>
              <description>Select between SW_SEL_CSW[x] and SW_SEL_CSW_FUNC.

CSW_FUNC_MODE[x] = 0: Use SW_CSW_CTL for control MUX x.
CSW_FUNC_MODE[x] = 1: Use SW_SEL_CSW_FUNC[y] for control MUX x as selected by y = {SW_SEL_CSW_MASK2[x],SW_SEL_CSW_MASK1[x],SW_SEL_CSW_MASK0[x]}.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_GPIO</name>
          <description>GPIO Switch Control</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7713177</resetMask>
          <fields>
            <field>
              <name>SW_CSD_SENSE</name>
              <description>MUX select for csd_sense waveform.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH3</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CSD_SHIELD</name>
              <description>MUX select for csd_shield waveform.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH3</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CSD_MUTUAL</name>
              <description>MUX select for csd_mutual waveform.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CSD_POLARITY</name>
              <description>MUX select for csd_polarity waveform.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CSD_CHARGE</name>
              <description>MUX select for csd_charge waveform.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_DSI_CMOD</name>
              <description>MUX select for dsi_cmod waveform.

if CMOD_SEL = CMOD_12 | CMOD_1
  dsi_cmod[0] = Decode SW_DSI_CMOD to select appropriate dsi_cmod waveform.
  dsi_cmod[1] = 0.
if CMOD_SEL = CMOD_34 | CMOD_3
  dsi_cmod[0] = 0.
  dsi_cmod[1] = Decode SW_DSI_CMOD to select appropriate dsi_cmod waveform.

This is assuming that:
dsi_cmod[0] is routed to cmod1
dsi_cmod[1] is routed to cmod3

Note that hardware overrides MMIO setting for dsi_cmod and sets it 1 during the INIT_SHORT state if using GPIO sensors (SW_DSI_CMOD != OPEN || SW_DSI_CSHTANK != OPEN).</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_PH1_PH0</name>
                  <description>chop == 1 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_PH3_PH1</name>
                  <description>chop == 1 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_DSI_CSH_TANK</name>
              <description>MUX select for dsi_csh_tank waveform.

if CMOD_SEL = CMOD_12 | CMOD_1
  dsi_csh_tank[0] = Decode SW_DSI_CSH_TANK to select appropriate dsi_csh_tank waveform.
  dsi_csh_tank[1] = 0.
if CMOD_SEL = CMOD_34 | CMOD_3
  dsi_csh_tank[0] = 0.
  dsi_csh_tank[1] = Decode SW_DSI_CSH_TANK to select appropriate dsi_csh_tank waveform.

This is assuming that:
dsi_csh_tank[0] is routed to cmod2
dsi_csh_tank[1] is routed to cmod4

Note that hardware overrides MMIO setting for dsi_csh_tank and sets it 1 during the INIT_SHORT state if using GPIO sensors (SW_DSI_CMOD != OPEN || SW_DSI_CSHTANK != OPEN).</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_PH0_PH1</name>
                  <description>chop == 1 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_PH1_PH3</name>
                  <description>chop == 1 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CDAC_RE</name>
          <description>Reference CAPDAC Switch Control</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x337777</resetMask>
          <fields>
            <field>
              <name>SW_RETCA</name>
              <description>Reference CAPDAC top plate to CSD Bus A Switch</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? sel = 10 (clk_reffb) : sel = 11 (!clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? sel = 10 (clk_reffb) : sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>DFT mode (ph1 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>DFT mode (ph3 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_RECB</name>
              <description>Reference CAPDAC to CSD Bus B Switch</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? sel = 10 (clk_reffb) : sel = 11 (!clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? sel = 10 (clk_reffb) : sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>DFT mode (ph1 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>DFT mode (ph3 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_RETV</name>
              <description>Reference CAPDAC top plate to vdda_q Switch.

Firmware Rule: Do not program RETV and RETG such that they are closed simultaneously.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>DFT mode</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>DFT mode</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_RETG</name>
              <description>Reference CAPDAC top plate to vssa_q Switch.

Firmware Rule: Do not program RETV and RETG such that they are closed simultaneously.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>DFT mode</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>DFT mode</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_REBV</name>
              <description>Reference CAPDAC bottom plate to vdda_q Switch.

Firmware Rule: Do not program REBV and REBG such that they are closed simultaneously.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_REBG</name>
              <description>Reference CAPDAC bottom plate to vssa_q Switch.

Firmware Rule: Do not program REBV and REBG such that they are closed simultaneously.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CDAC_CO</name>
          <description>Compensation CAPDAC Switch Control</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x337777</resetMask>
          <fields>
            <field>
              <name>SW_COTCA</name>
              <description>Compensation CAPDAC top plate to CSD Bus A Switch.
Note during the PRO_OFFSET state the following autonomous overriding occurs:
(compout_sync ^ CHOP_POL) ? [sel = 11 (!clk_comp) ] : [sel = 10 (clk_comp)].
Note that the CHOP_POL above is the hardware copy of the current chop polarity.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? sel = 10 (clk_comp) : sel = 11 (!clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? sel = 10 (clk_comp) : sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>DFT mode (ph1 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>DFT mode (ph3 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_COCB</name>
              <description>Compensation CAPDAC to CSD Bus B Switch.
Note during the PRO_OFFSET state the following autonomous overriding occurs:
(compout_sync ^ CHOP_POL) ? [sel = 10 (clk_comp) ] : [sel = 11 (!clk_comp)].
Note that the CHOP_POL above is the hardware copy of the current chop polarity.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? sel = 10 (clk_comp) : sel = 11 (!clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? sel = 10 (clk_comp) : sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>DFT mode (ph1 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>DFT mode (ph3 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_COTV</name>
              <description>Compensation CAPDAC top plate to vdda_q Switch.

Firmware Rule: Do not program COTV and COTG such that they are closed simultaneously.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>DFT mode</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>DFT mode</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_COTG</name>
              <description>Compensation CAPDAC top plate to vssa_q Switch.

Firmware Rule: Do not program COTV and COTG such that they are closed simultaneously.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>DFT mode</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>DFT mode</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_COBV</name>
              <description>Compensation CAPDAC bottom plate to vdda_q Switch.

Firmware Rule: Do not program COBV and COBG such that they are closed simultaneously.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_COBG</name>
              <description>Compensation CAPDAC bottom plate to vssa_q Switch.

Firmware Rule: Do not program COBV and COBG such that they are closed simultaneously.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CDAC_CF</name>
          <description>Fine CAPDAC Switch Control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x337777</resetMask>
          <fields>
            <field>
              <name>SW_CFTCA</name>
              <description>Fine CAPDAC top plate to CSD Bus A Switch.
Note during the PRO_OFFSET state the following autonomous overriding occurs if FINE_MODE = COMPENSATION:
(compout_sync ^ CHOP_POL) ? [sel = 11 (!clk_comp) ] : [sel = 10 (clk_comp)].
Note that the CHOP_POL above is the hardware copy of the current chop polarity.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>case({chop,FINE_MODE})
{1,REFERENCE} : sel = 11 (!clk_reffb)
{1,COMPENSATION} : sel = 11 (!clk_comp)
{0,REFERENCE} : sel = 10 (clk_reffb)
{0,COMPENSATION} : sel = 10 (clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>case({chop,FINE_MODE})
{1,REFERENCE} : sel = 10 (clk_reffb)
{1,COMPENSATION} : sel = 10 (clk_comp)
{0,REFERENCE} : sel = 11 (!clk_reffb)
{0,COMPENSATION} : sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>DFT mode (ph1 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>DFT mode (ph3 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CFTCB</name>
              <description>Fine CAPDAC top plate to CSD Bus B Switch.
Note during the PRO_OFFSET state the following autonomous overriding occurs if FINE_MODE = COMPENSATION:
(compout_sync ^ CHOP_POL) ? [sel = 10 (clk_comp) ] : [sel = 11 (!clk_comp)].
Note that the CHOP_POL above is the hardware copy of the current chop polarity.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>case({chop,FINE_MODE})
{1,REFERENCE} : sel = 11 (!clk_reffb)
{1,COMPENSATION} : sel = 11 (!clk_comp)
{0,REFERENCE} : sel = 10 (clk_reffb)
{0,COMPENSATION} : sel = 10 (clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>case({chop,FINE_MODE})
{1,REFERENCE} : sel = 10 (clk_reffb)
{1,COMPENSATION} : sel = 10 (clk_comp)
{0,REFERENCE} : sel = 11 (!clk_reffb)
{0,COMPENSATION} : sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>DFT mode (ph1 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>DFT mode (ph3 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CFTV</name>
              <description>Fine CAPDAC top plate to vdda_q Switch.

Firmware Rule: Do not program CFTV and CFTG such that they are closed simultaneously.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 [(FINE_MODE == REFERENCE) ? clk_reffb : clk_comp]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 [(FINE_MODE == REFERENCE) ? !clk_reffb : !clk_comp]</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>DFT mode (ph0 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>DFT mode (ph2 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CFTG</name>
              <description>Fine CAPDAC top plate to vssa_q Switch.

Firmware Rule: Do not program CFTV and CFTG such that they are closed simultaneously.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 [(FINE_MODE == REFERENCE) ? clk_reffb : clk_comp]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 [(FINE_MODE == REFERENCE) ? !clk_reffb : !clk_comp]</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>DFT mode (ph0 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>DFT mode (ph2 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CFBV</name>
              <description>Fine CAPDAC bottom plate to vdda_q Switch.

Firmware Rule: Do not program CFBV and CFBG such that they are closed simultaneously.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>FINE_MODE == REFERENCE ? sel = 10 (clk_reffb) : sel = 10 (clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>FINE_MODE == REFERENCE ? sel = 11 (!clk_reffb) : sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CFBG</name>
              <description>Fine CAPDAC bottom plate to vssa_q Switch.

Firmware Rule: Do not program CFBV and CFBG such that they are closed simultaneously.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>FINE_MODE == REFERENCE ? sel = 10 (clk_reffb) : sel = 10 (clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>FINE_MODE == REFERENCE ? sel = 11 (!clk_reffb) : sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CMOD1</name>
          <description>CMOD Switch Control 1</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF0F3F0F</resetMask>
          <fields>
            <field>
              <name>SW_C1CA</name>
              <description>CMOD1 to CSD Bus A Switch.

During INIT_SHORT (used for full-wave scanning) if CMOD_SEL = CMOD_12, hardware sets C1CA = CLOSED.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C1CB</name>
              <description>CMOD1 to CSD Bus B Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C1CC</name>
              <description>CMOD1 to CSD Bus C Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C1CV</name>
              <description>CMOD1 to vdda_q Switch.

Firmware Rule: Do not program C1CV and C1CG such that they are closed simultaneously.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>clk_extfb</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C1CG</name>
              <description>CMOD1 to vssa_q Switch.

Firmware Rule: Do not program C1CV and C1CG such that they are closed simultaneously.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_PH3</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>clk_extfb_bar</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REF_MODE</name>
              <description>CMOD1 is used as a reference in scenario where CMOD can be re-purposed when not used as a CMOD.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>CMOD1 enable.

Firmware Rule:
1) If any of C1CA/C1CB/C1CC can be 1 (statically or dynamically), ENABLED must be 1.
2) If statically closing (using CLOSED setting) any of C1CA/C1CB/C2CC, ENABLE must be set to 1 in a previous bus access to ensure break-before-make. When re-opening from static CLOSED, C1CA/C1CB/C1CC must be opened in a previous bus access before clearing ENABLE to 0. This is not required for dynamic programming options since e.g. PH0 is not active when these registers are programmed.
3) In any use case where C1CA/C1CB/C1CC are required to be set CLOSED via autonomous scanning, rule (2) cannot be observed. Example use case below**. In this scenario to get the desired effect, the options are to either:
a) Dedicate a specific CSW sensor for this purpose, follow rule (2) and do not change the settings autonomously for this sensor.
b) Use unused Cmod switches (e.g. if Cmod1/2 are being used, use the switches for Cmod3/4).

** Any use case where a csdbusa/b/c is not used. For example FW CSX wherein csdbusc not used; then csdbusc is statically connected to vssa_sc (C1CG=CLOSED, ENABLED=1 and C1CC=CLOSED).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CMOD2</name>
          <description>CMOD Switch Control 2</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF0F3F0F</resetMask>
          <fields>
            <field>
              <name>SW_C2CA</name>
              <description>CMOD2 to CSD Bus A Switch.

During INIT_SHORT (used for full-wave scanning) if CMOD_SEL = CMOD_12, hardware sets C1CA = CLOSED.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C2CB</name>
              <description>CMOD2 to CSD Bus B Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C2CC</name>
              <description>CMOD2 to CSD Bus C Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C2CV</name>
              <description>CMOD2 to vdda_q Switch.

Firmware Rule: Do not program C2CV and C2CG such that they are closed simultaneously.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>clk_extfb</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C2CG</name>
              <description>CMOD2 to vssa_q Switch.

Firmware Rule: Do not program C2CV and C2CG such that they are closed simultaneously.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_PH3</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>clk_extfb_bar</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REF_MODE</name>
              <description>CMOD2 is used as a reference in scenario where CMOD can be re-purposed when not used as a CMOD.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>CMOD2 enable.

Firmware Rule:
1) If any of C2CA/C2CB/C2CC can be 1 (statically or dynamically), ENABLED must be 1.
2) If statically closing (using CLOSED setting) any of C2CA/C2CB/C2CC, ENABLE must be set to 1 in a previous bus access to ensure break-before-make. When re-opening from static CLOSED, C2CA/C2CB/C2CC must be opened in a previous bus access before clearing ENABLE to 0. This is not required for dynamic programming options since e.g. PH0 is not active when these registers are programmed.
3) In any use case where C2CA/C2CB/C2CC are required to be set CLOSED via autonomous scanning, rule (2) cannot be observed. Example use case below**. In this scenario to get the desired effect, the options are to either:
a) Dedicate a specific CSW sensor for this purpose, follow rule (2) and do not change the settings autonomously for this sensor.
b) Use unused Cmod switches (e.g. if Cmod1/2 are being used, use the switches for Cmod3/4).

** Any use case where a csdbusa/b/c is not used. For example FW CSX wherein csdbusc not used; then csdbusc is statically connected to vssa_sc (C2CG=CLOSED, ENABLED=1 and C2CC=CLOSED).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CMOD3</name>
          <description>CMOD Switch Control 3</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF0F3F0F</resetMask>
          <fields>
            <field>
              <name>SW_C3CA</name>
              <description>CMOD3 to CSD Bus A Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C3CB</name>
              <description>CMOD3 to CSD Bus B Switch.

During INIT_SHORT (used for full-wave scanning) if CMOD_SEL = CMOD_34, hardware sets C3CB = CLOSED.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C3CC</name>
              <description>CMOD3 to CSD Bus C Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C3CV</name>
              <description>CMOD3 to vdda_q Switch.

Firmware Rule: Do not program C3CV and C3CG such that they are closed simultaneously.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>clk_extfb</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C3CG</name>
              <description>CMOD3 to vssa_q Switch.

Firmware Rule: Do not program C3CV and C3CG such that they are closed simultaneously.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_PH3</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>clk_extfb_bar</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REF_MODE</name>
              <description>CMOD3 is used as a reference in scenario where CMOD can be re-purposed when not used as a CMOD.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>CMOD3 enable.

Firmware Rule:
1) If any of C3CA/C3CB/C3CC can be 1 (statically or dynamically), ENABLED must be 1.
2) If statically closing (using CLOSED setting) any of C3CA/C3CB/C3CC, ENABLE must be set to 1 in a previous bus access to ensure break-before-make. When re-opening from static CLOSED, C3CA/C3CB/C3CC must be opened in a previous bus access before clearing ENABLE to 0. This is not required for dynamic programming options since e.g. PH0 is not active when these registers are programmed.
3) In any use case where C3CA/C3CB/C3CC are required to be set CLOSED via autonomous scanning, rule (2) cannot be observed. Example use case below**. In this scenario to get the desired effect, the options are to either:
a) Dedicate a specific CSW sensor for this purpose, follow rule (2) and do not change the settings autonomously for this sensor.
b) Use unused Cmod switches (e.g. if Cmod1/2 are being used, use the switches for Cmod3/4).

** Any use case where a csdbusa/b/c is not used. For example FW CSX wherein csdbusc not used; then csdbusc is statically connected to vssa_sc (C3CG=CLOSED, ENABLED=1 and C3CC=CLOSED).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CMOD4</name>
          <description>CMOD Switch Control 4</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF0F3F0F</resetMask>
          <fields>
            <field>
              <name>SW_C4CA</name>
              <description>CMOD4 to CSD Bus A Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C4CB</name>
              <description>CMOD4 to CSD Bus B Switch.

During INIT_SHORT (used for full-wave scanning) if CMOD_SEL = CMOD_34, hardware sets C4CB = CLOSED.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C4CC</name>
              <description>CMOD4 to CSD Bus C Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C4CV</name>
              <description>CMOD4 to vdda_q Switch.

Firmware Rule: Do not program C4CV and C4CG such that they are closed simultaneously.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>clk_extfb</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C4CG</name>
              <description>CMOD4 to vssa_q Switch.

Firmware Rule: Do not program C4CV and C4CG such that they are closed simultaneously.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_PH3</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>clk_extfb_bar</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REF_MODE</name>
              <description>CMOD4 is used as a reference in scenario where CMOD can be re-purposed when not used as a CMOD.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>CMOD4 enable.

Firmware Rule:
1) If any of C4CA/C4CB/C4CC can be 1 (statically or dynamically), ENABLED must be 1.
2) If statically closing (using CLOSED setting) any of C4CA/C4CB/C4CC, ENABLE must be set to 1 in a previous bus access to ensure break-before-make. When re-opening from static CLOSED, C4CA/C4CB/C4CC must be opened in a previous bus access before clearing ENABLE to 0. This is not required for dynamic programming options since e.g. PH0 is not active when these registers are programmed.
3) In any use case where C4CA/C4CB/C4CC are required to be set CLOSED via autonomous scanning, rule (2) cannot be observed. Example use case below**. In this scenario to get the desired effect, the options are to either:
a) Dedicate a specific CSW sensor for this purpose, follow rule (2) and do not change the settings autonomously for this sensor.
b) Use unused Cmod switches (e.g. if Cmod1/2 are being used, use the switches for Cmod3/4).

** Any use case where a csdbusa/b/c is not used. For example FW CSX wherein csdbusc not used; then csdbusc is statically connected to vssa_sc (C4CG=CLOSED, ENABLED=1 and C4CC=CLOSED).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OBS_CTL</name>
          <description>Observability Control</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0F0F0F</resetMask>
          <fields>
            <field>
              <name>OBSERVE0</name>
              <description>Selects the source for observe output signal 0:
0: Fs
1: Comparator Output (direct from hard IP).
2: Comparator Output captured on clk_hf_adv.
3: Comparator Output captured on clk_mod.
4: Current raw counter LSB.
5: Scan Done (hardware set signal for INTR.SCAN)
6: ph0.
7: ph1.
8: ph2.
9: ph3.
10: ph0X
11: ph1X
12-14: Unused (0).
15: Sequencer FSM state bit 0.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FS</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_ADV</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_SYNC</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COUNTER_LSB</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SCAN_DONE</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_1</name>
                  <description>N/A</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_2</name>
                  <description>N/A</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_3</name>
                  <description>N/A</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SM_STATE_0</name>
                  <description>N/A</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OBSERVE1</name>
              <description>Selects the source for observe output signal 1:
0-14: See OBSERVE0.
15: Sequencer FSM state bit 1.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FS</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_ADV</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_SYNC</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COUNTER_LSB</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SCAN_DONE</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_1</name>
                  <description>N/A</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_2</name>
                  <description>N/A</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_3</name>
                  <description>N/A</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SM_STATE_1</name>
                  <description>N/A</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OBSERVE2</name>
              <description>Selects the source for observe output signal 2:
0-14: See OBSERVE0.
15: Sequencer FSM state bit 2.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FS</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_ADV</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_SYNC</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COUNTER_LSB</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SCAN_DONE</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_1</name>
                  <description>N/A</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_2</name>
                  <description>N/A</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_3</name>
                  <description>N/A</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SM_STATE_2</name>
                  <description>N/A</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OBSERVE3</name>
              <description>Selects the source for observe output signal 3:
0-14: See OBSERVE0.
15: Sequencer FSM state bit 3.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FS</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_ADV</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_SYNC</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COUNTER_LSB</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SCAN_DONE</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_1</name>
                  <description>N/A</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_2</name>
                  <description>N/A</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_3</name>
                  <description>N/A</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SM_STATE_3</name>
                  <description>N/A</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WAKEUP_CTL</name>
          <description>Wakeup Control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>WAKEUP_TIMER</name>
              <description>Timer interval between wakeup scans in LP-AoC mode. Assumes a 32kHz operating clock (clk_lf). Desired range is 1-&gt;2000ms.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>If set, then LP AoC FSM will operate when in DEEP_SLEEP. This also switches clk_hf -&gt; clk_lf.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LP_AOC_CTL</name>
          <description>LP-AoC Control</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUCKET_THRESHOLD</name>
              <description>Global threshold to control the per sensor SENSOR_BASELINE updates.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCKET_STEP_SIZE</name>
              <description>Global step size for SENSOR_BASELINE adjustment.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEBOUNCE_THRESHOLD</name>
              <description>Global threshold for successive TOUCH_THRESHOLD exceeds to warrant a full system wakeup.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS1</name>
          <description>General Status Register 1</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RAW_COUNT</name>
              <description>Live current raw counter. For debug/test purposes. In normal operation, Firmware/DMA will typically read results from RESULT_FIFO_RD.

Note that in CIC2 mode, this value gets updated at the decimation rate. When the SUB_SAMPLE interrupt is asserted, firmware could read this value before the next SUB_SAMPLE interrupt fires to debug sub-samples if desired.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RAW_COUNT_POS</name>
              <description>Useful for determining component counts for positive and negative charge by subtracting from RAW_COUNT.

When PHASE_MODE_SEL = FOUR_PHASE
  RAW_COUNT_POS: Counts during ph1/ph2 of SUB_CONV.
When PHASE_MODE_SEL = TWO_PHASE
  RAW_COUNT_POS: Counts during ph0 of SUB_CONV.

This counter increments whenever the Cref CAPDAC is balancing during the corresponding phases above. Note that digital non-overlap is ignored for the purposes of this count since balancing occurs irrespective of these settings. Hence the 'raw' phases (pre application of any digital non-overlap) are considered as the measurement window for this counter.

Applicable for CIC1 and CIC2 mode. In CIC2 mode the count is determined by the value of the input to the first integrator stage (equivalent to CIC1 behaviour).</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS2</name>
          <description>General Status Register 2</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_CONV_COUNT</name>
              <description>Debug raw count for a particular conversion. Enabled only during a specified conversion of a sample (a specific chop phase).

Only applicable for CIC1 mode. In CIC2 mode this counter remains zero.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS3</name>
          <description>General Status Register 3</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x110FFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_SUB_CONVS</name>
              <description>Number of sub-conversions remaining while in PRO_DUMMY and SUB_CONV.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SEQ_STATE</name>
              <description>MSC Sequencer FSM state.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_DMA_WRITE</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOAD_CONFIG</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_SCAN_START</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ASSERT_RDY</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_CONSENSUS</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INIT_CMOD</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INIT_SHORT</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRO_OFFSET</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRO_DUMMY</name>
                  <description>N/A</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRO_WAIT</name>
                  <description>N/A</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUB_CONV</name>
                  <description>N/A</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EPILOGUE</name>
                  <description>N/A</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_DMA_READ_NEW_SAMPLE</name>
                  <description>N/A</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_DMA_READ_EOF</name>
                  <description>N/A</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POST_SCAN</name>
                  <description>N/A</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FS_CLOCK</name>
              <description>Sense clock Fs control waveform. For debug/test purposes.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MSC_CMP_OUT</name>
              <description>Output of main sensing comparator (synchronized). For debug/test purposes.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT_FIFO_STATUS</name>
          <description>Result FIFO Status</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Number of used/occupied entries in the result FIFO. When '0', the FIFO is empty.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>Result FIFO write pointer: FIFO location at which a new data is written by the hardware.

Note: This functionality is intended for debugging purposes.</description>
              <bitRange>[19:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>Result FIFO read pointer: FIFO location from which data is read via AHB.

Note: This functionality is intended for debugging purposes.</description>
              <bitRange>[29:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_UNDERFLOW</name>
              <description>Hardware sets this field to '1', when reading from an empty FIFO (RESULT_FIFO_STATUS.USED is '0').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description>Set if hardware attempts to write a RAW_COUNT (and associated metrics) to an already full result FIFO.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT_FIFO_RD</name>
          <description>Result FIFO Pointer</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF71FFFF</resetMask>
          <fields>
            <field>
              <name>RAW_COUNT</name>
              <description>FILTER_MODE = CIC1: Accumulated raw count for a sample. 
FILTER_MODE = CIC2: Average value of all valid sub-samples over all conversions in a sample. Note that the hardware averaging capabilities are limited. See INTR.CIC2_ERROR - if this interrupt asserts it *may* be possible to firmware back calculate the correct average.

See SCAN_CTL1.RAW_COUNT_MODE for overflow behaviour of RAW_COUNT.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>RAW_COUNT overflow.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESAMPLE_COUNT</name>
              <description>Counter indicating number of attempted re-samples (via NUM_AUTO_RESAMPLE) for this raw count.

If RESAMPLE_COUNT = 0 and NUM_AUTO_RESAMPLE &gt; 0, this raw count was obtained from the first sample attempt.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAD_CONV_COUNT</name>
              <description>Counter to indicate whether conversion of a sample is bad at the end of each chop phase. This is true if the comparator has not tripped by the end of EPILOGUE in a chop phase. 

BAD_CONV_COUNT can have a maximum value of 8 (based on largest legal NUM_CONV).

If RESAMPLE_COUNT &gt; 0 and BAD_CONV_COUNT = 0, this indicates that RESAMPLE_COUNT bad samples were encountered before this good sample was obtained.

If RESAMPLE_COUNT &gt; 0 and BAD_CONV_COUNT &gt; 0, this indicates that all NUM_AUTO_RESAMPLE attempts have been executed and the final attempt had BAD_CONV_COUNT bad conversions. In this situation RESAMPLE_COUNT should equal NUM_AUTO_RESAMPLE.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>MSCv3 Interrupt Cause Register</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC1111111</resetMask>
          <fields>
            <field>
              <name>SUB_SAMPLE</name>
              <description>A valid CIC2 sub-sample is complete. To facilitate firmware averaging of sub-samples. For debug purposes.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE</name>
              <description>A single sample is complete. For debug purposes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCAN</name>
              <description>A single scan is complete.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Coarse initialisation complete. For debug purposes.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME</name>
              <description>A single frame is complete.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC2_ERROR</name>
              <description>CIC2 error detected. This bit is set at the end of a sample if the number of valid CIC2 sub-samples is not one of [1,2,4,8,16]. At the end of a CIC2 sample, RESULT_FIFO_RD.RAW_COUNT contains the average of the valid sub-samples observed during that sample. The average is computed by a power of 2 shift as per below for the number of valid CIC2 samples observed:
0,1 -&gt; no division (not a typical use case since an average of multiple sub-samples is desired)
2 -&gt; divide by 2
3,4 -&gt; divide by 4
5,6,7,8 -&gt; divide by 8
9+ -&gt; divide by 16
The RESULT_FIFO_RD.RAW_COUNT value is only the true average if the number of valid CIC2 sub-samples is [1,2,4,8,16]. However, in the cases of [3.4.5.6.9.10,11,12,13,14,15] firmware can back-calculate the real average from the computed average (RAW_COUNT) and the divisor used to compute that average (1,2,4,8,16 above) as follows assuming the number of valid sub-samples is known:

Real_Average = Computed_Average*(Computed_Divider/NumSubSamples)

If the number of sub-samples exceeds 16, this cannot be reliably computed due to internal hardware overflows.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONFIG_REQ</name>
              <description>Request for scan configuration and scan start. The Sequencer FSM is entering WAIT_SCAN_START when this interrupt is raised. This interrupt can be used in CPU mode in a multi-channel scenario with external frame start to indicate to firmware that it is required to configure the channel and start a scan.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_UNDERFLOW</name>
              <description>Result FIFO underflow condition.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description>Result FIFO overflow condition.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>MSCv3 Interrupt Set Register</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC1111111</resetMask>
          <fields>
            <field>
              <name>SUB_SAMPLE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCAN</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC2_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONFIG_REQ</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>MSCv3 Interrupt Mask Register</description>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC1111111</resetMask>
          <fields>
            <field>
              <name>SUB_SAMPLE</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCAN</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC2_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONFIG_REQ</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>MSCv3 Interrupt Masked Register</description>
          <addressOffset>0x17C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC1111111</resetMask>
          <fields>
            <field>
              <name>SUB_SAMPLE</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SAMPLE</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SCAN</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CIC2_ERROR</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CONFIG_REQ</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_UNDERFLOW</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_LP</name>
          <description>Low Power Interrupt Cause Register</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>LP-AoC has detected wakeup.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_LP_SET</name>
          <description>Low Power Interrupt Set Register</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_LP_MASK</name>
          <description>Low Power Interrupt Mask Register</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_LP_MASKED</name>
          <description>Low Power Interrupt Masked Register</description>
          <addressOffset>0x18C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>Logical AND of corresponding INTR_LP and INTR_LP_MASK bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAME_CMD</name>
          <description>Frame Command Register</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>START_FRAME</name>
              <description>Start the MSCv3 sequencer frame process. Note that a rising edge on this bit also creates a 2x cycle clk_msc pulse on the msc_ext_frm_start_out signal. The corresponding msc_ext_frm_start_out_en is controlled by CTL.ENABLED.

Sequencer FSM clears this bit on egress from IDLE. If START_FRAME is set by firmware when FSM is not in IDLE, the hardware must hold the bit set to allow for 'pending' frame behaviour.

Firmware Rule:
Note if FRAME_CMD is used in a multi-channel scenario care must be taken by firmware not to excessively delay FRAME_CMD to each individual channel. If not, a window exists where the first channel that sees FRAME_CMD can reach the WAIT_CONSENSUS state and mistakenly believe all channels are ready for lockstep scanning when the reality is the other channels are still in IDLE and indicating ready because they haven't been initiated yet.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAKEUP_CMD</name>
          <description>Wakeup Command Register</description>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10001</resetMask>
          <fields>
            <field>
              <name>WAIT_FOR_DS</name>
              <description>Set by firmware to prime the LP-AoC FSM to be ready to detect entry to DEEP_SLEEP. When detected, hardware clears the bit down and the LP-AoC FSM periodically scans all valid sensor configurations programmed in the sensor configuration storage starting from FRAME_START_PTR.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ABORT</name>
              <description>Abort the LP-AoC when in WAIT_FOR_DS state.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_STRUCT_CTL</name>
          <description>Sensor Struct Control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0F</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Starting offset into SNS_* registers of current sensor configuration in local IP storage. Used by LOAD_CONFIG state in Sequencer FSM. Applicable only when CONFIG_NR &gt; 0.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LENGTH</name>
              <description>Number of SNS_* registers from OFFSET for current sensor configuration in local IP storage. Used by LOAD_CONFIG state in Sequencer FSM. Applicable only when CONFIG_NR &gt; 0.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_LP_AOC_SENSOR_CTL1</name>
          <description>LP-AoC Sensor Control 1</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>P_BUCKET</name>
              <description>Per sensor bucket for baseline greater than raw count adjustments.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>N_BUCKET</name>
              <description>Per sensor bucket for baseline &lt;= raw count adjustments.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_LP_AOC_SENSOR_CTL2</name>
          <description>LP-AoC Sensor Control 2</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SENSOR_BASELINE</name>
              <description>Per sensor baseline value.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUCH_THRESHOLD</name>
              <description>Per sensor threshold for |baseline - rawCount| to warrant a single touch detect.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_SW_SEL_CSW_MASK2</name>
          <description>Control MUX Function Select Mask 2</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUNC_MASK</name>
              <description>{SNS_SW_SEL_CSW_MASK2.FUNC_MASK[x],
SNS_SW_SEL_CSW_MASK1.FUNC_MASK[x],
SNS_SW_SEL_CSW_MASK0.FUNC_MASK[x]} used to select appropriate SW_SEL_CSW_FUNC[x] when CSW_FUNC_MODE[x] = 1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_SW_SEL_CSW_MASK1</name>
          <description>Control MUX Function Select Mask 1</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUNC_MASK</name>
              <description>{SNS_SW_SEL_CSW_MASK2.FUNC_MASK[x],
SNS_SW_SEL_CSW_MASK1.FUNC_MASK[x],
SNS_SW_SEL_CSW_MASK0.FUNC_MASK[x]} used to select appropriate SW_SEL_CSW_FUNC[x] when CSW_FUNC_MODE[x] = 1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_SW_SEL_CSW_MASK0</name>
          <description>Control MUX Function Select Mask 0</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUNC_MASK</name>
              <description>{SNS_SW_SEL_CSW_MASK2.FUNC_MASK[x],
SNS_SW_SEL_CSW_MASK1.FUNC_MASK[x],
SNS_SW_SEL_CSW_MASK0.FUNC_MASK[x]} used to select appropriate SW_SEL_CSW_FUNC[x] when CSW_FUNC_MODE[x] = 1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_SCAN_CTL</name>
          <description>Sensor Scan Control</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_SUB_CONVS</name>
              <description>Number of sub-conversions (minus 1) in a conversion.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_DIV</name>
              <description>The ratio (minus 1) of clk_comp::clk_mod.

Notes for tuning:
Fs = Fmod / Kref
Fcomp = Kcomp * Fs

MSCv3 MMIO provides:
Kref = (SENSE_DIV+1)
Fs = Fmod/(SENSE_DIV+1)
Fcomp = Fmod / (COMP_DIV+1)

Therefore:
Kcomp = Fmod/[Fs*(COMP_DIV+1)]

Kcomp = (SENSE_DIV+1)/(COMP_DIV+1)

It is expected that Kcomp be programmed as an integer. Anything else is considered a mis-programming.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_CONV</name>
              <description>Number of conversions (minus 1) per scanned sample. This is required for chopping (chop polarity is updated per conversion).</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ONE</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TWO</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FOUR</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EIGHT</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INIT_BYPASS</name>
              <description>Coarse initialisation bypass control. Applies to CMOD_SEL selected Cmod.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_CDAC_CTL</name>
          <description>Sensor CAPDAC Control</description>
          <addressOffset>0x21C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x17FFFFFF</resetMask>
          <fields>
            <field>
              <name>SEL_RE</name>
              <description>Select value for Reference CAPDAC size.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_CO</name>
              <description>Select value for Compensation CAPDAC size.

Note if SEL_CO = 0 and FINE_MODE != COMPENSATION, then clk_comp is gated during PRO_DUMMY, SUB_CONV and EPILOGUE.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_CF</name>
              <description>Select value for Fine CAPDAC size.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FINE_MODE</name>
              <description>Operational mode for Fine CAPDAC</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>REFERENCE</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMPENSATION</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLOCK_REF_RATE</name>
              <description>Used to select clk_mod or clk_mod/2 to as clk_ref. This clock is gated depending on the synchronised comparator to generate the gated feedback clock (clk_reffb) to the Reference CAPDAC.
'0': Use clk_mod.
'1': Use clk_mod/2.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLK_MOD</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALF_CLK_MOD</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FL_EN</name>
              <description>Dither/Flatspot LFSR enable control.

'0': Dither/Flatspot LFSR is disabled. LFSR_SCALE_FL, LFSR_SCALE_TYPE_FL and ACTIVATION_MODE and MSB manipulation logic have no effect. The hard IP is presented with the code programmed into SEL_FL.

'1': The Dither/Flatspot LFSR is enabled.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LFSR_SCALE_FL</name>
              <description>Shift the magnitude portion of the Flatspot/Dither CAPDAC LFSR output code left or right by LSFR_SCALE_FL bits. Direction of shift controlled by LFSR_SCALE_TYPE_FL.

Note since the magnitude is 7-bits, the maximum shift is 6-bits. The sign bit does not form part of the shift.

Example: 6-bit polynomial (x^6 + x^4 + x^3 + x^2 + 1).

lfsr_fl_out[7] = lfsr_fl[5]; // Sign bit always connected in MSB to HardIP.
if(LFSR_SCALE_TYPE_FL == LEFT)
  lfsr_out[6:0] = {2'b00,lfsr[4:0]} &lt;&lt; LFSR_SCALE_FL; // Scaled 7-bit magnitude.
else
  lfsr_out[6:0] = {2'b00,lfsr[4:0]} &gt;&gt; LFSR_SCALE_FL; // Scaled 7-bit magnitude.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LFSR_SCALE_TYPE_FL</name>
              <description>Flatspot/Dither CAPDAC shift direction.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RIGHT</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEFT</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_CTL</name>
          <description>Sense Control and Command Register</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC000FE00</resetValue>
          <resetMask>0xFFFFFFF7</resetMask>
          <fields>
            <field>
              <name>START_SCAN</name>
              <description>Start the MSCv3 sequencer scan process. The sequencer will clear this bit when it is done. Depending on the mode the sequencer is done when all NUM_SAMPLES for this scan have been accumulated, or if the sequencer is reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Indicator of sensor configuration validity.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LAST</name>
              <description>Indicator that current sensor configuration is the last sensor in the frame.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MULTI_CH_MODE</name>
              <description>Multi channel mode configuration. Determines whether consensus mechanism is engaged to ensure channels scan in lockstep. 
'0': Single channel.
'1': Wait for external sync (off-chip). 
'2': Wait for internal sync (on-chip).</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTERNAL</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INTERNAL</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SENSE_MODE_SEL</name>
              <description>Sense mode register structure selection. This field allows quick change between registers that influence sense mode. This register selects which structure is currently 'live' and used by the IP.

These registers are captured in MODE_STRUCT. The usable values in this register is determined by design time parameter SENSE_MODE_NR.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SENSE_MODE_0</name>
                  <description>Use MODE_STRUCT[0].</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE_MODE_1</name>
                  <description>Use MODE_STRUCT[1].</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE_MODE_2</name>
                  <description>Use MODE_STRUCT[2].</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE_MODE_3</name>
                  <description>Use MODE_STRUCT[3].</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DECIM_RATE</name>
              <description>Sets the decimation rate for the sinc^2 filter (CIC2). Typically referred to as N. Note N = DECIM_RATE + 1. Only applies when FILTER_CTL.FILTER_MODE = CIC2, and irrelevant for CIC1 mode (no effect in this mode).

Maximum value out of CIC2 is N^2 (unsigned input) and +/- N^2 (signed input).

Since CIC2 uses a 16-bit pipeline, the maximum range is [0,2^16-1] (unsigned) and [-2^15,2^15-1] (signed). This implies a limitation on maximum usable DECIM_RATE depending on BIT_FORMAT signed/unsigned.

BIT_FORMAT = UNSIGNED -&gt; DECIM_RATE(max) = 254 (N = 255).
BIT_FORMAT = SIGNED -&gt; DECIM_RATE(max) = 180 (N = 181).

The scan time for M-bit scan is 2^M clk_mod cycles. This value is determined by (SENSE_DIV+1)*(NUM_SUB_CONVS+1).

Note that the CIC2 filter does not operate in the EPILOGUE state, so NUM_EPI_CYCLES does not feed into the above equation.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SENSE_DIV</name>
              <description>The length (minus 1) of the sense modulation 'clock' period in clk_mod cycles (frequency = Fs). SENSE_DIV + 1 = sense_ratio.
Note this is the base divider, clock dithering may change the actual period length.

Firmware Rule: Firmware is responsible for programming a value in this register to ensure correct operation. When LFSR_MODE = DIRECT_CLOCK, in 2-phase mode sense_ratio needs to be &gt;=4 to allow for digital non-overlap. In 4-phase mode, sense_ratio needs to be &gt;=8. 

If spread spectrum is enabled (LFSR_MODE = SPREAD_SPECTRUM), SENSE_DIV must be programmed large enough to ensure that negative dithering does not cause sense_ratio to become too small.

It is possible for SENSE_DIV to be as low as zero though when LFSR_MODE = PRS (if digital non-overlap is disabled). This is because in PRS mode, SENSE_DIV defines the rate at which the LFSR is clocked and the MSB of the LFSR is used to create the phase signals.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_MODE</name>
              <description>Mode for generating the sense clock.
'0': Direct Clocking.
'1': Spread Spectrum.
'2': PRS.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIRECT_CLOCK</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPREAD_SPECTRUM</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRS</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LFSR_BITS</name>
              <description>Selects the number of LSB bits to use from the LSFR to provide the clock dithering variation on the base period (spread spectrum mode). 
Caveat make sure that SENSE_DIV &gt; the maximum absolute range (e.g. for 4B  SENSE_DIV &gt; 8), otherwise results are undefined.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>2B</name>
                  <description>Use 2 bits: range = [-2,1]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>3B</name>
                  <description>Use 3 bits: range = [-4,3]</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4B</name>
                  <description>Use 4 bits: range = [-8,7]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>5B</name>
                  <description>Use 5 bits: range = [-16,15] (default)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>32</dim>
          <dimIncrement>4</dimIncrement>
          <name>SW_SEL_CSW[%s]</name>
          <description>Control Switch MUX Switch Control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF0F3F0F</resetMask>
          <fields>
            <field>
              <name>SW_SNCA</name>
              <description>Control MUX Sensor N to CSD Bus A Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCB</name>
              <description>Control MUX Sensor N to CSD Bus B Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCC</name>
              <description>Control MUX Sensor N to CSD Bus C Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCV</name>
              <description>Control MUX Sensor N to vdda_q Switch.

Firmware Rule: Do not program SNCV and SNCG such that they are closed simultaneously.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>clk_extfb</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCG</name>
              <description>Control MUX Sensor N to vssa_q Switch.

Firmware Rule: Do not program SNCV and SNCG such that they are closed simultaneously.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_PH3</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>clk_extfb_bar</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REF_MODE</name>
              <description>Control MUX Sensor N is used as a reference.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Control MUX Sensor N enable.

Firmware Rule:
1) If any of SNCA/SNCB/SNCC can be 1 (statically or dynamically), ENABLED must be 1.
2) If statically closing (using CLOSED setting) any of SNCA/SNCB/SNCC, ENABLE must be set to 1 in a previous bus access to ensure break-before-make. When re-opening from static CLOSED, SNCA/SNCB/SNCC must be opened in a previous bus access before clearing ENABLE to 0. This is not required for dynamic programming options since e.g. PH0 is not active when these registers are programmed.
3) In any use case where SNCA/SNCB/SNCC are required to be set CLOSED via autonomous scanning, rule (2) cannot be observed. Example use case below**. In this scenario to get the desired effect, the options are to either:
a) Dedicate a specific CSW sensor for this purpose, follow rule (2) and do not change the settings autonomously for this sensor.
b) Use unused Cmod switches (e.g. if Cmod1/2 are being used, use the switches for Cmod3/4).

** Any use case where a csdbusa/b/c is not used. For example FW CSX wherein csdbusc not used; then csdbusc is statically connected to vssa_sc (SNCG=CLOSED, ENABLED=1 and SNCC=CLOSED).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>SW_SEL_CSW_FUNC[%s]</name>
          <description>Control Switch MUX Switch Control Global Functions</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF0F3F0F</resetMask>
          <fields>
            <field>
              <name>SW_SNCA</name>
              <description>Control MUX Sensor to CSD Bus A Switch.

Firmware Rule: See corresponding rule in SW_SEL_CSW.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCB</name>
              <description>Control MUX Sensor to CSD Bus B Switch.

Firmware Rule: See corresponding rule in SW_SEL_CSW.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCC</name>
              <description>Control MUX Sensor to CSD Bus C Switch.

Firmware Rule: See corresponding rule in SW_SEL_CSW.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCV</name>
              <description>Control MUX Sensor to vdda_q Switch.

Firmware Rule: Do not program SNCV and SNCG such that they are closed simultaneously.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>clk_extfb</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCG</name>
              <description>Control MUX Sensor to vssa_q Switch.

Firmware Rule: Do not program SNCV and SNCG such that they are closed simultaneously.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_PH3</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>clk_extfb_bar</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REF_MODE</name>
              <description>Control MUX Sensor is used as a reference.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Control MUX Sensor enable.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>3</dim>
          <dimIncrement>32</dimIncrement>
          <name>MODE[%s]</name>
          <description>Sense Mode Configuration Structure</description>
          <addressOffset>0x00000500</addressOffset>
          <register>
            <name>SENSE_DUTY_CTL</name>
            <description>Sense Clock Duty Cycle Control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1100077F</resetMask>
            <fields>
              <field>
                <name>PHASE_GAP_PH0_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of ph0.

PHASE_GAP_PH0_EN = 0 -&gt; No gap.
PHASE_GAP_PH0_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_PH0_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_PH1_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of ph1.

PHASE_GAP_PH1_EN = 0 -&gt; No gap.
PHASE_GAP_PH1_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_PH1_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_PH2_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of ph2.

PHASE_GAP_PH2_EN = 0 -&gt; No gap.
PHASE_GAP_PH2_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_PH2_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_PH3_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of ph3.

PHASE_GAP_PH3_EN = 0 -&gt; No gap.
PHASE_GAP_PH3_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_PH3_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_FS2_PH0_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of Fs2_ph0.

PHASE_GAP_FS2_PH0_EN = 0 -&gt; No gap.
PHASE_GAP_FS2_PH0_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_FS2_PH0_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_FS2_PH1_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of Fs2_ph0.

PHASE_GAP_FS2_PH1_EN = 0 -&gt; No gap.
PHASE_GAP_FS2_PH1_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_FS2_PH1_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PH_GAP_2CYCLE_EN</name>
                <description>If set, applies a two cycle gap on ph0/ph1/ph2/ph3/Fs2_ph0/Fs2_ph1 if the corresponding PHASE_GAP_*_EN is set.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ONE_CYCLE</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TWO_CYCLE</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_PH0X_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of ph0x.

PHASE_GAP_PH0X_EN = 0 -&gt; No gap.
PHASE_GAP_PH0X_EN = 1 &amp;&amp; PHX_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_PH0X_EN = 1 &amp;&amp; PHX_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_PH1X_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of ph1x.

PHASE_GAP_PH1X_EN = 0 -&gt; No gap.
PHASE_GAP_PH1X_EN = 1 &amp;&amp; PHX_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_PH1X_EN = 1 &amp;&amp; PHX_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHX_GAP_2CYCLE_EN</name>
                <description>If set, applies a two cycle gap on ph0X/ph1X if the corresponding PHASE_GAP_*_EN is set.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ONE_CYCLE</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TWO_CYCLE</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_SHIFT_EN</name>
                <description>Enable phase shift logic that generates the Ph0X and Ph1X waveforms. Used for inductive and impedance sensing.

If enabled, PHASE_SHIFT_CYCLES must be  &gt; 0.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_MODE_SEL</name>
                <description>Select 4-phase or 2-phase mode.
'0': Four phase.
'1': Two phase.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>FOUR_PHASE</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TWO_PHASE</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_SEL_CDAC_FL</name>
            <description>Flatspot/Dither CAPDAC Switch Control</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80777377</resetMask>
            <fields>
              <field>
                <name>SW_FLTCA</name>
                <description>Flatspot/Dither CAPDAC top plate to CSD Bus A Switch</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH1_4PHASE</name>
                    <description>chop == 1 ? ph1 : ph3</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH3</name>
                    <description>chop == 1 ? ph3 : ph1</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH0</name>
                    <description>chop == 1 ? ph0 : ph1</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH1_2PHASE</name>
                    <description>chop == 1 ? ph1 : ph0</description>
                    <value>5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SW_FLCB</name>
                <description>Flatspot/Dither CAPDAC to CSD Bus B Switch</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH1_4PHASE</name>
                    <description>chop == 1 ? ph1 : ph3</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH3</name>
                    <description>chop == 1 ? ph3 : ph1</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH0</name>
                    <description>chop == 1 ? ph0 : ph1</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH1_2PHASE</name>
                    <description>chop == 1 ? ph1 : ph0</description>
                    <value>5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SW_FLTV</name>
                <description>Flatspot/Dither CAPDAC top plate to vdda_q Switch.

Firmware Rule: Do not program FLTV and FLTG such that they are closed simultaneously.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>DFT mode</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2</name>
                    <description>DFT mode</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SW_FLTG</name>
                <description>Flatspot/Dither CAPDAC top plate to vssa_q Switch.


Firmware Rule: Do not program FLTV and FLTG such that they are closed simultaneously.</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0_OR_PH2</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>DFT mode</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2</name>
                    <description>DFT mode</description>
                    <value>5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SW_FLBV</name>
                <description>Flatspot/Dither CAPDAC bottom plate to vdda_q Switch.

Firmware Rule: Do not program FLBV and FLBG such that they are closed simultaneously.

Notes: 
1) Equations below describe 'msb' term as raw LFSR output, and take into account overriding as defined by ACTIVATION_MODE.
2) Glitches on FLBV or FLBG during ph0 or ph2 are acceptable (if msb toggles at this time) as the FLTCA and FLCB switches are open during this phase so there is no connection into the comparator or the Cmod caps.</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0X</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1X</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_2_PH</name>
                    <description>[(msb^ph1)^(ph0||ph1)] &amp; [ph0||ph1]</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_2_PH_BAR</name>
                    <description>(![(msb^ph1)^(ph0||ph1)]) &amp; [ph0||ph1]</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_4_PH</name>
                    <description>[(msb^(ph2||ph3))^(ph0||ph2)] &amp; [ph0||ph1||ph2||ph3]</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_4_PH_BAR</name>
                    <description>(![(msb^(ph2||ph3))^(ph0||ph2)]) &amp; [ph0||ph1||ph2||ph3]</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SW_FLBG</name>
                <description>Flatspot/Dither CAPDAC bottom plate to vssa_q Switch.

Firmware Rule: Do not program FLBV and FLBG such that they are closed simultaneously.

Notes:
1) Equations below describe 'msb' term as raw LFSR output, and take into account overriding as defined by ACTIVATION_MODE.
2) Glitches on FLBV or FLBG during ph0 or ph2 are acceptable (if msb toggles at this time) as the FLTCA and FLCB switches are open during this phase so there is no connection into the comparator or the Cmod caps.</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0X</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1X</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_2_PH</name>
                    <description>[(msb^ph1)^(ph0||ph1)] &amp; [ph0||ph1]</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_2_PH_BAR</name>
                    <description>(![(msb^ph1)^(ph0||ph1)]) &amp; [ph0||ph1]</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_4_PH</name>
                    <description>[(msb^(ph2||ph3))^(ph0||ph2)] &amp; [ph0||ph1||ph2||ph3]</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_4_PH_BAR</name>
                    <description>(![(msb^(ph2||ph3))^(ph0||ph2)]) &amp; [ph0||ph1||ph2||ph3]</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACTIVATION_MODE</name>
                <description>Activation event for Dither/Flatspot LFSR.
'0': Clock LFSR on ph0.
'1': Clock LFSR on ph0 or ph2.

Notes:
PH0 activation can be used in both 2 and 4 phase mode (PHASE_MODE_SEL).
PH0_OR_PH2 activation can be used in 4 phase mode only (PHASE_MODE_SEL).

In PH0 activation mode, the LFSR clocks on ph0 only. However hardware autonomously intervenes by processing the LFSR MSB before routing to the HardIP as follows during any given sense period:

PHASE_MODE_SEL = TWO_PHASE:
Invert LFSR MSB on ph1 rising edge.

PHASE_MODE_SEL = FOUR_PHASE:
Invert LFSR MSB on ph2 rising edge.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0_OR_PH2</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_SEL_TOP</name>
            <description>Top Level Switch Control</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xEFFFFF55</resetMask>
            <fields>
              <field>
                <name>CACB</name>
                <description>CSD Bus A to CSD Bus B Switch.

Note that hardware overrides MMIO setting for CACB and sets it CLOSED during the INIT_SHORT state if using GPIO sensors (SW_DSI_CMOD != OPEN || SW_DSI_CSHTANK != OPEN || AYA_EN == CLOSED || AYB_EN == CLOSED).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CACC</name>
                <description>CSD Bus A to CSD Bus C Switch</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CBCC</name>
                <description>CSD Bus B to CSD Bus C Switch</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MBCC</name>
                <description>AMUXBUSB to CSD Bus C Switch</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AYA_CTL</name>
                <description>AMUXBUS A to CSD Bus A Switch. Controls second part of AYA switch (AYA_EN&lt;1&gt; on hardIP).
Alternative to using dsi_cmod in GPIO mode.

Note that hardware overrides MMIO setting for AYA and sets it CLOSED during the INIT_SHORT state if using GPIO sensors (SW_DSI_CMOD != OPEN || SW_DSI_CSHTANK != OPEN || AYA_EN == CLOSED || AYB_EN == CLOSED). This register is wired to the hard IP directly (no MUX required in soft IP).</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>Opens second part of AYA switch.
Enables isolation on AYA if AYA_EN is also OPEN_ISOLATED.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_TWO_PHASE</name>
                    <description>chop == 0 ? ph0 : ph1</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_FOUR_PHASE</name>
                    <description>chop == 0 ? ph1 : ph3</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_MPSC_D</name>
                    <description>chop == 0 ? ph3 : ph1</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_MPRX</name>
                    <description>chop == 0 ? ph1 : ph0</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AYA_EN</name>
                <description>AMUXBUS A to CSD Bus A Switch. Controls the first part of AYA switch (AYA_EN&lt;0&gt; on the hardIP).

This register is wired to the hard IP directly (no MUX required in soft IP).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN_ISOLATED</name>
                    <description>Opens first part of AYA switch.
Enables isolation on AYA if AYA_CTL is also OPEN.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>Closes first part of AYA switch and disables isolation.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AYB_CTL</name>
                <description>AMUXBUS A to CSD Bus B Switch. Controls second part of AYB switch (AYB_EN&lt;1&gt; on hardIP).
Alternative to using dsi_csh_tank in GPIO mode.</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>Opens second part of AYB switch.
Enables isolation on AYB if AYB_EN is also OPEN_ISOLATED.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_TWO_PHASE</name>
                    <description>chop == 0 ? ph1 : ph0</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_FOUR_PHASE</name>
                    <description>chop == 0 ? ph3 : ph1</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_MPSC_D</name>
                    <description>chop == 0 ? ph1 : ph3</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_MPRX</name>
                    <description>chop == 0 ? ph0 : ph1</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AYB_EN</name>
                <description>AMUXBUS A to CSD Bus B Switch. Controls first part of AYB switch (AYB_EN&lt;0&gt; on the hardIP). 

This register is wired to the hard IP directly (no MUX required in soft IP).</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN_ISOLATED</name>
                    <description>Opens first part of AYB switch.
Enables isolation on AYB if AYB_CTL is also OPEN.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>Closes first part of AYB switch and disables isolation.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BYB</name>
                <description>AMUXBUS B to CSD Bus B Switch.

This register is wired to the hard IP directly (no MUX required in soft IP).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN_ISOLATED</name>
                    <description>sel = 00</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OPEN_NON_ISOLATED_CSDBUS</name>
                    <description>sel = 01</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OPEN_NON_ISOLATED_AMUXBUS</name>
                    <description>sel = 10</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>sel = 11</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SOSH</name>
                <description>COAX Shield to Shield Buffer Output Switch</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1_OR_PH3</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SHV</name>
                <description>COAX Shield to vdda_q Switch</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH3</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0X</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1X</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                    <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                    <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                    <value>9</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SHG</name>
                <description>COAX Shield to vssa_q Switch</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH3</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0X</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1X</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                    <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                    <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                    <value>9</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BGRF</name>
                <description>Bandgap Reference to Filter Switch</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RMF</name>
                <description>Ratiometric Reference to Filter Switch</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MBF</name>
                <description>AMUXBUSB to Filter Switch</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_SEL_COMP</name>
            <description>MSC Comparator Switch Control</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80555555</resetMask>
            <fields>
              <field>
                <name>CPCS1</name>
                <description>Comparator Plus Terminal to CMOD1 Sense Switch</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPCS3</name>
                <description>Comparator Plus Terminal to CMOD3 Sense Switch</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPMA</name>
                <description>Comparator Plus Terminal to AMUXBUSA Switch</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPCA</name>
                <description>Comparator Plus Terminal to CSD Bus A Switch</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPCB</name>
                <description>Comparator Plus Terminal to CSD Bus B Switch</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMCB</name>
                <description>Comparator Minus Terminal to CSD Bus B Switch</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPF</name>
                <description>Comparator Plus Terminal to Reference Filter Switch</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMCS2</name>
                <description>Comparator Minus Terminal to CMOD2 Sense Switch</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMCS4</name>
                <description>Comparator Minus Terminal to CMOD4 Sense Switch</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMV</name>
                <description>Comparator Minus Terminal to vdda_q Switch.

Firmware Rule: Do not program CMV and CMG such that they are closed simultaneously.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMG</name>
                <description>Comparator Minus Terminal to vssa_q Switch.

Firmware Rule: Do not program CMV and CMG such that they are closed simultaneously.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMF</name>
                <description>Comparator Minus Terminal to Reference Filter Switch</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HALF_WAVE_EN</name>
                <description>Enables halfwave mode in the comparator where reference is vdda_q.

Firmware Rule: When HALF_WAVE_EN = ENABLED, CHOP_POL must be programmed to 1 in the case where INIT_MODE = REFERENCE_VDDA.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_SEL_SH</name>
            <description>Shielding Switch Control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x7000000</resetValue>
            <resetMask>0x8F055555</resetMask>
            <fields>
              <field>
                <name>C1SHG</name>
                <description>cmod1_2_sh to vssa Switch</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>C1SH</name>
                <description>cmod1_2_sh to sh Switch (Drives cmod1_2_sh with shield signal)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>C3SHG</name>
                <description>cmod3_4_sh to vssa Switch</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>C3SH</name>
                <description>cmod3_4_sh to sh Switch (Drives cmod3_4_sh with shield signal)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SOMB</name>
                <description>Shield OpAmp to AMUXBUSB Switch</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CBSO</name>
                <description>CSD Bus B to Shield OpAmp Switch</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPCS1</name>
                <description>Shield Minus Terminal to CMOD1 Sense Switch</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPCS3</name>
                <description>Shield Minus Terminal to CMOD3 Sense Switch</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FSP</name>
                <description>Reference Filter to Shield Positive Terminal Switch</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCSO</name>
                <description>CSD Bus C to Shield OpAmp Switch</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BUF_SEL</name>
                <description>Selects value of compensation capacitance in shield buffer.</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_EN</name>
                <description>Enable the shield buffer.
'0': Off
'1': On</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>4096</dim>
          <dimIncrement>4</dimIncrement>
          <name>SENSOR_DATA[%s]</name>
          <description>Sensor Configuration Storage</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Local IP storage to support per-sensor configuration for AS-MS mode. Storage requirement in bytes is CONFIG_NR * (number of per sensor registers) * 4. The per sensor registers all have the prefix SNS_*.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_CTL</name>
          <description>Trim Control</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TRIM_IN</name>
              <description>Controls magnitude of comparator offset trim.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_EN</name>
              <description>Enables comparator offset trim.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIM_POLARITY</name>
              <description>Controls polarity of comparator offset trim.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="MSC0">
      <name>MSC1</name>
      <baseAddress>0x402A0000</baseAddress>
    </peripheral>
    <peripheral>
      <name>LPCOMP</name>
      <description>Low Power Comparators</description>
      <baseAddress>0x402B0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ID</name>
          <description>ID &amp; Revision</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1E0E0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>the ID of LPCOMP peripheral is 0xE0E0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>the version number is 0x0001</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CONFIG</name>
          <description>LPCOMP Configuration Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x33FFFF</resetMask>
          <fields>
            <field>
              <name>MODE1</name>
              <description>Operating mode for the comparator</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLOW</name>
                  <description>Slow operating mode (uses less power, &lt;50uA)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAST</name>
                  <description>Fast operating mode (uses more power, &lt;400uA)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra low power operting mode (uses ~2-4uA)</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST1</name>
              <description>Add 10mV hysteresis to the comparator
- 0: Enable Hysteresis
- 1: Disable Hysteresis</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER1</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE1</name>
              <description>Sets which edge will trigger an IRQ</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT1</name>
              <description>Current output value of the comparator.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE1</name>
              <description>Enable comparator #1</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE2</name>
              <description>Operating mode for the comparator</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLOW</name>
                  <description>Slow operating mode (uses less power, &lt;50uA)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAST</name>
                  <description>Fast operating mode (uses more power, &lt;400uA)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra low power operting mode (uses ~2-4uA)</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST2</name>
              <description>Add 10mV hysteresis to the comparator
- 0: Enable Hysteresis
- 1: Disable Hysteresis</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER2</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE2</name>
              <description>Sets which edge will trigger an IRQ</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT2</name>
              <description>Current output value of the comparator.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE2</name>
              <description>Enable comparator #2</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_BYPASS1</name>
              <description>Opamp1 bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async)
Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL1</name>
              <description>Opamp1 comparator DSI (trigger) out level : 0=pulse, 1=level</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_BYPASS2</name>
              <description>Opamp2 bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async)
Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL2</name>
              <description>Opamp2 comparator DSI (trigger) out level : 0=pulse, 1=level</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>LPCOMP Interrupt request register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP2</name>
              <description>Comparator 2 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>LPCOMP Interrupt set register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP2</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>LPCOMP Interrupt request mask</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP2_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>LPCOMP Interrupt request masked</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP2_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM1</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP1_TRIMA</name>
              <description>Trim A for Comparator #1</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM2</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP1_TRIMB</name>
              <description>Trim B for Comparator #1</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM3</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP2_TRIMA</name>
              <description>Trim A for Comparator #2</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM4</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP2_TRIMB</name>
              <description>Trim B for Comparator #2</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EXCO</name>
      <description>ECO+PLL as SRSSLT clk_eco external source</description>
      <baseAddress>0x402F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock Select Register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>CLK_SELECT</name>
              <description>When PLL_CONFIG.ENABLE=0, then clk_eco=clk_osc.
When PLL_CONFIG.ENABLE=1 then BYPASS_SEL and PLL_STATUS.LOCKED also affect this control point.
CLK_SELECT:
0:  PLL_CONFIG.BYPASS=0x, PLL_STATUS.LOCKED = 0:  clk_eco=clk_osc
     PLL_CONFIG.BYPASS=0x, PLL_STATUS.LOCKED = 1:  clk_eco=clk_pll
     PLL_CONFIG.BYPASS=10, PLL_STATUS.LOCKED = x:  clk_eco=clk_osc
     PLL_CONFIG.BYPASS=11, PLL_STATUS.LOCKED = x:  clk_eco=clk_pll
1:  PLL_CONFIG.BYPASS=xx, PLL_STATUS.LOCKED = x:  clk_eco=clk_pl</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REF_SEL</name>
              <description>Select source for PLL reference
0: from ECO
1: from external reference
2: from clk_imo
3: from clk_imo</description>
              <bitRange>[2:1]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SEL_ECO</name>
                  <description>From ECO</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_EXT_REF</name>
                  <description>From external reference</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SEL_CLK_IMO</name>
                  <description>From CLK_IMO</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>ECO_CONFIG</name>
          <description>ECO Configuration Register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x80000003</resetMask>
          <fields>
            <field>
              <name>CLK_EN</name>
              <description>Clock Enable.  When enabling the clock, first write ENABLE=1, wait at least 10us, and then write CLK_EN=1.  When disabling, clearing both CLK_EN=0 and ENABLE=0 can be done in the same AHB write</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AGC_EN</name>
              <description>Automatic Gain Control (AGC) enable.  When set, the oscillation amplitude is controlled to the level selected by ECO_TRIM0.ATRIM.  When low, the amplitude is not explicitly controlled and will grow until it saturates to the supply rail (1.8V nom).  WARNING: use care when disabling AGC because driving a crystal beyond its rated limit can permanently damage the crystal.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ECO oscillator.  Refer to CLK_EN for sequencing.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECO_STATUS</name>
          <description>ECO Status Register</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WATCHDOG_ERROR</name>
              <description>This bit is set to 1 if the oscillator is stuck.  The ECO clock is gated off during a watchdog error condition. Due to internal synchonization, the clock is stopped two cycles after an error condition is observed and ungated two cycles after the error condition is resolved.

Note: This bit setting reflected in INT.WD_ERR if Interrupts are enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_CONFIG</name>
          <description>PLL Configuration Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20000</resetValue>
          <resetMask>0xC037FFFF</resetMask>
          <fields>
            <field>
              <name>FEEDBACK_DIV</name>
              <description>Control bits for feedback divider: Valid divide is 8-255.  Do not change while PLL output is selected.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFERENCE_DIV</name>
              <description>Control bits for reference divider: Divide by 2=0001, ..., divide by 64=111111.  Do not change while PLL output is selected.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OUTPUT_DIV</name>
              <description>Control bits for Output divider.  Do not change while PLL output is selected.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PASS</name>
                  <description>Pass Through</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV2</name>
                  <description>Divide by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV4</name>
                  <description>Divide by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV8</name>
                  <description>Divide by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ICP_SEL</name>
              <description>Programmable charge pump current between 0uA and 7uA.  Do not change while the PLL output is selected.  For functional operation, the value must be set according to the PLL output frequency Fout (measured before the output divider):
0: 0uA (Hi-Z) Engineering use only
1: 1uA. Engineering use only
2: 2uA. Use when Fout &lt;= 67MHz
3: 3uA. Use when Fout &gt; 67MHz
4-7: 4uA-7uA.  Engineering use only</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYPASS_SEL</name>
              <description>Selects the source of the system PLL0 clock.  See also CLK_SELECT.CLK_SELECT for effect on clk_eco selection.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>AUTO</name>
                  <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AUTO1</name>
                  <description>Same as AUTO</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_REF</name>
                  <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PLL_OUT</name>
                  <description>Select PLL output.  Ignores lock indicator.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ISOLATE_N</name>
              <description>Isolation control of PLL outputs.  This also internally resets the PLL.  De-assert &gt;= 5us after ENABLE=1.  Assertion can happen in same write as ENABLE=0.  Do not change while PLL output is selected.
0: Isolate outputs; Precharge PLL control voltage if PLL0_TEST.FAST_LOCK_EN is set to 1.
1: Do not isolate outputs</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Master enable for PLL power gate.  Refer to ISOLATE_N field for required sequencing.
0: Block is powered off, also forces clk_eco = clk_osc - See CLK_SELECT.CLK_SELECT description.
1: Block is powered on</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_STATUS</name>
          <description>PLL Status Register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>LOCKED</name>
              <description>PLL Lock Indicator - See CLK_SELECT.CLK_SELECT description for interaction with clk_eco selection.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_TEST</name>
          <description>PLL Test Register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>TEST_MODE</name>
              <description>Test Mode</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal Operation</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_VC_LKG</name>
                  <description>Vcontrol Leakage Test Mode
Measure frequency drift over time to indirectly measure leakage on Vcontrol</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_CP_DN</name>
                  <description>Charge Pump Down Current Test Mode
With ICPSEL&gt;0, directly measure charge pump up current on Vcontrol
With ICPSEL=0, directly measure leakage on Vcontrol
With ICPSEL=0, FAST_LOCK_EN=0 and ISOLATE_N=0, directly measure discharge current on Vcontrol
With ICPSEL=0, FAST_LOCK_EN=1 and ISOLATE_N=0, directly measure precharge current on Vcontrol</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_CP_UP</name>
                  <description>Charge Pump Up Current Test Mode
With ICPSEL&gt;0, directly measure charge pump up current on Vcontrol
With ICPSEL=0, directly measure leakage on Vcontrol
With ICPSEL=0, FAST_LOCK_EN=0 and ISOLATE_N=0, directly measure discharge current on Vcontrol
With ICPSEL=0, FAST_LOCK_EN=1 and ISOLATE_N=0, directly measure precharge current on Vcontrol</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>USER_EXT_FL</name>
                  <description>User Mode with Extended Fast Lock Precharge</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_CTR_PQ</name>
                  <description>Reference and Feedback Counter Test Mode</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_LD_DLY</name>
                  <description>Lock Detector Delay Line Test Mode</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_CTR_ALT</name>
                  <description>Lock Detector Wait and Extended Fast Lock Counter Test Mode
With ICPSEL=0 and Reference Clock stopped directly measure precharge current on Vcontrol
With ICPSEL=0 and Reference Clock running directly measure leakage on Vcontrol</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FAST_LOCK_EN</name>
              <description>Fast Lock Enable - Speeds up the lock time when set to 1.  When ISOLATE_N is high, the PLL control voltage will be precharged to reduce time spent acquiring frequency lock.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNLOCK_OCCURRED</name>
              <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware. This is a diagnostic bit used for char and validation.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXCO_PGM_CLK</name>
          <description>EXCO Program Clock</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000001E</resetMask>
          <fields>
            <field>
              <name>CLK_ECO</name>
              <description>Bit bang clk_eco</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_PLL0_IN</name>
              <description>Observation point for clk_pll0_in, not retained.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_PLL0_OUT</name>
              <description>Bit bang clk_pll0_out</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CLK_PLL0</name>
              <description>Bit bang en_clk_pll0</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Enable bit-banging test capability in this register.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REF_CTL</name>
          <description>Clock Supervision Reference Contol</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000</resetValue>
          <resetMask>0x8007FFFF</resetMask>
          <fields>
            <field>
              <name>STARTUP</name>
              <description>Startup delay time -1 (in reference clock cycles), after enable or DeepSleep wakeup, from reference clock start to monitored clock start.
At a minimum (both clocks running): STARTUP &gt;= (PERIOD +3) * FREQ_RATIO - UPPER, with FREQ_RATIO = (Reference frequency / Monitored frequency)
On top of that the actual clock startup delay and the margin for accuracy of both clocks must be added.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSV_INT_EN</name>
              <description>Enable CSV setting INT.CSV_CLK_SW if a clock switch occurs to IMO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSV_TRIG_EN</name>
              <description>Enable CSV to cause trigger if a clock switch occurs to IMO.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSV_CLK_SW_EN</name>
              <description>Enable CSV to cause Clock Switch to IMO when set.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSV_EN</name>
              <description>Enables clock supervision, both frequency and loss.    
CSV in Active domain: Clock supervision is reset during DeepSleep and Hibernate modes.  When enabled it begins operating automatically after a DeepSleep wakeup, but it must be reconfigured after Hibernate wakeup.  

When CSV error detection occurs - the CSV_CLK_SW, CSV_INT_EN and CVS_TRIG_EN control where the error is reported.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REF_LIMIT</name>
          <description>Clock Supervision Reference Limits</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LOWER</name>
              <description>Cycle time lower limit.  Set the lower limit -1, in reference clock cycles, before the next monitored clock event is allowed to happen.  If a monitored clock event happens before this limit is reached a CSV error is detected.
LOWER must be at least 1 less than UPPER. In case the clocks are asynchronous LOWER must be at least 3 less than UPPER.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UPPER</name>
              <description>Cycle time upper limit.  Set the upper limit -1, in reference clock cycles, before (or same time) the next monitored clock event must happen.  If a monitored clock event does not happen before this limit is reached, or does not happen at all (clock loss), a CSV error is detected.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MON_CTL</name>
          <description>Clock Supervision Monitor Control</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>PERIOD</name>
              <description>Period time.  Set the Period -1, in monitored clock cycles, before the next monitored clock event happens. 
PERIOD &lt;=  (UPPER+1) / FREQ_RATIO -1, with FREQ_RATIO = (Reference frequency / Monitored frequency)
In case the clocks are asynchronous: PERIOD &lt;=  UPPER / FREQ_RATIO -1
Additionaly margin must be added for accuracy of both clocks.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt Request Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>PLL_LOCK</name>
              <description>HW will set this bit when PLL loses lock (PLL 'locked' output goes low).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WD_ERR</name>
              <description>EXCO Watch Dog Error detected - Oscillator stopped oscillating</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSV_CLK_SW</name>
              <description>Clock Supervisor Switched Clock Source to IMO</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt Set Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>PLL_LOCK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WD_ERR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSV_CLK_SW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt Mask Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>PLL_LOCK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WD_ERR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CSV_CLK_SW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrrupt Masked Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>PLL_LOCK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WD_ERR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CSV_CLK_SW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RSTDLY_CTL</name>
          <description>Programmable Delay Counter  Control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>LOAD</name>
              <description>Programmable Delay Counter Load - Reloads the DLYCOUNT into the COUNT_VAL register
0: No Action
1: Generate a 1 clock pulse that loads the Initial value into the COUNT_VAL register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN</name>
              <description>Programmable Delay Counter Enable
'0': Disable
'1': Enable</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RSTDLY</name>
          <description>Programmable Delay Counter Initial  Amount</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x100</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DLYCOUNT</name>
              <description>Delay Count Value</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RSTDLY_COUNT_VAL</name>
          <description>Programmable Delay Counter Value</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x100</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT_VAL</name>
              <description>Current Programmable Delay Counter value</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECO_TRIM0</name>
          <description>ECO Trim0 Register</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>WDTRIM</name>
              <description>Watch Dog Trim -  Delta voltage below stead state level
0x0 - 0.05V
0x1 - 0.1V
0x2 - 0.15V
0x3 - 0.2V</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ATRIM</name>
              <description>Amplitude trim to set the crystal drive level when ECO_CONFIG.AGC_EN=1.  WARNING: use care when setting this field because driving a crystal beyond its rated limit can permanently damage the crystal.
0x0 - 0.3Vpp
0x1 - 0.4Vpp
0x2 - 0.5Vpp
0x3 - 0.6Vpp
0x4 - 0.7Vpp
0x5 - 0.8Vpp
0x6 - 0.9Vpp
0x7 - 1.0Vpp</description>
              <bitRange>[4:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECO_TRIM1</name>
          <description>ECO Trim1 Register</description>
          <addressOffset>0xFF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x15</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>FTRIM</name>
              <description>Filter Trim - 3rd harmonic oscillation</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTRIM</name>
              <description>Feedback resistor Trim</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>GTRIM</name>
              <description>Gain Trim - Startup time</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECO_TRIM2</name>
          <description>ECO Trim2 Register</description>
          <addressOffset>0xFF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x20</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>ITRIM</name>
              <description>Current Trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PLL_TRIM</name>
          <description>PLL Trim Register</description>
          <addressOffset>0xFF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x12</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>VCO_GAIN</name>
              <description>Programmable VCO frequency characteristic at high freq - set to &lt;10&gt;</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCK_WINDOW</name>
              <description>Selects the allowed phase error before declaring the PLL Unlocked</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DELAY_25NS</name>
                  <description>Delay 25 ns</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DELAY_50NS</name>
                  <description>Delay 50 ns</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DELAY_75NS</name>
                  <description>Delay 75 ns</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DELAY_100NS</name>
                  <description>Delay 100 ns</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LOCK_DELAY</name>
              <description>Selects the number of PLL phase frequency detector cycles that the phase error must be in range before declaring lock. (PFD clock cycle = Clock Reference Period/REFERENCE_DIV)</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PFD_CLK_16</name>
                  <description>16 PFD clock cycles</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PFD_CLK_32</name>
                  <description>32 PFD clock cycles</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PFD_CLK_48</name>
                  <description>48 PFD clock cycles</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PFD_CLK_64</name>
                  <description>64 PFD clock cycles</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CTBM0</name>
      <description>Continuous Time Block Mini</description>
      <headerStructName>CTBM</headerStructName>
      <baseAddress>0x40300000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTB_CTRL</name>
          <description>global CTB and power control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>- 0: CTB IP disabled off during DeepSleep power mode
- 1: CTB IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>- 0: CTB IP disabled (put analog in power down, open all switches)
- 1: CTB IP enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_RES0_CTRL</name>
          <description>Opamp0 and resistor0 control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xBF7</resetMask>
          <fields>
            <field>
              <name>OA0_PWR_MODE</name>
              <description>Opamp0 power level</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>Low compensation setting (smallest cap, highest GBW). For gain=10: PM=60deg @ Cload=50pF for the output to pin driver and 10pF for the internal only driver</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MEDIUM</name>
                  <description>Medium compensation setting. For gain=4: PM=60deg @ Cload=50pF for the output to pin driver and 10pF for the internal only driver.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>Highest compensation (largest cap, lowest GBW). For gain=1: PM=60deg @ Cload=50pF for the output to pin driver and 10pF for the internal only driver</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA0_DRIVE_STR_SEL</name>
              <description>Opamp0 output strenght select 0=1x, 1=10x</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_COMP_EN</name>
              <description>Opamp0 comparator enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_HYST_EN</name>
              <description>Opamp0 hysteresis enable (10mV)</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_BYPASS_DSI_SYNC</name>
              <description>Opamp0 bypass comparator output synchronization for DSI (trigger) output: 0=synchronize (level or pulse), 1=bypass (output async)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_DSI_LEVEL</name>
              <description>Opamp0 comparator DSI (trigger) out level : 
0=pulse, each time an edge is detected (see OA0_COMPINT) a pulse is sent out on DSI
1=level,  DSI output is a synchronized version of the comparator output</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_COMPINT</name>
              <description>Opamp0 comparator edge detect for interrupt and pulse mode of DSI (trigger)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA0_PUMP_EN</name>
              <description>Opamp0 pump enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_RES1_CTRL</name>
          <description>Opamp1 and resistor1 control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xBF7</resetMask>
          <fields>
            <field>
              <name>OA1_PWR_MODE</name>
              <description>Opamp1 power level: see description of OA0_PWR_MODE</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_DRIVE_STR_SEL</name>
              <description>Opamp1 output strenght select 0=1x, 1=10x</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_COMP_EN</name>
              <description>Opamp1 comparator enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_HYST_EN</name>
              <description>Opamp1 hysteresis enable (10mV)</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_BYPASS_DSI_SYNC</name>
              <description>Opamp1 bypass comparator output synchronization for DSI output: 0=synchronize, 1=bypass</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_DSI_LEVEL</name>
              <description>Opamp1 comparator DSI (trigger) out level : 
0=pulse, each time an edge is detected (see OA1_COMPINT) a pulse is sent out on DSI
1=level,  DSI output is a synchronized version of the comparator output</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_COMPINT</name>
              <description>Opamp1 comparator edge detect for interrupt and pulse mode of DSI (trigger)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA1_PUMP_EN</name>
              <description>Opamp1 pump enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COMP_STAT</name>
          <description>Comparator status</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10001</resetMask>
          <fields>
            <field>
              <name>OA0_COMP</name>
              <description>Opamp0 current comparator status</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OA1_COMP</name>
              <description>Opamp1 current comparator status</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Comparator 0 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1</name>
              <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 1 triggers. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt request set register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt request mask</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt request masked</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_CTRL</name>
          <description>Was 'Analog DfT controls', now used as Risk Mitigation bits (RMP)</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000007</resetMask>
          <fields>
            <field>
              <name>DFT_MODE</name>
              <description>this bit is combined with bit 31, to form RMP[3:0], it must always be written with '3' for correct operation.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_EN</name>
              <description>this bit is combined with the 3 bits 2:0, to form RMP[3:0]</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_SW</name>
          <description>Opamp0 switch control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x24410D</resetMask>
          <fields>
            <field>
              <name>OA0P_A00</name>
              <description>Opamp0 positive terminal amuxbusa</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A20</name>
              <description>Opamp0 positive terminal P0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A30</name>
              <description>Opamp0 positive terminal ctbbus0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A11</name>
              <description>Opamp0 negative terminal P1</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A81</name>
              <description>Opamp0 negative terminal Opamp0 output</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D51</name>
              <description>Opamp0 output sarbus0 (ctbbus2 in CTB)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D81</name>
              <description>Opamp0 output switch to short 1x with 10x drive</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_SW_CLEAR</name>
          <description>Opamp0 switch control clear</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x24410D</resetMask>
          <fields>
            <field>
              <name>OA0P_A00</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A20</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A30</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A11</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A81</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D51</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D81</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_SW</name>
          <description>Opamp1 switch control</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x2C4113</resetMask>
          <fields>
            <field>
              <name>OA1P_A03</name>
              <description>Opamp1 positive terminal amuxbusb</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A13</name>
              <description>Opamp1 positive terminal P5</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A43</name>
              <description>Opamp1 positive terminal ctbbus1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A22</name>
              <description>Opamp1 negative terminal P4</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A82</name>
              <description>Opamp1 negative terminal Opamp1 output</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D52</name>
              <description>Opamp1 output sarbus0 (ctbbus2 in CTB)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D62</name>
              <description>Opamp1 output sarbus1 (ctbbus3 in CTB)</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D82</name>
              <description>Opamp1 output switch to short 1x with 10x drive</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_SW_CLEAR</name>
          <description>Opamp1 switch control clear</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x2C4113</resetMask>
          <fields>
            <field>
              <name>OA1P_A03</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A13</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A43</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A22</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A82</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D52</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D62</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D82</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTB_SW_HW_CTRL</name>
          <description>CTB bus switch control</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC</resetMask>
          <fields>
            <field>
              <name>P2_HW_CTRL</name>
              <description>for P22, D51 (dsi_out[2])</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>P3_HW_CTRL</name>
              <description>for P33, D52, D62 (dsi_out[3])</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTB_SW_STATUS</name>
          <description>CTB bus switch control status</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x70000000</resetMask>
          <fields>
            <field>
              <name>OA0O_D51_STAT</name>
              <description>see OA0O_D51 bit in OA0_SW</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OA1O_D52_STAT</name>
              <description>see OA1O_D52 bit in OA1_SW</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OA1O_D62_STAT</name>
              <description>see OA1O_D62 bit in OA1_SW</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_OFFSET_TRIM</name>
          <description>Opamp0 trim control</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA0_OFFSET_TRIM</name>
              <description>Opamp0 offset trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_SLOPE_OFFSET_TRIM</name>
          <description>Opamp0 trim control</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA0_SLOPE_OFFSET_TRIM</name>
              <description>Opamp0 slope offset drift trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_COMP_TRIM</name>
          <description>Opamp0 trim control</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>OA0_COMP_TRIM</name>
              <description>Opamp 0 Compensation Capacitor Trim</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_OFFSET_TRIM</name>
          <description>Opamp1 trim control</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA1_OFFSET_TRIM</name>
              <description>Opamp1 offset trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_SLOPE_OFFSET_TRIM</name>
          <description>Opamp1 trim control</description>
          <addressOffset>0xF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA1_SLOPE_OFFSET_TRIM</name>
              <description>Opamp1 slope offset drift trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_COMP_TRIM</name>
          <description>Opamp1 trim control</description>
          <addressOffset>0xF14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>OA1_COMP_TRIM</name>
              <description>Opamp 1 Compensation Capacitor Trim</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SAR0</name>
      <description>SAR ADC with Sequencer</description>
      <headerStructName>SAR</headerStructName>
      <baseAddress>0x403A0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Analog control register.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10000000</resetValue>
          <resetMask>0xFB1FEEF0</resetMask>
          <fields>
            <field>
              <name>VREF_SEL</name>
              <description>SARADC internal VREF selection.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VREF0</name>
                  <description>VREF0 from PRB (VREF buffer on)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF1</name>
                  <description>VREF1 from PRB (VREF buffer on)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF2</name>
                  <description>VREF2 from PRB (VREF buffer on)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_AROUTE</name>
                  <description>VREF from AROUTE (VREF buffer on)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VBGR</name>
                  <description>1.024V from BandGap (VREF buffer on)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_EXT</name>
                  <description>External precision Vref direct from a pin (low impedance path).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA_DIV_2</name>
                  <description>Vdda/2  (VREF buffer on)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA</name>
                  <description>Vdda.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VREF_BYP_CAP_EN</name>
              <description>VREF bypass cap enable for when VREF buffer is on</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_SEL</name>
              <description>SARADC internal NEG selection for Single ended conversion</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VSSA_KELVIN</name>
                  <description>NEG input of SARADC is connected to 'vssa_kelvin', gives more precision around zero. Note this opens both SARADC internal switches, therefore use this value to insert a break-before-make cycle on those switches when SWITCH_DISABLE is high.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ART_VSSA</name>
                  <description>NEG input of SARADC is connected to VSSA in AROUTE close to the SARADC</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P1</name>
                  <description>NEG input of SARADC is connected to P1 pin of SARMUX</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P3</name>
                  <description>NEG input of SARADC is connected to P3 pin of SARMUX</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P5</name>
                  <description>NEG input of SARADC is connected to P5 pin of SARMUX</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P7</name>
                  <description>NEG input of SARADC is connected to P7 pin of SARMUX</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACORE</name>
                  <description>NEG input of SARADC is connected to an ACORE in AROUTE</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF</name>
                  <description>NEG input of SARADC is shorted with VREF input of SARADC.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAR_HW_CTRL_NEGVREF</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for VREF to NEG switch.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_CTRL_VREF</name>
              <description>VREF buffer low power mode.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL_PWR</name>
                  <description>normal power (default), bypass cap, max clk_sar is 18MHz.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALF_PWR</name>
                  <description>deprecated</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>THIRD_PWR</name>
                  <description>Invalid for PSoC4A, otherwise 2X power, no bypass cap, max clk_sar is 1.8MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>QUARTER_PWR</name>
                  <description>deprecated</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPARE</name>
              <description>Spare controls, not yet designated, for late changes done with an ECO</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOOSTPUMP_EN</name>
              <description>SARADC internal pump: 0=disabled: pump output is VDDA, 1=enabled: pump output is boosted.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ICONT_LV</name>
              <description>SARADC low power mode.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL_PWR</name>
                  <description>normal power (default), max clk_sar is 18MHz.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALF_PWR</name>
                  <description>1/2 power mode, max clk_sar is 9MHz.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MORE_PWR</name>
                  <description>1.333 power mode, max clk_sar is 18MHz.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>QUARTER_PWR</name>
                  <description>1/4 power mode, max clk_sar is 4.5MHz.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>- 0: SARMUX IP disabled off during DeepSleep power mode
- 1: SARMUX IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SYNC_CONFIG</name>
              <description>- 0: bypass clock domain synchronisation of the DSI config signals.
- 1: synchronize the DSI config signals to peripheral clock domain.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_MODE</name>
              <description>SAR sequencer takes configuration from DSI signals (note this also has the same effect as SWITCH_DISABLE==1)
- 0: Normal mode, SAR sequencer operates according to CHAN_EN enables and CHAN_CONFIG channel configurations
- 1: CHAN_EN, INJ_START_EN and channel configurations in CHAN_CONFIG and INJ_CHAN_CONFIG are ignored</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_DISABLE</name>
              <description>Disable SAR sequencer from enabling routing switches (note DSI and firmware can always close switches independent of this control)
- 0: Normal mode, SAR sequencer changes switches according to pin address in channel configurations
- 1: Switches disabled, SAR sequencer does not enable any switches, it is the responsibility of the firmware or UDBs (through DSI) to set the switches to route the signal to be converted through the SARMUX</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Before enabling always make sure the SAR is idle (STATUS.BUSY==0)
- 0: SAR IP disabled (put analog in power down and stop clocks), also can clear FW_TRIGGER and INJ_START_EN (if not tailgaiting) on write.
- 1: SAR IP enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_CTRL</name>
          <description>Sample control register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80008</resetValue>
          <resetMask>0x800F00FF</resetMask>
          <fields>
            <field>
              <name>SUB_RESOLUTION</name>
              <description>Conversion resolution for channels that have sub-resolution enabled (RESOLUTION=1) (otherwise resolution is 12-bit).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>8B</name>
                  <description>8-bit.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>10B</name>
                  <description>10-bit.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEFT_ALIGN</name>
              <description>Left align data in data[15:0], default data is right aligned in data[11:0], with sign extension to 16 bits if the channel is differential.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SINGLE_ENDED_SIGNED</name>
              <description>Output data from a single ended conversion as a signed value</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>Default: result data is unsigned (zero extended if needed)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>result data is signed (sign extended if needed)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_SIGNED</name>
              <description>Output data from a differential conversion as a signed value</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>result data is unsigned (zero extended if needed)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>Default: result data is signed (sign extended if needed)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_CNT</name>
              <description>Averaging Count for channels that have over sampling enabled (AVG_EN). A channel will be sampled back to back (1&lt;&lt;(AVG_CNT+1)) = [2..256] times before the result is stored and the next enabled channel is sampled (1st order accumulate and dump filter).
If shifting is not enabled (AVG_SHIFT=0) then the result is forced to shift right so that is fits in 16 bits, so right shift is done by max(0,AVG_CNT-3).</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_SHIFT</name>
              <description>Averaging shifting: after averaging the result is shifted right to fit in the sample resolution. For averaging the sample resolution is the highest resolution allowed by wounding.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONTINUOUS</name>
              <description>- 0: Wait for next FW_TRIGGER (one shot) or hardware (DSI) trigger (e.g. from TPWM for periodic triggering) before scanning enabled channels.
- 1: Continuously scan enabled channels, ignore triggers.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_EN</name>
              <description>- 0: firmware trigger only: disable hardware (DSI) trigger.
- 1: enable hardware (DSI) trigger (e.g. from TCPWM, GPIO or UDB).</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_LEVEL</name>
              <description>- 0: DSI trigger signal is a pulse input, a positive edge detected on the DSI trigger signal triggers a new scan.
- 1: DSI trigger signal is a level input, as long as the DSI trigger signal remains high the SAR will do continuous scans.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SYNC_TRIGGER</name>
              <description>- 0: bypass clock domain synchronisation of the DSI trigger signal.
- 1: synchronize the DSI trigger signal to the SAR clock domain, if needed an edge detect is done in the peripheral clock domain.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EOS_DSI_OUT_EN</name>
              <description>Enable to output EOS_INTR to DSI. When enabled each time EOS_INTR is set by the hardware also a pulse is send on the dsi_eos signal.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_TIME01</name>
          <description>Sample time specification ST0 and ST1</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40004</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME0</name>
              <description>Sample time0 (aperture) in ADC clock cycles. Note that actual sample time is half a clock less than specified here. The minimum sample time is 194ns, which is 3.5 cycles (4 in this field) with an 18MHz clock. Minimum legal value in this register is 2.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME1</name>
              <description>Sample time1</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_TIME23</name>
          <description>Sample time specification ST2 and ST3</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40004</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME2</name>
              <description>Sample time2</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME3</name>
              <description>Sample time3</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_THRES</name>
          <description>Global range detect threshold register.</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_LOW</name>
              <description>Low threshold for range detect.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RANGE_HIGH</name>
              <description>High threshold for range detect.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_COND</name>
          <description>Global range detect mode register.</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>RANGE_COND</name>
              <description>Range condition select.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BELOW</name>
                  <description>result &lt; RANGE_LOW</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INSIDE</name>
                  <description>RANGE_LOW &lt;= result &lt; RANGE_HIGH</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ABOVE</name>
                  <description>RANGE_HIGH &lt;= result</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUTSIDE</name>
                  <description>result &lt; RANGE_LOW || RANGE_HIGH &lt;= result</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_EN</name>
          <description>Enable bits for the channels</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_EN</name>
              <description>Channel enable. 
- 0: the corresponding channel is disabled.
- 1: the corresponding channel is enabled, it will be included in the next scan.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>START_CTRL</name>
          <description>Start control register (firmware trigger).</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>FW_TRIGGER</name>
              <description>When firmware writes a 1 here it will trigger the next scan of enabled channels, hardware clears this bit when the scan started with this trigger is completed. If scanning continuously the trigger is ignored and hardware clears this bit after the next scan is done. This bit is also cleared when the SAR is disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_CTRL</name>
          <description>DFT control register.</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0xBF7F0003</resetMask>
          <fields>
            <field>
              <name>DLY_INC</name>
              <description>DFT control: Control for delay circuits on sampling phase, =1 doubes the non-overlap delay</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIZ</name>
              <description>DFT control for getting higher input impedance, must be 1 (0 is deprecated)</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_INC</name>
              <description>DFT control for preamp inputs</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_OUTC</name>
              <description>DFT control for preamp outputs</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_CSEL_DFT</name>
              <description>Usage 1: DFT bits for DAC array
Usage 2: For [0]=1 (when dcen=0): Delay timing for latch enable increased by 20 percent
[1]=1: comparator preamp power level increased by 25 percent</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CSEL_DFT</name>
              <description>Mux select signal for DAC control</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCEN</name>
              <description>Delay Control Enable for latch.
- 0: doubles the latch enable time.
- 1: normal latch enable time (default).</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADFT_OVERRIDE</name>
              <description>During deepsleep/ hibernate mode keep SARMUX active, i.e. do not open all switches (disconnect), to be used for ADFT</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_CONFIG[%s]</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80003777</resetMask>
          <fields>
            <field>
              <name>PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel. If differential is enabled then PIN_ADDR[0] is ignored and considered to be 0, i.e. PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT2</name>
                  <description>AROUTE virtual port2 (VPORT2)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT1</name>
                  <description>AROUTE virtual port1 (VPORT1)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.
- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (PIN_ADDR[0] is ignored).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.
- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_WORK[%s]</name>
          <description>Channel working data register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_VALID_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_VALID register</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>16</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_RESULT[%s]</name>
          <description>Channel result data register</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0000000</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_VALID_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_VALID register</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK_VALID</name>
          <description>Channel working data register valid bits</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_WORK_VALID</name>
              <description>If set the corresponding WORK data is valid, i.e. was already sampled during the current scan.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT_VALID</name>
          <description>Channel result data register valid bits</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_RESULT_VALID</name>
              <description>If set the corresponding RESULT data is valid, i.e. was sampled during the last scan.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Current status of internal SAR registers (mostly for debug)</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000001F</resetMask>
          <fields>
            <field>
              <name>CUR_CHAN</name>
              <description>current channel being sampled (channel 16 indicates the injection channel), only valid if BUSY.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_VREF_NEG</name>
              <description>the current switch status, including DSI and sequencer controls, of the switch in the SARADC that shorts NEG with VREF input (see NEG_SEL).</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>If high then the SAR is busy with a conversion. This bit is always high when CONTINUOUS is set. Firmware should wait for this bit to be low before putting the SAR in power down.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AVG_STAT</name>
          <description>Current averaging status (for debug)</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF0FFFFF</resetMask>
          <fields>
            <field>
              <name>CUR_AVG_ACCU</name>
              <description>the current value of the averaging accumulator</description>
              <bitRange>[19:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CUR_AVG_CNT</name>
              <description>the current value of the averaging counter. Note that the value shown is updated after the sampling time and therefore runs ahead of the accumulator update.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register.</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_INTR</name>
              <description>End Of Scan Interrupt: hardware sets this interrupt after completing a scan of all the enabled channels. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_INTR</name>
              <description>Overflow Interrupt: hardware sets this interrupt when it sets a new EOS_INTR while that bit was not yet cleared by the firmware. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_INTR</name>
              <description>Firmware Collision Interrupt: hardware sets this interrupt when FW_TRIGGER is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the FW_TRIGGER has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_INTR</name>
              <description>DSI Collision Interrupt: hardware sets this interrupt when the DSI trigger signal is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the DSI trigger has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_INTR</name>
              <description>Injection End of Conversion Interrupt: hardware sets this interrupt after completing the conversion for the injection channel (irrespective of if tailgating was used). Write with '1' to clear bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR</name>
              <description>Injection Saturation Interrupt: hardware sets this interrupt if an injection conversion result (before averaging) is either 0x000 or 0xFFF (for 12-bit resolution), this is an indication that the ADC likely saturated. Write with '1' to clear bit.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR</name>
              <description>Injection Range detect Interrupt: hardware sets this interrupt if the injection conversion result (after averaging) met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR</name>
              <description>Injection Collision Interrupt: hardware sets this interrupt when the injection trigger signal is asserted (INJ_START_EN==1 &amp;&amp; INJ_TAILGATING==0) while the SAR is BUSY. Raising this interrupt is delayed to when the sampling of the injection channel has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the injection channel was sampled later than was intended. Write with '1' to clear bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set request register</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register.</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked request register</description>
          <addressOffset>0x21C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FW_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR</name>
          <description>Saturate interrupt request register.</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_INTR</name>
              <description>Saturate Interrupt: hardware sets this interrupt for each channel if a conversion result (before averaging) of that channel is either 0x000 or 0xFFF (for 12-bit resolution), this is an indication that the ADC likely saturated. Write with '1' to clear bit.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_SET</name>
          <description>Saturate interrupt set request register</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_MASK</name>
          <description>Saturate interrupt mask register.</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_MASKED</name>
          <description>Saturate interrupt masked request register</description>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR</name>
          <description>Range detect interrupt request register.</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_INTR</name>
              <description>Range detect Interrupt: hardware sets this interrupt for each channel if the conversion result (after averaging) of that channel met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_SET</name>
          <description>Range detect interrupt set request register</description>
          <addressOffset>0x234</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_MASK</name>
          <description>Range detect interrupt mask register.</description>
          <addressOffset>0x238</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_MASKED</name>
          <description>Range interrupt masked request register</description>
          <addressOffset>0x23C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt cause register</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC00000FF</resetMask>
          <fields>
            <field>
              <name>EOS_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FW_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_MASKED_RED</name>
              <description>Reduction OR of all SAR_SATURATION_INTR_MASKED bits</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_MASKED_RED</name>
              <description>Reduction OR of all SAR_RANGE_INTR_MASKED bits</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INJ_CHAN_CONFIG</name>
          <description>Injection channel configuration register.</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0003777</resetMask>
          <fields>
            <field>
              <name>INJ_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this injection channel. If differential is enabled then PIN_ADDR[0] is ignored and considered to be 0, i.e. PIN_ADDR points to the even pin of a pin pair.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AROUTE_VIRT</name>
                  <description>AROUTE virtual port</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INJ_DIFFERENTIAL_EN</name>
              <description>Differential enable for this channel.
- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (INJ_PIN_ADDR[0] is ignored).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RESOLUTION</name>
              <description>Resolution for this channel.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>12B</name>
                  <description>12-bit resolution is used for this channel.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INJ_AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SAMPLE_TIME_SEL</name>
              <description>Injection sample time select: select which of the 4 global sample times to use for this channel</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_TAILGATING</name>
              <description>Injection channel tailgating.
- 0: no tailgating for this channel, SAR is immediately triggered when the INJ_START_EN bit is set if the SAR is not busy. If the SAR is busy, the INJ
     channel addressed pin is sampled at the end of the current scan.
- 1: injection channel tailgating. The addressed pin is sampled after the next trigger and after all enabled channels have been scanned.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_START_EN</name>
              <description>Set by firmware to enable the injection channel. If INJ_TAILGATING is not set this bit also functions as trigger for this channel. Cleared by hardware after this channel has been sampled (i.e. this channel is always one shot even if CONTINUOUS is set). Also cleared if the SAR is disabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INJ_RESULT</name>
          <description>Injection channel result register</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>INJ_RESULT</name>
              <description>SAR conversion result of the channel.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH0</name>
          <description>SARMUX Firmware switch controls</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between vssa_kelvin and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between temperature sensor and vplus signal, also powers on the temperature sensor. Write with '1' to set bit.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusa and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusb and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusa and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusb and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus0 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus1 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus0 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus1 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_COREIO0</name>
              <description>Firmware control: 0=open, 1=close switch between P4 and coreio0 signal. Write with '1' to set bit.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_COREIO1</name>
              <description>Firmware control: 0=open, 1=close switch between P5 and coreio1 signal. Write with '1' to set bit.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_COREIO2</name>
              <description>Firmware control: 0=open, 1=close switch between P6 and coreio2 signal. Write with '1' to set bit.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_COREIO3</name>
              <description>Firmware control: 0=open, 1=close switch between P7 and coreio3 signal. Write with '1' to set bit.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_CLEAR0</name>
          <description>SARMUX Firmware switch control clear</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_COREIO0</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_COREIO1</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_COREIO2</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_COREIO3</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH1</name>
          <description>SARMUX Firmware switch controls</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P4_DFT_INP</name>
              <description>Firmware control: 0=open, 1=close switch between P4 pin and dft_inp signal. Write with '1' to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_DFT_INM</name>
              <description>Firmware control: 0=open, 1=close switch between P5 pin and dft_inm signal. Write with '1' to set bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT0_SARBUS0</name>
              <description>Firmware control: 0=open, 1=close switch between adft0 signal and sarbus0 signal. Write with '1' to set bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT1_SARBUS1</name>
              <description>Firmware control: 0=open, 1=close switch between adft1 signal and sarbus1 signal. Write with '1' to set bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_CLEAR1</name>
          <description>SARMUX Firmware switch control clear</description>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P4_DFT_INP</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_DFT_INM</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT0_SARBUS0</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT1_SARBUS1</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_HW_CTRL</name>
          <description>SARMUX switch hardware control</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF00FF</resetMask>
          <fields>
            <field>
              <name>MUX_HW_CTRL_P0</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P0 switches.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P1</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P1 switches.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P2</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P2 switches.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P3</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P3 switches.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P4</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P4 switches.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P5</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P5 switches.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P6</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P6 switches.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P7</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P7 switches.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_VSSA</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for vssa switch.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_TEMP</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for temp switch.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_AMUXBUSA</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for amuxbusa switches.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_AMUXBUSB</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for amuxbusb switches.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_SARBUS0</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for sarbus0 switches.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_SARBUS1</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for sarbus1 switches.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_STATUS</name>
          <description>SARMUX switch status</description>
          <addressOffset>0x348</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PUMP_CTRL</name>
          <description>Switch pump control</description>
          <addressOffset>0x380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>CLOCK_SEL</name>
              <description>Clock select: 0=external clock, 1=internal clock (deprecated).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>0=disabled: pump output is VDDA_PUMP, 1=enabled: pump output is boosted.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANA_TRIM</name>
          <description>Analog trim register.</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>CAP_TRIM</name>
              <description>Attenuation cap trimming</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIMUNIT</name>
              <description>Attenuation cap trimming</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WOUNDING</name>
          <description>SAR wounding register</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>WOUND_RESOLUTION</name>
              <description>Maximum SAR resolution allowed</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>12BIT</name>
                  <description>unwounded: up to full 12-bit SAR resolution allowed</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>10BIT</name>
                  <description>wounded: max resolution upto 10-bit SAR resolution allowed</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8BIT</name>
                  <description>wounded: only 8-bit SAR resolution allowed</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8BIT_TOO</name>
                  <description>wounded: only 8-bit SAR resolution allowed</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PASS0</name>
      <description>PASS top-level MMIO (DSABv2, INTR)</description>
      <headerStructName>PASS</headerStructName>
      <baseAddress>0x403F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt cause register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>CTB0_INT</name>
              <description>CTB0 interrupt pending</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTB1_INT</name>
              <description>CTB1 interrupt pending</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTB2_INT</name>
              <description>CTB2 interrupt pending</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTB3_INT</name>
              <description>CTB3 interrupt pending</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_CTRL</name>
          <description>DFT control register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>DSAB_ADFT_RES_EN</name>
              <description>Close the switch to connect the DSAB ADFT resistor to the AMUXBUS</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PASS_CTRL</name>
          <description>PASS Control</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF03</resetMask>
          <fields>
            <field>
              <name>PMPCLK_BYP</name>
              <description>- 0: Pump clk is clk_hf/2
 - 1: Pump clk is selected from PMPCLK_SRC</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMPCLK_SRC</name>
              <description>- 0: Pump clk is clk_hf
 - 1: Pump clk is direct from SRSS</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RMB_BITS</name>
              <description>Risk mitigation bits</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>DSAB</name>
          <description>DSAB configuration</description>
          <addressOffset>0x00000E00</addressOffset>
          <register>
            <name>DSAB_CTRL</name>
            <description>global DSAB control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x910F0F3F</resetMask>
            <fields>
              <field>
                <name>CURRENT_SEL</name>
                <description>DSAB DAC control field

Nominal DSAB Output Current = CURRENT_SEL * 0.075 uA

In products with SRSS-LITE, this setting impacts the CTB(m) offset. A value of 0x20 is used during factory trim and is required to maintain low offsets across temperature variation. If a different setting is used then a periodic re-trim of CTB(m) offset should be performed.</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SEL_OUT</name>
                <description>N/A</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REF_SWAP_EN</name>
                <description>This field (along with SEL_OUT and ENABLED) provides bitwise selection of the current sources that drive the DSAB ZTC and PTAT outputs.

See SEL_OUT field for truth tables.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BYPASS_MODE_EN</name>
                <description>0 - DSAB PTAT generator is powered from DSAB regulator: VDDA must be at least 2.4V
1 - DSAB PTAT generator is pwoered directly from VDDA: VDDA cannot exceed 4.0V</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STARTUP_RM</name>
                <description>Risk mitigation control                                                                                         
1 - Force start the startup circuit</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>This field (along with SEL_OUT and REF_SWAP_EN) provides bitwise selection of the current sources that drive the DSAB ZTC and PTAT outputs.
See SEL_OUT field for truth tables.
In SRSSLT devices, in active mode, this bit is overridden to '1', that is - it is always enabled in active mode.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DSAB_DFT</name>
            <description>DFT bits</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>EN_DFT</name>
                <description>- 0: DSAB DFT disabled
- 1: DSAB DFT enabled (connect output to amuxbus)

0001 - PTAT&lt;0&gt;
0010 - PTAT&lt;1&gt;
0011 - PTAT&lt;1:0&gt;
0100 - PTAT&lt;2&gt;
0111 - PTAT&lt;2:0&gt;
1000 - PTAT&lt;3&gt;
1111 - PTAT&lt;3:0&gt; 
1001 - DSAB Reg Out</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>DSAB_TRIM</name>
          <description>DSAB Trim bits</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>IBIAS_TRIM</name>
              <description>1111=lowest, 0000=highest</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSAB_RMB_BITS</name>
              <description>Risk mitigation bits</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CANFD0</name>
      <description>CAN Controller</description>
      <headerStructName>CANFD</headerStructName>
      <baseAddress>0x40400000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>131072</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <name>CH</name>
          <description>FIFO wrapper around M_TTCAN 3PIP, to enable DMA</description>
          <addressOffset>0x00000000</addressOffset>
          <cluster>
            <name>M_TTCAN</name>
            <description>TTCAN 3PIP, includes FD</description>
            <addressOffset>0x00000000</addressOffset>
            <register>
              <name>CREL</name>
              <description>Core Release Register</description>
              <addressOffset>0x0</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>DAY</name>
                  <description>Time Stamp Day
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MON</name>
                  <description>Time Stamp Month
Two digits, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>YEAR</name>
                  <description>Time Stamp Year
One digit, BCD-coded. This field is set by generic parameter on M_TTCAN synthesis.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SUBSTEP</name>
                  <description>Sub-step of Core Release
One digit, BCD-coded.</description>
                  <bitRange>[23:20]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>STEP</name>
                  <description>Step of Core Release
One digit, BCD-coded.</description>
                  <bitRange>[27:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REL</name>
                  <description>Core Release
One digit, BCD-coded.</description>
                  <bitRange>[31:28]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ENDN</name>
              <description>Endian Register</description>
              <addressOffset>0x4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x87654321</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ETV</name>
                  <description>Endianness Test Value
The endianness test value is 0x87654321.</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>DBTP</name>
              <description>Data Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0xC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xA33</resetValue>
              <resetMask>0x9F1FFF</resetMask>
              <fields>
                <field>
                  <name>DSJW</name>
                  <description>Data (Re)Synchronization Jump Width
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[3:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG2</name>
                  <description>Data time segment after sample point
0x0-0xF Valid values are 0 to 15. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[7:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DTSEG1</name>
                  <description>Data time segment before sample point
0x00-0x1F Valid values are 0 to 31. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DBRP</name>
                  <description>Data Bit Rate Prescaler
0x00-0x1F The value by which the oscillator frequency is divided for generating the bit time
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit
Rate Prescaler are 0 to 31. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDC</name>
                  <description>Transmitter Delay Compensation
0= Transmitter Delay Compensation disabled
1= Transmitter Delay Compensation enabled</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TEST</name>
              <description>Test Register</description>
              <addressOffset>0x10</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F</resetMask>
              <fields>
                <field>
                  <name>TAM</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Multiplexer Control
Controls output pin m_ttcan_ascm in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_ascm controlled by FSE
1= Level at pin m_ttcan_ascm = '1'</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TAT</name>
                  <description>ASC is not supported by M_TTCAN
Test ASC Transmit Control
Controls output pin m_ttcan_asct in test mode, ORed with the signal from the FSE
0= Level at pin m_ttcan_asct controlled by FSE
1= Level at pin m_ttcan_asct = '1'</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAM</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Multiplexer Control
Monitors level at output pin m_ttcan_ascm.
0= Output pin m_ttcan_ascm = '0'
1= Output pin m_ttcan_ascm = '1'</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CAT</name>
                  <description>ASC is not supported by M_TTCAN
Check ASC Transmit Control
Monitors level at output pin m_ttcan_asct.
0= Output pin m_ttcan_asct = '0'</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LBCK</name>
                  <description>Loop Back Mode
0= Reset value, Loop Back Mode is disabled
1= Loop Back Mode is enabled (see Section 3.1.9, Test Modes)</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TX</name>
                  <description>Control of Transmit Pin
00 Reset value, m_ttcan_tx controlled by the CAN Core, updated at the end of the CAN bit time
01 Sample Point can be monitored at pin m_ttcan_tx
10 Dominant ('0') level at pin m_ttcan_tx
11 Recessive ('1') at pin m_ttcan_tx</description>
                  <bitRange>[6:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RX</name>
                  <description>Receive Pin
Monitors the actual value of pin m_ttcan_rx
0= The CAN bus is dominant (m_ttcan_rx = '0')
1= The CAN bus is recessive (m_ttcan_rx = '1')</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RWD</name>
              <description>RAM Watchdog</description>
              <addressOffset>0x14</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>WDC</name>
                  <description>Watchdog Configuration
Start value of the Message RAM Watchdog Counter. With the reset value of '00' the counter is
disabled.</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDV</name>
                  <description>Watchdog Value
Actual Message RAM Watchdog Counter Value.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>CCCR</name>
              <description>CC Control Register</description>
              <addressOffset>0x18</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x1</resetValue>
              <resetMask>0xF3FF</resetMask>
              <fields>
                <field>
                  <name>INIT</name>
                  <description>Initialization
0= Normal Operation
1= Initialization is started</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CCE</name>
                  <description>Configuration Change Enable
0= The CPU has no write access to the protected configuration registers
1= The CPU has write access to the protected configuration registers (while CCCR.INIT = '1')</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ASM</name>
                  <description>Restricted Operation Mode
Bit ASM can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time. For a description of the Restricted Operation Mode see Section 3.1.5.
0= Normal CAN operation
1= Restricted Operation Mode active</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSA</name>
                  <description>Clock Stop Acknowledge
0= No clock stop acknowledged
1= M_TTCAN may be set in power down by stopping m_ttcan_hclk and m_ttcan_cclk</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSR</name>
                  <description>Clock Stop Request, not supported by M_TTCAN use CTL.STOP_REQ at the group level instead.
0= No clock stop is requested
1= Clock stop requested. When clock stop is requested, first INIT and then CSA will be set after
all pending transfer requests have been completed and the CAN bus reached idle.</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MON_</name>
                  <description>Bus Monitoring Mode
Bit MON can only be set by the Host when both CCE and INIT are set to '1'. The bit can be reset by
the Host at any time.
0= Bus Monitoring Mode is disabled
1= Bus Monitoring Mode is enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DAR</name>
                  <description>Disable Automatic Retransmission
0= Automatic retransmission of messages not transmitted successfully enabled
1= Automatic retransmission disabled</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEST</name>
                  <description>Test Mode Enable
0= Normal operation, register TEST holds reset values
1= Test Mode, write access to register TEST enabled</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FDOE</name>
                  <description>FD Operation Enable
0= FD operation disabled
1= FD operation enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BRSE</name>
                  <description>Bit Rate Switch Enable
0= Bit rate switching for transmissions disabled
1= Bit rate switching for transmissions enabled</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PXHD</name>
                  <description>Protocol Exception Handling Disable
0= Protocol exception handling enabled
1= Protocol exception handling disabled</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFBI</name>
                  <description>Edge Filtering during Bus Integration
0= Edge filtering disabled
1= Two consecutive dominant tq required to detect an edge for hard synchronization</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXP</name>
                  <description>Transmit Pause
If this bit is set, the M_TTCAN pauses for two CAN bit times before starting the next transmission
after itself has successfully transmitted a frame (see Section 3.5).
0= Transmit pause disabled
1= Transmit pause enabled</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NISO</name>
                  <description>Non ISO Operation
If this bit is set, the M_TTCAN uses the CAN FD frame format as specified by the Bosch CAN FD
Specification V1.0.
0= CAN FD frame format according to ISO 11898-1:2015
1= CAN FD frame format according to Bosch CAN FD Specification V1.0 addressing the non-ISO CAN FD</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NBTP</name>
              <description>Nominal Bit Timing &amp; Prescaler Register</description>
              <addressOffset>0x1C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x6000A03</resetValue>
              <resetMask>0xFFFFFF7F</resetMask>
              <fields>
                <field>
                  <name>NTSEG2</name>
                  <description>Nominal Time segment after sample point
0x01-0x7F Valid values are 1 to 127. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NTSEG1</name>
                  <description>Nominal Time segment before sample point
0x01-0xFF Valid values are 1 to 255. The actual interpretation by the hardware of this value is
such that one more than the programmed value is used.</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NBRP</name>
                  <description>Nominal Bit Rate Prescaler
0x000-0x1FFThe value by which the oscillator frequency is divided for generating the bit time
quanta. The bit time is built up from a multiple of this quanta. Valid values for the Bit
Rate Prescaler are 0 to 511. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[24:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NSJW</name>
                  <description>Nominal (Re)Synchronization Jump Width
0x00-0x7F Valid values are 0 to 127. The actual interpretation by the hardware of this value is
such that one more than the value programmed here is used.</description>
                  <bitRange>[31:25]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCC</name>
              <description>Timestamp Counter Configuration</description>
              <addressOffset>0x20</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xF0003</resetMask>
              <fields>
                <field>
                  <name>TSS</name>
                  <description>Timestamp Select, should always be set to external timestamp counter
00= Timestamp counter value always 0x0000
01= Timestamp counter value incremented according to TCP
10= External timestamp counter value used
11= Same as '00'</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCP</name>
                  <description>Timestamp Counter Prescaler (still used for TOCC)
0x0-0xF Configures the timestamp and timeout counters time unit in multiples of CAN bit times
[1...16]. The actual interpretation by the hardware of this value is such that one more
than the value programmed here is used.</description>
                  <bitRange>[19:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TSCV</name>
              <description>Timestamp Counter Value</description>
              <addressOffset>0x24</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TSC</name>
                  <description>Timestamp Counter, not used for M_TTCAN
The internal/external Timestamp Counter value is captured on start of frame (both Rx and Tx).
When TSCC.TSS = '01', the Timestamp Counter is incremented in multiples of CAN bit times
[1...16] depending on the configuration of TSCC.TCP. A wrap around sets interrupt flag IR.TSW.
Write access resets the counter to zero. When TSCC.TSS = '10', TSC reflects the external
Timestamp Counter value. A write access has no impact.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCC</name>
              <description>Timeout Counter Configuration</description>
              <addressOffset>0x28</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF0000</resetValue>
              <resetMask>0xFFFF0007</resetMask>
              <fields>
                <field>
                  <name>ETOC</name>
                  <description>Enable Timeout Counter
0= Timeout Counter disabled
1= Timeout Counter enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOS</name>
                  <description>Timeout Select
When operating in Continuous mode, a write to TOCV presets the counter to the value configured
by TOCC.TOP and continues down-counting. When the Timeout Counter is controlled by one of the
FIFOs, an empty FIFO presets the counter to the value configured by TOCC.TOP. Down-counting
is started when the first FIFO element is stored.
00= Continuous operation
01= Timeout controlled by Tx Event FIFO
10= Timeout controlled by Rx FIFO 0
11= Timeout controlled by Rx FIFO 1</description>
                  <bitRange>[2:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOP</name>
                  <description>Timeout Period
Start value of the Timeout Counter (down-counter). Configures the Timeout Period.</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TOCV</name>
              <description>Timeout Counter Value</description>
              <addressOffset>0x2C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0xFFFF</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>TOC</name>
                  <description>Timeout Counter
The Timeout Counter is decremented in multiples of CAN bit times [1...16] depending on the
configuration of TSCC.TCP. When decremented to zero, interrupt flag IR.TOO is set and the
Timeout Counter is stopped. Start and reset/restart conditions are configured via TOCC.TOS.</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ECR</name>
              <description>Error Counter Register</description>
              <addressOffset>0x40</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TEC</name>
                  <description>Transmit Error Counter
Actual state of the Transmit Error Counter, values between 0 and 255</description>
                  <bitRange>[7:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>REC</name>
                  <description>Receive Error Counter
Actual state of the Receive Error Counter, values between 0 and 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RP</name>
                  <description>Receive Error Passive
0= The Receive Error Counter is below the error passive level of 128
1= The Receive Error Counter has reached the error passive level of 128</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CEL</name>
                  <description>CAN Error Logging
The counter is incremented each time when a CAN protocol error causes the Transmit Error Counter
or the Receive Error Counter to be incremented. It is reset by read access to CEL. The counter stops
at 0xFF; the next increment of TEC or REC sets interrupt flag IR.ELO.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>PSR</name>
              <description>Protocol Status Register</description>
              <addressOffset>0x44</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x707</resetValue>
              <resetMask>0x7F7FFF</resetMask>
              <fields>
                <field>
                  <name>LEC</name>
                  <description>Last Error Code,
Set on Read0
The LEC indicates the type of the last error to occur on the CAN bus. This field will be cleared to '0'
when a message has been transferred (reception or transmission) without error.

0= No Error: No error occurred since LEC has been reset by successful reception or transmission.
1= Stuff Error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
2= Form Error: A fixed format part of a received frame has the wrong format.
3= AckError: The message transmitted by the M_TTCAN was not acknowledged by another node.
4= Bit1Error: During the transmission of a message (with the exception of the arbitration field),
the device wanted to send a recessive level (bit of logical value '1'), but the monitored bus
 value was dominant. 
5= Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or
overload flag), the device wanted to send a dominant level (data or identifier bit logical value
0'), but the monitored bus value was recessive. During Bus_Off recovery this status is set
each time a sequence of 11 recessive bits has been monitored. This enables the CPU to
monitor the proceeding of the Bus_Off recovery sequence (indicating the bus is not stuck at
dominant or continuously disturbed).
6= CRCError: The CRC check sum of a received message was incorrect. The CRC of an incoming
message does not match with the CRC calculated from the received data.
7= NoChange: Any read access to the Protocol Status Register re-initializes the LEC to '7'.
When the LEC shows the value '7', no CAN bus event was detected since the last CPU read
access to the Protocol Status Register.</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>ACT</name>
                  <description>Activity
Monitors the module's CAN communication state.
00= Synchronizing - node is synchronizing on CAN communication
01= Idle - node is neither receiver nor transmitter
10= Receiver - node is operating as receiver
11= Transmitter - node is operating as transmitter</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EP</name>
                  <description>Error Passive
0= The M_CAN is in the Error_Active state. It normally takes part in bus communication and sends an active error flag when an error has been detected
1= The M_CAN is in the Error_Passive state</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EW</name>
                  <description>Warning Status
0= Both error counters are below the Error_Warning limit of 96
1= At least one of error counter has reached the Error_Warning limit of 96</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>BO</name>
                  <description>Bus_Off Status
0= The M_CAN is not Bus_Off
1= The M_CAN is in Bus_Off state</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DLEC</name>
                  <description>Data Phase Last Error Code
, Set on Read
Type of last error that occurred in the data phase of a CAN FD format frame with its BRS flag set. Coding is the same as for LEC. This field will be cleared to zero when a CAN FD format frame with its BRS flag set has been transferred (reception or transmission) without error.</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RESI</name>
                  <description>ESI flag of last received CAN FD Message
, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its ESI flag set
1= Last received CAN FD message had its ESI flag set</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RBRS</name>
                  <description>BRS flag of last received CAN FD Message
, Reset on Read
This bit is set together with RFDF, independent of acceptance filtering.
0= Last received CAN FD message did not have its BRS flag set
1= Last received CAN FD message had its BRS flag set</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RFDF</name>
                  <description>Received a CAN FD Message
, Reset on Read
This bit is set independent of acceptance filtering.
0= Since this bit was reset by the CPU, no CAN FD message has been received
1= Message in CAN FD format with FDF flag set has been received</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>PXE</name>
                  <description>Protocol Exception Event
, Reset on Read
0= No protocol exception event occurred since last read access
1= Protocol exception event occurred</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TDCV</name>
                  <description>Transmitter Delay Compensation Value
0x00-0x7F Position of the secondary sample point, defined by the sum of the measured delay from m_can_tx to m_can_rx and TDCR.TDCO. The SSP position is, in the data phase, the number of mtq between the start of the transmitted bit and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TDCR</name>
              <description>Transmitter Delay Compensation Register</description>
              <addressOffset>0x48</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F7F</resetMask>
              <fields>
                <field>
                  <name>TDCF</name>
                  <description>Transmitter Delay Compensation Filter Window Length
0x00-0x7F Defines the minimum value for the SSP position, dominant edges on m_ttcan_rx
that would result in an earlier SSP position are ignored for transmitter delay measurement.
The feature is enabled when TDCF is configured to a value greater than
TDCO. Valid values are 0 to 127 mtq</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TDCO</name>
                  <description>Transmitter Delay Compensation Offset
0x00-0x7F Offset value defining the distance between the measured delay from m_ttcan_tx to
m_ttcan_rx and the secondary sample point. Valid values are 0 to 127 mtq.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IR</name>
              <description>Interrupt Register</description>
              <addressOffset>0x50</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0N</name>
                  <description>Rx FIFO 0 New Message
0= No new message written to Rx FIFO 0
1= New message written to Rx FIFO 0</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0W</name>
                  <description>Rx FIFO 0 Watermark Reached
0= Rx FIFO 0 fill level below watermark
1= Rx FIFO 0 fill level reached watermark</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0F</name>
                  <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0L_</name>
                  <description>Rx FIFO 0 Message Lost
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1N</name>
                  <description>Rx FIFO 1 New Message
0= No new message written to Rx FIFO 1
1= New message written to Rx FIFO 1</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1W</name>
                  <description>Rx FIFO 1 Watermark Reached
0= Rx FIFO 1 fill level below watermark
1= Rx FIFO 1 fill level reached watermark</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1F</name>
                  <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1L_</name>
                  <description>Rx FIFO 1 Message Lost
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPM</name>
                  <description>High Priority Message
0= No high priority message received
1= High priority message received</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TC</name>
                  <description>Transmission Completed
0= No transmission completed
1= Transmission completed</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCF</name>
                  <description>Transmission Cancellation Finished
0= No transmission cancellation finished
1= Transmission cancellation finished</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFE</name>
                  <description>Tx FIFO Empty
0= Tx FIFO non-empty
1= Tx FIFO empty</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFN</name>
                  <description>Tx Event FIFO New Entry
0= Tx Event FIFO unchanged
1= Tx Handler wrote Tx Event FIFO element</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFW</name>
                  <description>Tx Event FIFO Watermark Reached
0= Tx Event FIFO fill level below watermark
1= Tx Event FIFO fill level reached watermark</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFF</name>
                  <description>Tx Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFL_</name>
                  <description>Tx Event FIFO Element Lost
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSW</name>
                  <description>Timestamp Wraparound
0= No timestamp counter wrap-around
1= Timestamp counter wrapped around</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAF</name>
                  <description>Message RAM Access Failure
The flag is set, when the Rx Handler
- has not completed acceptance filtering or storage of an accepted message until the arbitration field of the following message has been received. In this case acceptance filtering or message storage is aborted and the Rx Handler starts processing of the following message.
- was not able to write a message to the Message RAM. In this case message storage is aborted.
In both cases the FIFO put index is not updated resp. the New Data flag for a dedicated Rx Buffer is not set, a partly stored message is overwritten when the next message is stored to this location.
The flag is also set when the Tx Handler was not able to read a message from the Message RAM
in time. In this case message transmission is aborted. In case of a Tx Handler access failure the
M_TTCAN is switched into Restricted Operation Mode (see Section 3.1.5). To leave Restricted
Operation Mode, the Host CPU has to reset CCCR.ASM.
0= No Message RAM access failure occurred
1= Message RAM access failure occurred</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOO</name>
                  <description>Timeout Occurred
0= No timeout
1= Timeout reached</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRX</name>
                  <description>Message stored to Dedicated Rx Buffer
The flag is set whenever a received message has been stored into a dedicated Rx Buffer.
0= No Rx Buffer updated
1= At least one received message stored into a Rx Buffer</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEC</name>
                  <description>M_TTCAN reports correctable ECC fault to the generic fault structure, this bit always reads as 0.
Bit Error Corrected
Message RAM bit error detected and corrected. Controlled by input signal m_ttcan_aeim_berr[0]
generated by an optional external parity / ECC logic attached to the Message RAM.
0= No bit error detected when reading from Message RAM
1= Bit error detected and corrected (e.g. ECC)</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEU</name>
                  <description>Bit Error Uncorrected
Message RAM bit error detected, uncorrected. Controlled by input signal m_ttcan_aeim_berr[1]
generated by an optional external parity / ECC logic attached to the Message RAM. An uncorrected
Message RAM bit error sets CCCR.INIT to '1'. This is done to avoid transmission of corrupted data.
0= No bit error detected when reading from Message RAM
1= Bit error detected, uncorrected (e.g. parity logic)</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELO</name>
                  <description>Error Logging Overflow
0= CAN Error Logging Counter did not overflow
1= Overflow of CAN Error Logging Counter occurred</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EP_</name>
                  <description>Error Passive
0= Error_Passive status unchanged
1= Error_Passive status changed</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EW_</name>
                  <description>Warning Status
0= Error_Warning status unchanged
1= Error_Warning status changed</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BO_</name>
                  <description>Bus_Off Status
0= Bus_Off status unchanged
1= Bus_Off status changed</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDI</name>
                  <description>Watchdog Interrupt
0= No Message RAM Watchdog event occurred
1= Message RAM Watchdog event due to missing READY</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEA</name>
                  <description>Protocol Error in Arbitration Phase (Nominal Bit Time is used)
0= No protocol error in arbitration phase
1= Protocol error in arbitration phase detected (PSR.LEC != 0,7)</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PED</name>
                  <description>Protocol Error in Data Phase (Data Bit Time is used)
0= No protocol error in data phase
1= Protocol error in data phase detected (PSR.DLEC != 0,7)</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARA</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>IE</name>
              <description>Interrupt Enable</description>
              <addressOffset>0x54</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NE</name>
                  <description>Rx FIFO 0 New Message Interrupt Enable</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WE</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Enable</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FE</name>
                  <description>Rx FIFO 0 Full Interrupt Enable</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LE</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Enable</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NE</name>
                  <description>Rx FIFO 1 New Message Interrupt Enable</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WE</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Enable</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FE</name>
                  <description>Rx FIFO 1 Full Interrupt Enable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LE</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Enable</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPME</name>
                  <description>High Priority Message Interrupt Enable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCE</name>
                  <description>Transmission Completed Interrupt Enable</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFE</name>
                  <description>Transmission Cancellation Finished Interrupt Enable</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEE</name>
                  <description>Tx FIFO Empty Interrupt Enable</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNE</name>
                  <description>Tx Event FIDO New Entry Interrupt Enable</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWE</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Enable</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFE</name>
                  <description>Tx Event FIFO Full Interrupt Enable</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLE</name>
                  <description>Tx Event FIFO Event Lost Interrupt Enable</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWE</name>
                  <description>Timestamp Wraparound Interrupt Enable</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFE</name>
                  <description>Message RAM Access Failure Interrupt Enable</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOE</name>
                  <description>Timeout Occurred Interrupt Enable</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXE</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Enable</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECE</name>
                  <description>Bit Error Corrected Interrupt Enable (not used in M_TTCAN)</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUE</name>
                  <description>Bit Error Uncorrected Interrupt Enable</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOE</name>
                  <description>Error Logging Overflow Interrupt Enable</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPE</name>
                  <description>Error Passive Interrupt Enable</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWE</name>
                  <description>Warning Status Interrupt Enable</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOE</name>
                  <description>Bus_Off Status Interrupt Enable</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIE</name>
                  <description>Watchdog Interrupt Enable</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAE</name>
                  <description>Protocol Error in Arbitration Phase Enable</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDE</name>
                  <description>Protocol Error in Data Phase Enable</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAE</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILS</name>
              <description>Interrupt Line Select</description>
              <addressOffset>0x58</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RF0NL</name>
                  <description>Rx FIFO 0 New Message Interrupt Line</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0WL</name>
                  <description>Rx FIFO 0 Watermark Reached Interrupt Line</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0FL</name>
                  <description>Rx FIFO 0 Full Interrupt Line</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF0LL</name>
                  <description>Rx FIFO 0 Message Lost Interrupt Line</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1NL</name>
                  <description>Rx FIFO 1 New Message Interrupt Line</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1WL</name>
                  <description>Rx FIFO 1 Watermark Reached Interrupt Line</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1FL</name>
                  <description>Rx FIFO 1 Full Interrupt Line</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RF1LL</name>
                  <description>Rx FIFO 1 Message Lost Interrupt Line</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>HPML</name>
                  <description>High Priority Message Interrupt Line</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCL</name>
                  <description>Transmission Completed Interrupt Line</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TCFL</name>
                  <description>Transmission Cancellation Finished Interrupt Line</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFEL</name>
                  <description>Tx FIFO Empty Interrupt Line</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFNL</name>
                  <description>Tx Event FIFO New Entry Interrupt Line</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFWL</name>
                  <description>Tx Event FIFO Watermark Reached Interrupt Line</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFFL</name>
                  <description>Tx Event FIFO Full Interrupt Line</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TEFLL</name>
                  <description>Tx Event FIFO Event Lost Interrupt Line</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TSWL</name>
                  <description>Timestamp Wraparound Interrupt Line</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>MRAFL</name>
                  <description>Message RAM Access Failure Interrupt Line</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TOOL</name>
                  <description>Timeout Occurred Interrupt Line</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DRXL</name>
                  <description>Message stored to Dedicated Rx Buffer Interrupt Line</description>
                  <bitRange>[19:19]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BECL</name>
                  <description>Bit Error Corrected Interrupt Line  (not used in M_TTCAN)</description>
                  <bitRange>[20:20]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BEUL</name>
                  <description>Bit Error Uncorrected Interrupt Line</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELOL</name>
                  <description>Error Logging Overflow Interrupt Line</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EPL</name>
                  <description>Error Passive Interrupt Line</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EWL</name>
                  <description>Warning Status Interrupt Line</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>BOL</name>
                  <description>Bus_Off Status Interrupt Line</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WDIL</name>
                  <description>Watchdog Interrupt Line</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEAL</name>
                  <description>Protocol Error in Arbitration Phase Line</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>PEDL</name>
                  <description>Protocol Error in Data Phase Line</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ARAL</name>
                  <description>N/A</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>ILE</name>
              <description>Interrupt Line Enable</description>
              <addressOffset>0x5C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3</resetMask>
              <fields>
                <field>
                  <name>EINT0</name>
                  <description>Enable Interrupt Line 0
0= Interrupt line m_ttcan_int0 disabled
1= Interrupt line m_ttcan_int0 enabled</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EINT1</name>
                  <description>Enable Interrupt Line 1
0= Interrupt line m_ttcan_int1 disabled
1= Interrupt line m_ttcan_int1 enabled</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>GFC</name>
              <description>Global Filter Configuration</description>
              <addressOffset>0x80</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>RRFE</name>
                  <description>Reject Remote Frames Extended
0= Filter remote frames with 29-bit extended IDs
1= Reject all remote frames with 29-bit extended IDs</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RRFS</name>
                  <description>Reject Remote Frames Standard
0= Filter remote frames with 11-bit standard IDs
1= Reject all remote frames with 11-bit standard IDs</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFE</name>
                  <description>Accept Non-matching Frames Extended
Defines how received messages with 29-bit IDs that do not match any element of the filter list are
treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ANFS</name>
                  <description>Accept Non-matching Frames Standard
Defines how received messages with 11-bit IDs that do not match any element of the filter list are
treated.
00= Accept in Rx FIFO 0
01= Accept in Rx FIFO 1
10= Reject
11= Reject</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>SIDFC</name>
              <description>Standard ID Filter Configuration</description>
              <addressOffset>0x84</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFC</resetMask>
              <fields>
                <field>
                  <name>FLSSA</name>
                  <description>Filter List Standard Start Address
Start address of standard Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSS</name>
                  <description>List Size Standard
0= No standard Message ID filter
1-128= Number of standard Message ID filter elements
128= Values greater than 128 are interpreted as 128</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDFC</name>
              <description>Extended ID Filter Configuration</description>
              <addressOffset>0x88</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>FLESA</name>
                  <description>Filter List Extended Start Address
Start address of extended Message ID filter list (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LSE</name>
                  <description>List Size Extended
0= No extended Message ID filter
1-64= Number of extended Message ID filter elements
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>XIDAM</name>
              <description>Extended ID AND Mask</description>
              <addressOffset>0x90</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1FFFFFFF</resetMask>
              <fields>
                <field>
                  <name>EIDM</name>
                  <description>Extended ID Mask
For acceptance filtering of extended frames the Extended ID AND Mask is ANDed with the Message
ID of a received frame. Intended for masking of 29-bit IDs in SAE J1939. With the reset value of all
bits set to one the mask is not active.</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>HPMS</name>
              <description>High Priority Message Status</description>
              <addressOffset>0x94</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>BIDX</name>
                  <description>Buffer Index
Index of Rx FIFO element to which the message was stored. Only valid when MSI[1] = '1'.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MSI</name>
                  <description>Message Storage Indicator
00= No FIFO selected
01= FIFO message lost
10= Message stored in FIFO 0
11= Message stored in FIFO 1</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FIDX</name>
                  <description>Filter Index
Index of matching filter element. Range is 0 to SIDFC.LSS - 1 resp. XIDFC.LSE - 1.</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>FLST</name>
                  <description>Filter List
Indicates the filter list of the matching filter element.
0= Standard Filter List
1= Extended Filter List</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT1</name>
              <description>New Data 1</description>
              <addressOffset>0x98</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data
The register holds the New Data flags of Rx Buffers 0 to 31. The flags are set when the respective
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them.
A flag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. A hard
reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>NDAT2</name>
              <description>New Data 2</description>
              <addressOffset>0x9C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>ND</name>
                  <description>New Data
The register holds the New Data flags of Rx Buffers 32 to 63. The flags are set when the respective
Rx Buffer has been updated from a received frame. The flags remain set until the Host clears them.
A flag is cleared by writing a '1' to the corresponding bit position. Writing a '0' has no effect. A hard
reset will clear the register.
0= Rx Buffer not updated
1= Rx Buffer updated from new message</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0C</name>
              <description>Rx FIFO 0 Configuration</description>
              <addressOffset>0xA0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F0SA</name>
                  <description>Rx FIFO 0 Start Address
Start address of Rx FIFO 0 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0S</name>
                  <description>Rx FIFO 0 Size
0= No Rx FIFO 0
1-64= Number of Rx FIFO 0 elements
64= Values greater than 64 are interpreted as 64
The Rx FIFO 0 elements are indexed from 0 to F0S-1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0WM</name>
                  <description>Rx FIFO 0 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 0 watermark interrupt (IR.RF0W)
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F0OM</name>
                  <description>FIFO 0 Operation Mode
FIFO 0 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 0 blocking mode
1= FIFO 0 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0S</name>
              <description>Rx FIFO 0 Status</description>
              <addressOffset>0xA4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F0FL</name>
                  <description>Rx FIFO 0 Fill Level
Number of elements stored in Rx FIFO 0, range 0 to 64.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0GI</name>
                  <description>Rx FIFO 0 Get Index
Rx FIFO 0 read index pointer, range 0 to 63.
This field is updated by the software writing to RxF0A.F0AI</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0PI</name>
                  <description>Rx FIFO 0 Put Index
Rx FIFO 0 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F0F</name>
                  <description>Rx FIFO 0 Full
0= Rx FIFO 0 not full
1= Rx FIFO 0 full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF0L</name>
                  <description>Rx FIFO 0 Message Lost
This bit is a copy of interrupt flag IR.RF0L. When IR.RF0L is reset, this bit is also reset.
0= No Rx FIFO 0 message lost
1= Rx FIFO 0 message lost, also set after write attempt to Rx FIFO 0 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF0A</name>
              <description>Rx FIFO 0 Acknowledge</description>
              <addressOffset>0xA8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F0AI</name>
                  <description>Rx FIFO 0 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 0 it has to write the
 buffer index of the last element read from Rx FIFO 0 to F0AI. This will set the Rx FIFO 0 Get Index
 RXF0S.F0GI to F0AI + 1 and update the FIFO 0 Fill Level RXF0S.F0FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXBC</name>
              <description>Rx Buffer Configuration</description>
              <addressOffset>0xAC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFC</resetMask>
              <fields>
                <field>
                  <name>RBSA</name>
                  <description>Rx Buffer Start Address
Configures the start address of the Rx Buffers section in the Message RAM (32-bit word address).
Also used to reference debug messages A,B,C.</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1C</name>
              <description>Rx FIFO 1 Configuration</description>
              <addressOffset>0xB0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFF7FFFFC</resetMask>
              <fields>
                <field>
                  <name>F1SA</name>
                  <description>Rx FIFO 1 Start Address
Start address of Rx FIFO 1 in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1S</name>
                  <description>Rx FIFO 1 Size
0= No Rx FIFO 1
1-64= Number of Rx FIFO 1 elements
64= Values greater than 64 are interpreted as 64
The Rx FIFO 1 elements are indexed from 0 to F1S - 1</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1WM</name>
                  <description>Rx FIFO 1 Watermark
0= Watermark interrupt disabled
1-64= Level for Rx FIFO 1 watermark interrupt (IR.RF1W)
64= Watermark interrupt disabled</description>
                  <bitRange>[30:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1OM</name>
                  <description>FIFO 1 Operation Mode
FIFO 1 can be operated in blocking or in overwrite mode (see Section 3.4.2).
0= FIFO 1 blocking mode
1= FIFO 1 overwrite mode</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1S</name>
              <description>Rx FIFO 1 Status</description>
              <addressOffset>0xB4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xC33F3F7F</resetMask>
              <fields>
                <field>
                  <name>F1FL</name>
                  <description>Rx FIFO 1 Fill Level
Number of elements stored in Rx FIFO 1, range 0 to 64.</description>
                  <bitRange>[6:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1GI</name>
                  <description>Rx FIFO 1 Get Index
Rx FIFO 1 read index pointer, range 0 to 63.
This field is updated by the software writing to RxF1A.FAI</description>
                  <bitRange>[13:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1PI</name>
                  <description>Rx FIFO 1 Put Index
Rx FIFO 1 write index pointer, range 0 to 63.</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>F1F</name>
                  <description>Rx FIFO 1 Full
0= Rx FIFO 1 not full
1= Rx FIFO 1 full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RF1L</name>
                  <description>Rx FIFO 1 Message Lost
This bit is a copy of interrupt flag IR.RF1L. When IR.RF1L is reset, this bit is also reset.
0= No Rx FIFO 1 message lost
1= Rx FIFO 1 message lost, also set after write attempt to Rx FIFO 1 of size zero</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>DMS</name>
                  <description>Debug Message Status
00= Idle state, wait for reception of debug messages, DMA request is cleared
01= Debug message A received
10= Debug messages A, B received
11= Debug messages A, B, C received, DMA request is set</description>
                  <bitRange>[31:30]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXF1A</name>
              <description>Rx FIFO 1 Acknowledge</description>
              <addressOffset>0xB8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F</resetMask>
              <fields>
                <field>
                  <name>F1AI</name>
                  <description>Rx FIFO 1 Acknowledge Index
After the Host has read a message or a sequence of messages from Rx FIFO 1 it has to write the
 buffer index of the last element read from Rx FIFO 1 to F1AI. This will set the Rx FIFO 1 Get Index
 RXF1S.F1GI to F1AI + 1 and update the FIFO 1 Fill Level RXF1S.F1FL.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>RXESC</name>
              <description>Rx Buffer / FIFO Element Size Configuration</description>
              <addressOffset>0xBC</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x777</resetMask>
              <fields>
                <field>
                  <name>F0DS</name>
                  <description>N/A</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>F1DS</name>
                  <description>Rx FIFO 1 Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[6:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RBDS</name>
                  <description>Rx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[10:8]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBC</name>
              <description>Tx Buffer Configuration</description>
              <addressOffset>0xC0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>TBSA</name>
                  <description>Tx Buffers Start Address
Start address of Tx Buffers section in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NDTB</name>
                  <description>Number of Dedicated Transmit Buffers
0= No Dedicated Tx Buffers
1-32= Number of Dedicated Tx Buffers
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQS</name>
                  <description>Transmit FIFO/Queue Size
0= No Tx FIFO/Queue
1-32= Number of Tx Buffers used for Tx FIFO/Queue
32= Values greater than 32 are interpreted as 32</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TFQM</name>
                  <description>Tx FIFO/Queue Mode
0= Tx FIFO operation
1= Tx Queue operation</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXFQS</name>
              <description>Tx FIFO/Queue Status</description>
              <addressOffset>0xC4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F1F3F</resetMask>
              <fields>
                <field>
                  <name>TFFL</name>
                  <description>Tx FIFO Free Level
Number of consecutive free Tx FIFO elements starting from TFGI, range 0 to 32. Read as zero when
Tx Queue operation is configured (TXBC.TFQM = '1')</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFGI</name>
                  <description>Tx FIFO Get Index
Tx FIFO read index pointer, range 0 to 31. Read as zero when Tx Queue operation is configured
TXBC.TFQM = '1').</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQPI</name>
                  <description>Tx FIFO/Queue Put Index
Tx FIFO/Queue write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TFQF</name>
                  <description>Tx FIFO/Queue Full
0= Tx FIFO/Queue not full
1= Tx FIFO/Queue full</description>
                  <bitRange>[21:21]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXESC</name>
              <description>Tx Buffer Element Size Configuration</description>
              <addressOffset>0xC8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7</resetMask>
              <fields>
                <field>
                  <name>TBDS</name>
                  <description>Tx Buffer Data Field Size
000= 8 byte data field
001= 12 byte data field
010= 16 byte data field
011= 20 byte data field
100= 24 byte data field
101= 32 byte data field
110= 48 byte data field
111= 64 byte data field</description>
                  <bitRange>[2:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBRP</name>
              <description>Tx Buffer Request Pending</description>
              <addressOffset>0xCC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TRP</name>
                  <description>Transmission Request Pending
Each Tx Buffer has its own Transmission Request Pending bit. The bits are set via register TXBAR.
The bits are reset after a requested transmission has completed or has been cancelled via register
TXBCR.
TXBRP bits are set only for those Tx Buffers configured via TXBC. After a TXBRP bit has been set,
a Tx scan (see Section 3.5, Tx Handling) is started to check for the pending Tx request with the
highest priority (Tx Buffer with lowest Message ID).
A cancellation request resets the corresponding transmission request pending bit of register
TXBRP. In case a transmission has already been started when a cancellation is requested, this is
done at the end of the transmission, regardless whether the transmission was successful or not. The
cancellation request bits are reset directly after the corresponding TXBRP bit has been reset.
After a cancellation has been requested, a finished cancellation is signaled via TXBCF
after successful transmission together with the corresponding TXBTO bit
when the transmission has not yet been started at the point of cancellation
when the transmission has been aborted due to lost arbitration
when an error occurred during frame transmission
In DAR mode all transmissions are automatically cancelled if they are not successful. The
corresponding TXBCF bit is set for all unsuccessful transmissions.
0= No transmission request pending
1= Transmission request pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBAR</name>
              <description>Tx Buffer Add Request</description>
              <addressOffset>0xD0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>AR</name>
                  <description>Add Request
Each Tx Buffer has its own Add Request bit. Writing a '1' will set the corresponding Add Request
bit; writing a '0' has no impact. This enables the Host to set transmission requests for multiple Tx
Buffers with one write to TXBAR. TXBAR bits are set only for those Tx Buffers configured via TXBC.
When no Tx scan is running, the bits are reset immediately, else the bits remain set until the Tx scan
process has completed.
0= No transmission request added
1= Transmission requested added</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCR</name>
              <description>Tx Buffer Cancellation Request</description>
              <addressOffset>0xD4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CR</name>
                  <description>Cancellation Request
Each Tx Buffer has its own Cancellation Request bit. Writing a '1' will set the corresponding
Cancellation Request bit; writing a '0' has no impact. This enables the Host to set cancellation
requests for multiple Tx Buffers with one write to TXBCR. TXBCR bits are set only for those Tx
Buffers configured via TXBC. The bits remain set until the corresponding bit of TXBRP is reset.
0= No cancellation pending
1= Cancellation pending</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTO</name>
              <description>Tx Buffer Transmission Occurred</description>
              <addressOffset>0xD8</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TO</name>
                  <description>Transmission Occurred
Each Tx Buffer has its own Transmission Occurred bit. The bits are set when the corresponding
TXBRP bit is cleared after a successful transmission. The bits are reset when a new transmission
is requested by writing a '1' to the corresponding bit of register TXBAR.
0= No transmission occurred
1= Transmission occurred</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCF</name>
              <description>Tx Buffer Cancellation Finished</description>
              <addressOffset>0xDC</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CF</name>
                  <description>Cancellation Finished
Each Tx Buffer has its own Cancellation Finished bit. The bits are set when the corresponding
TXBRP bit is cleared after a cancellation was requested via TXBCR. In case the corresponding
TXBRP bit was not set at the point of cancellation, CF is set immediately. The bits are reset when a
new transmission is requested by writing a '1' to the corresponding bit of register TXBAR.
0= No transmit buffer cancellation
1= Transmit buffer cancellation finished</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBTIE</name>
              <description>Tx Buffer Transmission Interrupt Enable</description>
              <addressOffset>0xE0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TIE</name>
                  <description>Transmission Interrupt Enable
Each Tx Buffer has its own Transmission Interrupt Enable bit.
0= Transmission interrupt disabled
1= Transmission interrupt enable</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXBCIE</name>
              <description>Tx Buffer Cancellation Finished Interrupt Enable</description>
              <addressOffset>0xE4</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>CFIE</name>
                  <description>Cancellation Finished Interrupt Enable
Each Tx Buffer has its own Cancellation Finished Interrupt Enable bit.
0= Cancellation finished interrupt disabled
1= Cancellation finished interrupt enabled</description>
                  <bitRange>[31:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFC</name>
              <description>Tx Event FIFO Configuration</description>
              <addressOffset>0xF0</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x3F3FFFFC</resetMask>
              <fields>
                <field>
                  <name>EFSA</name>
                  <description>Event FIFO Start Address
Start address of Tx Event FIFO in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFS</name>
                  <description>Event FIFO Size
0= Tx Event FIFO disabled
1-32= Number of Tx Event FIFO elements
32= Values greater than 32 are interpreted as 32
The Tx Event FIFO elements are indexed from 0 to EFS-1</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EFWM</name>
                  <description>Event FIFO Watermark
0= Watermark interrupt disabled
1-32= Level for Tx Event FIFO watermark interrupt (IR.TEFW)
32= Watermark interrupt disabled</description>
                  <bitRange>[29:24]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFS</name>
              <description>Tx Event FIFO Status</description>
              <addressOffset>0xF4</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x31F1F3F</resetMask>
              <fields>
                <field>
                  <name>EFFL</name>
                  <description>Event FIFO Fill Level
Number of elements stored in Tx Event FIFO, range 0 to 32.</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFGI</name>
                  <description>Event FIFO Get Index
Tx Event FIFO read index pointer, range 0 to 31.</description>
                  <bitRange>[12:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFPI</name>
                  <description>Event FIFO Put Index
Tx Event FIFO write index pointer, range 0 to 31.</description>
                  <bitRange>[20:16]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>EFF</name>
                  <description>Event FIFO Full
0= Tx Event FIFO not full
1= Tx Event FIFO full</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TEFL</name>
                  <description>Tx Event FIFO Element Lost
This bit is a copy of interrupt flag IR.TEFL. When IR.TEFL is reset, this bit is also reset.
0= No Tx Event FIFO element lost
1= Tx Event FIFO element lost, also set after write attempt to Tx Event FIFO of size zero.</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TXEFA</name>
              <description>Tx Event FIFO Acknowledge</description>
              <addressOffset>0xF8</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x1F</resetMask>
              <fields>
                <field>
                  <name>EFAI</name>
                  <description>Event FIFO Acknowledge Index
After the Host has read an element or a sequence of elements from the Tx Event FIFO it has to write
the index of the last element read from Tx Event FIFO to EFAI. This will set the Tx Event FIFO Get
Index TXEFS.EFGI to EFAI + 1 and update the Event FIFO Fill Level TXEFS.EFFL.</description>
                  <bitRange>[4:0]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMC</name>
              <description>TT Trigger Memory Configuration</description>
              <addressOffset>0x100</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFFC</resetMask>
              <fields>
                <field>
                  <name>TMSA</name>
                  <description>Trigger Memory Start Address
Start address of Trigger Memory in Message RAM (32-bit word address, see Figure 2).</description>
                  <bitRange>[15:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TME</name>
                  <description>Trigger Memory Elements
0= No Trigger Memory
1-64= Number of Trigger Memory elements
64= Values greater than 64 are interpreted as 64</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTRMC</name>
              <description>TT Reference Message Configuration</description>
              <addressOffset>0x104</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xDFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>RID</name>
                  <description>Reference Identifier
Identifier transmitted with reference message and used for reference message filtering. Standard or
extended reference identifier depending on bit XTD. A standard identifier has to be written to
ID[28:18].</description>
                  <bitRange>[28:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>XTD</name>
                  <description>Extended Identifier
0= 11-bit standard identifier
1= 29-bit extended identifier</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RMPS</name>
                  <description>Reference Message Payload Select
Ignored in case of time slaves.
0= Reference message has no additional payload
1= The following elements are taken from Tx Buffer 0:
Message Marker MM, Event FIFO Control EFC, Data Length Code DLC, Data Bytes DB
Level 1: bytes 2-8, Level 0,2: bytes 5-8)</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCF</name>
              <description>TT Operation Configuration</description>
              <addressOffset>0x108</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x7FFFFFB</resetMask>
              <fields>
                <field>
                  <name>OM</name>
                  <description>Operation Mode
00= Event-driven CAN communication, default
01= TTCAN level 1
10= TTCAN level 2
11= TTCAN level 0</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GEN</name>
                  <description>Gap Enable
0= Strictly time-triggered operation
1= External event-synchronized time-triggered operation</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TM</name>
                  <description>Time Master
0= Time Master function disabled
1= Potential Time Master</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LDSDL</name>
                  <description>LD of Synchronization Deviation Limit
The Synchronization Deviation Limit SDL is configured by its dual logarithm LDSDL with SDL =
2(LDSDL + 5). It should not exceed the clock tolerance given by the CAN bit timing configuration.
0x0-7 LD of Synchronization Deviation Limit (SDL &lt;= 32...4096)</description>
                  <bitRange>[7:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IRTO</name>
                  <description>Initial Reference Trigger Offset
0x00-7F Positive offset, range from 0 to 127</description>
                  <bitRange>[14:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EECS</name>
                  <description>Enable External Clock Synchronization
If enabled, TUR configuration (TURCF.NCL only) may be updated during TTCAN operation.
0= External clock synchronization in TTCAN Level 0,2 disabled
1= External clock synchronization in TTCAN Level 0,2 enabled</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL</name>
                  <description>Application Watchdog Limit
The application watchdog can be disabled by programming AWL to 0x00.
0x00-FF Maximum time after which the application has to serve the application watchdog.
The application watchdog is incremented once each 256 NTUs.</description>
                  <bitRange>[23:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EGTF</name>
                  <description>Enable Global Time Filtering
0= Global time filtering in TTCAN Level 0,2 is disabled
1= Global time filtering in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[24:24]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECC</name>
                  <description>Enable Clock Calibration
0= Automatic clock calibration in TTCAN Level 0,2 is disabled
1= Automatic clock calibration in TTCAN Level 0,2 is enabled</description>
                  <bitRange>[25:25]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>EVTP</name>
                  <description>Event Trigger Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[26:26]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTMLM</name>
              <description>TT Matrix Limits</description>
              <addressOffset>0x10C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFF0FFF</resetMask>
              <fields>
                <field>
                  <name>CCM</name>
                  <description>N/A</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSS</name>
                  <description>N/A</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXEW</name>
                  <description>Tx Enable Window
0x0-F Length of Tx enable window, 1-16 NTU cycles</description>
                  <bitRange>[11:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ENTT</name>
                  <description>Expected Number of Tx Triggers
0x000-FFF Expected number of Tx Triggers in one Matrix Cycle</description>
                  <bitRange>[27:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURCF</name>
              <description>TUR Configuration</description>
              <addressOffset>0x110</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x10000000</resetValue>
              <resetMask>0xBFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>NCL</name>
                  <description>Numerator Configuration Low
Write access to the TUR Numerator Configuration Low is only possible during configuration with
TURCF.ELT = '0' or if TTOCF.EECS (external clock synchronization enabled) is set. When a new
value for NCL is written outside TT Configuration Mode, the new value takes effect when
TTOST.WECS is cleared to '0'. NCL is locked TTOST.WECS is '1'.
0x0000-FFFF Numerator Configuration Low</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>DC</name>
                  <description>Denominator Configuration
0x0000 Illegal value
0x0001-3FFF Denominator Configuration</description>
                  <bitRange>[29:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELT</name>
                  <description>Enable Local Time
0= Local time is stopped, default
1= Local time is enabled</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOCN</name>
              <description>TT Operation Control</description>
              <addressOffset>0x114</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xBFFF</resetMask>
              <fields>
                <field>
                  <name>SGT</name>
                  <description>Set Global time
Writing a '1' to SGT sets TTOST.WGDT if the node is the actual Time Master. SGT is reset after one
Host clock period. The global time preset takes effect when the node transmits the next reference
message with the Master_Ref_Mark modified by the preset value written to TTGTP.</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ECS</name>
                  <description>External Clock Synchronization
Writing a '1' to ECS sets TTOST.WECS if the node is the actual Time Master. ECS is reset after one
Host clock period. The external clock synchronization takes effect at the start of the next basic cycle.</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWP</name>
                  <description>Stop Watch Polarity
0= Rising edge trigger
1= Falling edge trigger</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWS</name>
                  <description>Stop Watch Source
00= Stop Watch disabled
01= Actual value of cycle time is copied to TTCPT.SWV
10= Actual value of local time is copied to TTCPT.SWV
11= Actual value of global time is copied to TTCPT.SWV</description>
                  <bitRange>[4:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTIE</name>
                  <description>Register Time Mark Interrupt Pulse Enable
Register time mark interrupts are configured by register TTTMK. A register time mark interrupt pulse
with the length of one NTU is generated when the time referenced by TTOCN.TMC (cycle, local, or
global) equals TTTMK.TM, independent of the synchronization state.
0= Register Time Mark Interrupt output m_ttcan_rtp disabled
1= Register Time Mark Interrupt output m_ttcan_rtp enabled</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMC</name>
                  <description>Register Time Mark Compare
00= No Register Time Mark Interrupt generated
01= Register Time Mark Interrupt if Time Mark = cycle time
10= Register Time Mark Interrupt if Time Mark = local time
11= Register Time Mark Interrupt if Time Mark = global time</description>
                  <bitRange>[7:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTIE</name>
                  <description>Trigger Time Mark Interrupt Pulse Enable
External time mark events are configured by trigger memory element TMEX (see Section 2.4.7). A
trigger time mark interrupt pulse is generated when the trigger memory element becomes active,
and the M_TTCAN is in synchronization state In_Schedule or In_Gap.
0= Trigger Time Mark Interrupt output m_ttcan_tmp disabled
1= Trigger Time Mark Interrupt output m_ttcan_tmp enabled</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GCS</name>
                  <description>Gap Control Select
0= Gap control independent from m_ttcan_evt
1= Gap control by input pin m_ttcan_evt</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>FGP</name>
                  <description>Finish Gap
Set by the CPU, reset by each reference message
0= No reference message requested
1= Application requested start of reference message</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TMG</name>
                  <description>Time Mark Gap
0= Reset by each reference message
1= Next reference message started when Register Time Mark interrupt TTIR.RTMI is activated</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>NIG</name>
                  <description>Next is Gap
This bit can only be set when the M_TTCAN is the actual Time Master and when it is configured for
external event-synchronized time-triggered operation (TTOCF.GEN = '1')
0= No action, reset by reception of any reference message
1= Transmit next reference message with Next_is_Gap = '1'</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ESCN</name>
                  <description>External Synchronization Control
If enabled the M_TTCAN synchronizes its cycle time phase to an external event signaled by a rising
edge at pin m_ttcan_evt (see Section 4.11).
0= External synchronization disabled
1= External synchronization enabled</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKC</name>
                  <description>TT Operation Control Register Locked
Set by a write access to register TTOCN. Reset when the updated configuration has been
synchronized into the CAN clock domain.
0= Write access to TTOCN enabled
1= Write access to TTOCN locked</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTGTP</name>
              <description>TT Global Time Preset</description>
              <addressOffset>0x118</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>TP</name>
                  <description>N/A</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CTP</name>
                  <description>Cycle Time Target Phase
CTP is write-protected while TTOCN.ESCN or TTOST.SPL are set (see Section 4.11).
0x0000-FFFF Defines target value of cycle time when a rising edge of m_ttcan_evt is expected</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTTMK</name>
              <description>TT Time Mark</description>
              <addressOffset>0x11C</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x807FFFFF</resetMask>
              <fields>
                <field>
                  <name>TM_</name>
                  <description>Time Mark
0x0000-FFFF Time Mark</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TICC</name>
                  <description>Time Mark Cycle Code
Cycle count for which the time mark is valid.
0b000000x valid for all cycles
0b000001c valid every second cycle at cycle count mod2 = c
0b00001cc valid every fourth cycle at cycle count mod4 = cc
0b0001ccc valid every eighth cycle at cycle count mod8 = ccc
0b001cccc valid every sixteenth cycle at cycle count mod16 = cccc
0b01ccccc valid every thirty-second cycle at cycle count mod32 = ccccc
0b1cccccc valid every sixty-fourth cycle at cycle count mod64 = cccccc</description>
                  <bitRange>[22:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>LCKM</name>
                  <description>TT Time Mark Register Locked
Always set by a write access to registers TTOCN. Set by write access to register TTTMK when
TTOCN.TMC != '00'. Reset when the registers have been synchronized into the CAN clock domain.
0= Write access to TTTMK enabled
1= Write access to TTTMK locked</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIR</name>
              <description>TT Interrupt Register</description>
              <addressOffset>0x120</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBC</name>
                  <description>Start of Basic Cycle
0= No Basic Cycle started since bit has been reset
1= Basic Cycle started</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMC</name>
                  <description>Start of Matrix Cycle
0= No Matrix Cycle started since bit has been reset
1= Matrix Cycle started</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSM_</name>
                  <description>Change of Synchronization Mode
0= No change in master to slave relation or schedule synchronization
1= Master to slave relation or schedule synchronization changed,
also set when TTOST.SPL is reset</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOG</name>
                  <description>Start of Gap
0= No reference message seen with Next_is_Gap bit set
1= Reference message with Next_is_Gap bit set becomes valid</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMI</name>
                  <description>Register Time Mark Interrupt
Set when time referenced by TTOCN.TMC (cycle, local, or global) equals TTTMK.TM, independent
of the synchronization state.
0= Time mark not reached
1= Time mark reached</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMI</name>
                  <description>Trigger Time Mark Event Internal
Internal time mark events are configured by trigger memory element TMIN (see Section 2.4.7). Set
when the trigger memory element becomes active, and the M_TTCAN is in synchronization state
In_Gap or In_Schedule.
0= Time mark not reached
1= Time mark reached (Level 0: cycle time TTOCF.IRTO * 0x200)</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWE</name>
                  <description>Stop Watch Event
0= No rising/falling edge at stop watch trigger pin m_ttcan_swt detected
1= Rising/falling edge at stop watch trigger pin m_ttcan_swt detected</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTW</name>
                  <description>Global Time Wrap
0= No global time wrap occurred
1= Global time wrap from 0xFFFF to 0x0000 occurred</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTD</name>
                  <description>Global Time Discontinuity
0= No discontinuity of global time
1= Discontinuity of global time</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTE</name>
                  <description>Global Time Error
Synchronization deviation SD exceeds limit specified by TTOCF.LDSDL, TTCAN Level 0,2 only.
0= Synchronization deviation within limit
1= Synchronization deviation exceeded limit</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXU</name>
                  <description>Tx Count Underflow
0= Number of Tx Trigger as expected
1= Less Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXO</name>
                  <description>Tx Count Overflow
0= Number of Tx Trigger as expected
1= More Tx trigger than expected in one matrix cycle</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1</name>
                  <description>Scheduling Error 1
0= No scheduling error 1
1= Scheduling error 1 occurred</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2</name>
                  <description>Scheduling Error 2
0= No scheduling error 2
1= Scheduling error 2 occurred</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELC</name>
                  <description>Error Level Changed
Not set when error level changed during initialization.
0= No change in error level
1= Error level changed</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWT</name>
                  <description>Initialization Watch Trigger
The initialization is restarted by resetting IWT.
0= No missing reference message during system startup
1= No system startup due to missing reference message</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WT</name>
                  <description>Watch Trigger
0= No missing reference message
1= Missing reference message (Level 0: cycle time 0xFF00)</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AW</name>
                  <description>Application Watchdog
0= Application watchdog served in time
1= Application watchdog not served in time</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CER</name>
                  <description>Configuration Error
Trigger out of order.
0= No error found in trigger list
1= Error found in trigger list</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTIE</name>
              <description>TT Interrupt Enable</description>
              <addressOffset>0x124</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCE</name>
                  <description>Start of Basic Cycle Interrupt Enable</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCE</name>
                  <description>Start of Matrix Cycle Interrupt Enable</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSME</name>
                  <description>Change of Synchronization Mode Interrupt Enable</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGE</name>
                  <description>Start of Gap Interrupt Enable</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIE</name>
                  <description>Register Time Mark Interrupt Enable</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIE</name>
                  <description>Trigger Time Mark Event Internal Enable</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEE</name>
                  <description>Stop Watch Event Interrupt Enable</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWE</name>
                  <description>Global Time Wrap Interrupt Enable</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDE</name>
                  <description>Global Time Discontinuity Interrupt Enable</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEE</name>
                  <description>Global Time Error Interrupt Enable</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUE</name>
                  <description>Tx Count Underflow Interrupt Enable</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOE</name>
                  <description>Tx Count Overflow Interrupt Enable</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1E</name>
                  <description>Scheduling Error 1 Interrupt Enable</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2E</name>
                  <description>Scheduling Error 2 Interrupt Enable</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCE</name>
                  <description>Change Error Level Interrupt Enable</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTE</name>
                  <description>Initialization Watch Trigger Interrupt Enable</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTE</name>
                  <description>Watch Trigger Interrupt Enable</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWE_</name>
                  <description>Application Watchdog Interrupt Enable</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERE</name>
                  <description>Configuration Error Interrupt Enable</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTILS</name>
              <description>TT Interrupt Line Select</description>
              <addressOffset>0x128</addressOffset>
              <size>32</size>
              <access>read-write</access>
              <resetValue>0x0</resetValue>
              <resetMask>0x7FFFF</resetMask>
              <fields>
                <field>
                  <name>SBCL</name>
                  <description>Start of Basic Cycle Interrupt Line</description>
                  <bitRange>[0:0]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SMCL</name>
                  <description>Start of Matrix Cycle Interrupt Line</description>
                  <bitRange>[1:1]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CSML</name>
                  <description>Change of Synchronization Mode Interrupt Line</description>
                  <bitRange>[2:2]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SOGL</name>
                  <description>Start of Gap Interrupt Line</description>
                  <bitRange>[3:3]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>RTMIL</name>
                  <description>Register Time Mark Interrupt Line</description>
                  <bitRange>[4:4]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TTMIL</name>
                  <description>Trigger Time Mark Event Internal Line</description>
                  <bitRange>[5:5]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SWEL</name>
                  <description>Stop Watch Event Interrupt Line</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTWL</name>
                  <description>Global Time Wrap Interrupt Line</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTDL</name>
                  <description>Global Time Discontinuity Interrupt Line</description>
                  <bitRange>[8:8]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>GTEL</name>
                  <description>Global Time Error Interrupt Line</description>
                  <bitRange>[9:9]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXUL</name>
                  <description>Tx Count Underflow Interrupt Line</description>
                  <bitRange>[10:10]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>TXOL</name>
                  <description>Tx Count Overflow Interrupt Line</description>
                  <bitRange>[11:11]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE1L</name>
                  <description>Scheduling Error 1 Interrupt Line</description>
                  <bitRange>[12:12]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>SE2L</name>
                  <description>Scheduling Error 2 Interrupt Line</description>
                  <bitRange>[13:13]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>ELCL</name>
                  <description>Change Error Level Interrupt Line</description>
                  <bitRange>[14:14]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>IWTL</name>
                  <description>Initialization Watch Trigger Interrupt Line</description>
                  <bitRange>[15:15]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>WTL</name>
                  <description>Watch Trigger Interrupt Line</description>
                  <bitRange>[16:16]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>AWL_</name>
                  <description>Application Watchdog Interrupt Line</description>
                  <bitRange>[17:17]</bitRange>
                  <access>read-write</access>
                </field>
                <field>
                  <name>CERL</name>
                  <description>Configuration Error Interrupt Line</description>
                  <bitRange>[18:18]</bitRange>
                  <access>read-write</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTOST</name>
              <description>TT Operation Status</description>
              <addressOffset>0x12C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFC0FFFF</resetMask>
              <fields>
                <field>
                  <name>EL</name>
                  <description>Error Level
00= Severity 0 - No Error
01= Severity 1 - Warning
10= Severity 2 - Error
11= Severity 3 - Severe Error</description>
                  <bitRange>[1:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>MS</name>
                  <description>Master State
00= Master_Off, no master properties relevant
01= Operating as Time Slave
10= Operating as Backup Time Master
11= Operating as current Time Master</description>
                  <bitRange>[3:2]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SYS</name>
                  <description>Synchronization State
00= Out of Synchronization
01= Synchronizing to TTCAN communication
10= Schedule suspended by Gap (In_Gap)
11= Synchronized to schedule (In_Schedule)</description>
                  <bitRange>[5:4]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QGTP</name>
                  <description>Quality of Global Time Phase
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '0'.
0= Global time not valid
1= Global time in phase with Time Master</description>
                  <bitRange>[6:6]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>QCS</name>
                  <description>Quality of Clock Speed
Only relevant in TTCAN Level 0 and Level 2, otherwise fixed to '1'.
0= Local clock speed not synchronized to Time Master clock speed
1= Synchronization Deviation &lt;= SDL</description>
                  <bitRange>[7:7]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>RTO</name>
                  <description>Reference Trigger Offset
The Reference Trigger Offset value is a signed integer with a range from -127 (0x81) to 127 (0x7F).
There is no notification when the lower limit of -127 is reached. In case the M_TTCAN becomes
Time Master (MS[1:0] = '11'), the reset of RTO is delayed due to synchronization between Host and
CAN clock domain. For time slaves the value configured by TTOCF.IRTO is read.
0x00-FF Actual Reference Trigger offset value</description>
                  <bitRange>[15:8]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WGTD</name>
                  <description>Wait for Global Time Discontinuity
0= No global time preset pending
1= Node waits for the global time preset to take effect. The bit is reset when the node has transmitted
a reference message with Disc_Bit = '1' or after it received a reference message.</description>
                  <bitRange>[22:22]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GFI</name>
                  <description>Gap Finished Indicator
Set when the CPU writes TTOCN.FGP, or by a time mark interrupt if TMG = '1', or via input pin
m_ttcan_evt if TTOCN.GCS = '1'. Not set by Ref_Trigger_Gap or when Gap is finished by another
node sending a reference message.
0= Reset at the end of each reference message
1= Gap finished by M_TTCAN</description>
                  <bitRange>[23:23]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>TMP</name>
                  <description>Time Master Priority
0x0-7 Priority of actual Time Master</description>
                  <bitRange>[26:24]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GSI</name>
                  <description>Gap Started Indicator
0= No Gap in schedule, reset by each reference message and for all time slaves
1= Gap time after Basic Cycle has started</description>
                  <bitRange>[27:27]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WFE</name>
                  <description>Wait for Event
0= No Gap announced, reset by a reference message with Next_is_Gap = '0'
1= Reference message with Next_is_Gap = '1' received</description>
                  <bitRange>[28:28]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>AWE</name>
                  <description>Application Watchdog Event
The application watchdog is served by reading TTOST. When the watchdog is not served in time,
bit AWE is set, all TTCAN communication is stopped, and the M_TTCAN is set into Bus Monitoring
Mode.
0= Application Watchdog served in time
1= Failed to serve Application Watchdog in time</description>
                  <bitRange>[29:29]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>WECS</name>
                  <description>Wait for External Clock Synchronization
0= No external clock synchronization pending
1= Node waits for external clock synchronization to take effect. The bit is reset at the start of the
next basic cycle.</description>
                  <bitRange>[30:30]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SPL</name>
                  <description>Schedule Phase Lock
The bit is valid only when external synchronization is enabled (TTOCN.ESCN = '1'). In this case it
signals that the difference between cycle time configured by TTGTP.CTP and the cycle time at the
rising edge at pin m_ttcan_evt is less or equal 9 NTU (see Section 4.11).
0= Phase outside range
1= Phase inside range</description>
                  <bitRange>[31:31]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TURNA</name>
              <description>TUR Numerator Actual</description>
              <addressOffset>0x130</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x10000</resetValue>
              <resetMask>0x3FFFF</resetMask>
              <fields>
                <field>
                  <name>NAV</name>
                  <description>N/A</description>
                  <bitRange>[17:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTLGT</name>
              <description>TT Local &amp; Global Time</description>
              <addressOffset>0x134</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFFFFFF</resetMask>
              <fields>
                <field>
                  <name>LT</name>
                  <description>Local Time
Non-fractional part of local time, incremented once each local NTU (see Section 4.5).
0x0000-FFFF Local time value of TTCAN node</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>GT</name>
                  <description>Global Time
Non-fractional part of the sum of the node's local time and its local offset (see Section 4.5).
0x0000-FFFF Global time value of TTCAN network</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCTC</name>
              <description>TT Cycle Time &amp; Count</description>
              <addressOffset>0x138</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x3F0000</resetValue>
              <resetMask>0x3FFFFF</resetMask>
              <fields>
                <field>
                  <name>CT</name>
                  <description>Cycle Time
Non-fractional part of the difference of the node's local time and Ref_Mark (see Section 4.5).
0x0000-FFFF Cycle time value of TTCAN Basic Cycle</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>CC</name>
                  <description>Cycle Count
0x00-3F Number of actual Basic Cycle in the System Matrix</description>
                  <bitRange>[21:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCPT</name>
              <description>TT Capture Time</description>
              <addressOffset>0x13C</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF003F</resetMask>
              <fields>
                <field>
                  <name>CCV</name>
                  <description>Cycle Count Value
Cycle count value captured together with SWV.
0x00-3F Captured cycle count value</description>
                  <bitRange>[5:0]</bitRange>
                  <access>read-only</access>
                </field>
                <field>
                  <name>SWV</name>
                  <description>Stop Watch Value
On a rising/falling edge (as configured via TTOCN.SWP) at the Stop Watch Trigger pin m_ttcan_swt, when TTOCN.SWS is != '00' and TTIR.SWE is '0', the actual time value as selected
by TTOCN.SWS (cycle, local, global) is copied to SWV and TTIR.SWE will be set to '1'. Capturing of the next stop watch value is enabled by resetting TTIR.SWE.
0x0000-FFFF Captured Stop Watch value</description>
                  <bitRange>[31:16]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
            <register>
              <name>TTCSM</name>
              <description>TT Cycle Sync Mark</description>
              <addressOffset>0x140</addressOffset>
              <size>32</size>
              <access>read-only</access>
              <resetValue>0x0</resetValue>
              <resetMask>0xFFFF</resetMask>
              <fields>
                <field>
                  <name>CSM</name>
                  <description>Cycle Sync Mark
The Cycle Sync Mark is measured</description>
                  <bitRange>[15:0]</bitRange>
                  <access>read-only</access>
                </field>
              </fields>
            </register>
          </cluster>
          <register>
            <name>RXFTOP_CTL</name>
            <description>Receive FIFO Top control</description>
            <addressOffset>0x180</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>F0TPE</name>
                <description>FIFO 0 Top Pointer Enable. 
This enables the FIFO top pointer logic to set the FIFO Top Address (FnTA) and message word counter.
This logic is also disabled when the IP is being reconfigured (CCCR.CCE=1).
When this logic is disabled a Read from RXFTOP0_DATA is undefined.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>F1TPE</name>
                <description>FIFO 1 Top Pointer Enable.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_STAT</name>
            <description>Receive FIFO 0 Top Status</description>
            <addressOffset>0x1A0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F0TA</name>
                <description>Current FIFO 0 Top Address.
This is a pointer to the next word in the message buffer defined by the FIFO Start Address (FnSA), Get Index (FnGI), the FIFO message size (FnDS) and the message word counter (FnMWC)
FnTA = FnSA + FnGI * msg_size[FnDS] + FnMWC</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP0_DATA</name>
            <description>Receive FIFO 0 Top Data</description>
            <addressOffset>0x1A8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F0TD</name>
                <description>When enabled (F0TPE=1) read data from MRAM at location FnTA. This register can have a read side effect if the following conditions are met:
- M_TTCAN not being reconfigured (CCCR.CCE=0)
- FIFO Top Pointer logic is enabled (FnTPE=1)
- FIFO is not empty (FnFL!=0)
The read side effect is as follows:
- if FnMWC pointed to the last word of the message (as indicated by FnDS) then the corresponding message index (FnGI) is automatically acknowledge by a write to FnAI
- FnMWC is incremented (or restarted if FnMWC pointed to the last word of the message)
- the FIFO top address FnTA is incremented (with FIFO wrap around) 
When this logic is disabled (F0TPE=0) a Read from this register returns undefined data.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_STAT</name>
            <description>Receive FIFO 1 Top Status</description>
            <addressOffset>0x1B0</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>F1TA</name>
                <description>See F0TA description</description>
                <bitRange>[15:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXFTOP1_DATA</name>
            <description>Receive FIFO 1 Top Data</description>
            <addressOffset>0x1B8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>F1TD</name>
                <description>See F0TD description</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>CTL</name>
          <description>Global CAN control register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x800000FF</resetMask>
          <fields>
            <field>
              <name>STOP_REQ</name>
              <description>Clock Stop Request for each TTCAN IP .
The m_ttcan_clkstop_req of each TTCAN IP is directly driven by these bits.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MRAM_OFF</name>
              <description>MRAM off
0= Default MRAM on (with MRAM retained in DeepSleep).
1= Switch MRAM off (not retained) to save power. Before setting this bit all the CAN channels have to be powered down using the STOP_REQ/ACK bits.
When the MRAM is off any access attempt to it is considered an address error (as if MRAM_SIZE=0).
After switching the MRAM on again software needs to allow for a certain power up time before MRAM can be used, i.e. before STOP_REQ can be de-asserted. The power up time is equivalent to the system SRAM power up time specified in the CPUSS.RAM_PWR_DELAY_CTL register.

To meet S8 platform requirements, MRAM_OFF should be set to 0 prior to transitioning to Hibernate mode.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Global CAN status register</description>
          <addressOffset>0x1004</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>STOP_ACK</name>
              <description>Clock Stop Acknowledge for each TTCAN IP.
These bits are directly driven by m_ttcan_clkstop_ack of each TTCAN IP.
When this bit is set the corresponding TTCAN IP clocks will be gated off, except HCLK will enabled for each AHB write</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR0_CAUSE</name>
          <description>Consolidated interrupt0 cause register</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT0</name>
              <description>Show pending m_ttcan_int0 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR1_CAUSE</name>
          <description>Consolidated interrupt1 cause register</description>
          <addressOffset>0x1014</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>INT1</name>
              <description>Show pending m_ttcan_int1 of each channel</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CTL</name>
          <description>Time Stamp control register</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Time Stamp counter prescale value. 
When enabled divide the Host clock (HCLK) by PRESCALE+1 to create Time Stamp clock ticks.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Counter enable bit
0 = Count disabled. Stop counting up and keep the counter value
1 = Count enabled. Start counting up from the current value</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TS_CNT</name>
          <description>Time Stamp counter value</description>
          <addressOffset>0x1024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>VALUE</name>
              <description>The counter value of the Time Stamp Counter.
When enabled this counter will count Time Stamp clock ticks from the pre-scaler.
When written this counter and the pre-scaler will reset to 0 (write data is ignored).</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_CTL</name>
          <description>ECC control</description>
          <addressOffset>0x1080</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10000</resetMask>
          <fields>
            <field>
              <name>ECC_EN</name>
              <description>Enable ECC for CANFD SRAM
When disabled also all error injection functionality is disabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_ERR_INJ</name>
          <description>ECC error injection</description>
          <addressOffset>0x1084</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFC</resetValue>
          <resetMask>0x7F10FFFC</resetMask>
          <fields>
            <field>
              <name>ERR_ADDR</name>
              <description>Specifies the address of the word where an error will be injected on write or an non-correctable error will be suppressed.
When the ERR_EN bit is set an error parity (ERR_PAR) is injected when any write, from bus or a CAN channel, is done to this address.
When the ERR_EN bit is set and the access address matches ERR_ADDR then a non-correctable ECC error or an Address error will NOT result in a bus error or CAN channel shutdown.
Note that error reporting to the fault structure cannot be suppressed.</description>
              <bitRange>[15:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_EN</name>
              <description>Enable error injection (ECC_EN must be 1).
When this bit is set the error parity (ERR_PAR) will be used when an AHB write is done to the ERR_ADDR address.
When the error word is read a single or double error will be reported to the fault structure just like for a real ECC error (even if this bit is no longer set).
When this bit is set (and ECC_EN=1) a non-correctable error (ECC or address error) for the ERR_ADDR will not be reported back to the CAN channel or  AHB bus.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ERR_PAR</name>
              <description>ECC Parity bits to use for ECC error injection at address ERR_ADDR.</description>
              <bitRange>[30:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2S0</name>
      <description>I2S registers</description>
      <headerStructName>I2S</headerStructName>
      <baseAddress>0x404F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>TX_ENABLED</name>
              <description>Enables the I2S TX component:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_ENABLED</name>
              <description>Enables the I2S RX component:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLOCK_CTL</name>
          <description>Clock control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x13F</resetMask>
          <fields>
            <field>
              <name>CLOCK_DIV</name>
              <description>Frequency divisor for generating I2S clock frequency.
The selected clock with CLOCK_SEL is divided by this. 
'0': Bypass
'1': 2 x
'2': 3 x
'3': 4 x
...
'62': 63 x
'63': 64 x</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLOCK_SEL</name>
              <description>Selects clock to be used by I2S:
'0': Internal clock ('clk_audio_i2s')
'1': External clock ('clk_i2s_if')</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>Command</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10101</resetMask>
          <fields>
            <field>
              <name>TX_START</name>
              <description>Transmitter enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PAUSE</name>
              <description>Pause enable:
'0': Disabled (TX FIFO data is sent over I2S).
'1': Enabled ('0' data is sent over I2S, instead of TX FIFO data).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_START</name>
              <description>Receiver enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL</name>
          <description>Trigger control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10001</resetMask>
          <fields>
            <field>
              <name>TX_REQ_EN</name>
              <description>Trigger output ('tr_i2s_tx_req') enable for requests of DMA transfer in transmission
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_REQ_EN</name>
              <description>Trigger output ('tr_i2s_rx_req') enable for requests of DMA transfer in reception
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTL</name>
          <description>Transmitter control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x440510</resetValue>
          <resetMask>0x37737F8</resetMask>
          <fields>
            <field>
              <name>B_CLOCK_INV</name>
              <description>Serial data transmission is advanced by 0.5 SCK cycles. This bit is valid only in TX slave mode.
When set to '1', the serial data will be transmitted 0.5 SCK cycles earlier than when set to '0'. 

1) TX_CTL.SCKI_POL=0 and TX_CTL.B_CLOCK_INV=0: Serial data will be transmitted off the SCK falling edge
2) TX_CTL.SCKI_POL=0 and TX_CTL.B_CLOCK_INV=1: Serial data will be transmitted off the SCK rising edge that is 0.5 SCK cycles before the SCK falling edge in 1)
3) TX_CTL.SCKI_POL=1 and TX_CTL.B_CLOCK_INV=0: Serial data will be transmitted off the SCK rising edge
4) TX_CTL.SCKI_POL=1 and TX_CTL.B_CLOCK_INV=1: Serial data will be transmitted off the SCK falling edge that is 0.5 SCK cycles before the SCK rising edge in 3)

(Note that this is only the appearance w.r.t. SCK edge, the actual timing is generated by an internal clock that runs 8x the SCK frequency). The word sync (TX_WS) signal is not affected by this bit setting. 
Note: When Master mode, must be '0'.
(Note: This bit is connected to AR38U12.TX_CFG.TX_BCLKINV)</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FALLING_EDGE_TX</name>
                  <description>SDO transmitted at SCK falling edge when TX_CTL.SCKI_POL=0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING_EDGE_TX</name>
                  <description>SDO transmitted at SCK rising edge when TX_CTL.SCKI_POL=0</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_NR</name>
              <description>Specifies number of channels per frame:

Note: only '2channels' is supported during Left Justfied or I2S mode. Hence software must set '1' to this field in the modes.
(Note: These bits are connected to AR38U12.TX_CFG.TX_CHSET)</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CH_NUM1</name>
                  <description>1 channel</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM2</name>
                  <description>2 channels</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM3</name>
                  <description>3 channels</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM4</name>
                  <description>4 channels</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM5</name>
                  <description>5 channels</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM6</name>
                  <description>6 channels</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM7</name>
                  <description>7 channels</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM8</name>
                  <description>8 channels</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MS</name>
              <description>Set interface in master or slave mode:

(Note: This bit is connected to AR38U12.TX_CFG.TX_MS)</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLAVE</name>
                  <description>Slave</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MASTER</name>
                  <description>Master</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_MODE</name>
              <description>Select I2S, left-justified or TDM:

(Note: These bits are connected to AR38U12.TX_CFG.TX_I2S_MODE)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEFT_JUSTIFIED</name>
                  <description>Left Justified</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S</name>
                  <description>I2S mode</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDM_A</name>
                  <description>TDM mode A, the 1st Channel align to WSO 
Rising Edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDM_B</name>
                  <description>TDM mode B, the 1st Channel align to WSO
Rising edge with1 SCK Delay</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WS_PULSE</name>
              <description>Set WS pulse width in TDM mode:

(Note: This bit is connected to AR38U12.TX_CFG.TX_WS_PULSE)
Note: When not TDM mode, must be '1'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SCK_PERIOD</name>
                  <description>Pulse width is 1 SCK period</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_LENGTH</name>
                  <description>Pulse width is 1 channel length</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OVHDATA</name>
              <description>Set overhead value:
'0': Set to '0'
'1': Set to '1'
(Note: This bit is connected to AR38U12.TX_CFG.TX_OVHDATA)</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WD_EN</name>
              <description>Set watchdog for 'tx_ws_in':
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_LEN</name>
              <description>Channel length in number of bits:

Note: 
- When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
- When TDM mode, must be 32-bit length to this field.
(Note: These bits are connected to AR38U12.TX_CFG.TX_CHLEN)</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT_LEN8</name>
                  <description>8-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN16</name>
                  <description>16-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN18</name>
                  <description>18-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN20</name>
                  <description>20-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN24</name>
                  <description>24-bit</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN32</name>
                  <description>32-bit</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WORD_LEN</name>
              <description>Word length in number of bits:

Note: 
- When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
- Don't configure this field as beyond Channel length.
(Note: These bits are connected to AR38U12.TX_CFG.TX_IWL)</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT_LEN8</name>
                  <description>8-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN16</name>
                  <description>16-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN18</name>
                  <description>18-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN20</name>
                  <description>20-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN24</name>
                  <description>24-bit</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN32</name>
                  <description>32-bit</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SCKO_POL</name>
              <description>TX master bit clock polarity. 
When this bit is 1, the outgoing tx_sck signal is inverted after it has been transmitted from the I2S transceiver core. This bit does not affect the internal serial data transmission timing. The word sync (TX_WS) signal is not affected by this bit setting. 
'0': When transmitter is in master mode, serial data is transmitted from the falling bit clock edge
'1': When transmitter is in master mode, serial data is transmitted from the rising bit clock edge</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCKI_POL</name>
              <description>TX slave bit clock polarity. 
When this bit is 1, the incoming tx_sck signal is inverted before it is received by the I2S transceiver core. This bit does not affect the internal serial data transmission timing. The word sync (TX_WS) signal is not affected by this bit setting. See TX_CTL.B_CLOCK_INV for more details.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_WATCHDOG</name>
          <description>Transmitter watchdog</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WD_COUNTER</name>
              <description>Start value of the TX watchdog. With the reset value of 0x0000:0000 the counter is disabled. This is clocked by the AHB-Lite system clock 'clk_sys'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTL</name>
          <description>Receiver control</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x440510</resetValue>
          <resetMask>0x3F727F8</resetMask>
          <fields>
            <field>
              <name>B_CLOCK_INV</name>
              <description>Serial data capture is delayed by 0.5 SCK cycles. This bit is valid only in RX master mode.
When set to '1', the serial data will be captured 0.5 SCK cycles later than when set to '0'.

1) RX_CTL.SCKO_POL=0 and RX_CTL.B_CLOCK_INV=0: Serial data will be captured by the SCK rising edge
2) RX_CTL.SCKO_POL=0 and RX_CTL.B_CLOCK_INV=1: Serial data will be captured by the SCK falling edge that is 0.5 SCK cycles after the SCK rising edge in 1)
3) RX_CTL.SCKO_POL=1 and RX_CTL.B_CLOCK_INV=0: Serial data will be captured by the SCK falling edge
4) RX_CTL.SCKO_POL=1 and RX_CTL.B_CLOCK_INV=1: Serial data will be captured by the SCK rising edge that is 0.5 SCK cycles after the SCK falling edge in 3)

(Note that this is only the appearance w.r.t. SCK edge, the actual capture timing is derived from an internal clock that runs 8x the SCK frequency). The word sync (RX_WS) signal is not affected by this bit setting. 
Note: When Slave mode, must be '0'.
(Note: This bit is connected to AR38U12.TX_CFG.RX_BCLKINV)</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RISING_EDGE_RX</name>
                  <description>SDI received at SCK rising edge when RX_CTL.SCKO_POL=0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING_EDGE_RX</name>
                  <description>SDI received at SCK falling edge when RX_CTL.SCKO_POL=0</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CH_NR</name>
              <description>Specifies number of channels per frame:

Note: only '2channels' is supported during Left Justfied or I2S mode. Hence software must set '1' to this field in the modes.
(Note: These bits are connected to AR38U12.RX_CFG.RX_CHSET)</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CH_NUM1</name>
                  <description>1 channel</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM2</name>
                  <description>2 channels</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM3</name>
                  <description>3 channels</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM4</name>
                  <description>4 channels</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM5</name>
                  <description>5 channels</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM6</name>
                  <description>6 channels</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM7</name>
                  <description>7 channels</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_NUM8</name>
                  <description>8 channels</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MS</name>
              <description>Set interface in master or slave mode:

(Note: This bit is connected to AR38U12.TX_CFG.RX_MS)</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLAVE</name>
                  <description>Slave</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MASTER</name>
                  <description>Master</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>I2S_MODE</name>
              <description>Select I2S, left-justified or TDM:

(Note: These bits are connected to AR38U12.RX_CFG.RX_I2S_MODE)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LEFT_JUSTIFIED</name>
                  <description>Left Justified</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>I2S</name>
                  <description>I2S mode</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDM_A</name>
                  <description>TDM mode A, the 1st Channel align to WSO 
Rising Edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TDM_B</name>
                  <description>TDM mode B, the 1st Channel align to WSO
Rising edge with1 SCK Delay</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WS_PULSE</name>
              <description>Set WS pulse width in TDM mode:

(Note: This bit is connected to AR38U12.RX_CFG.RX_WS_PULSE)
Note: When not TDM mode, must be '1'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SCK_PERIOD</name>
                  <description>Pulse width is 1 SCK period</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CH_LENGTH</name>
                  <description>Pulse width is 1 channel length</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WD_EN</name>
              <description>Set watchdog for 'rx_ws_in'
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CH_LEN</name>
              <description>Channel length in number of bits:

Note: 
- When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
- When TDM mode, must be 32-bit length to this field.
(Note: These bits are connected to AR38U12.RX_CFG.RX_CHLEN)</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT_LEN8</name>
                  <description>8-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN16</name>
                  <description>16-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN18</name>
                  <description>18-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN20</name>
                  <description>20-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN24</name>
                  <description>24-bit</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN32</name>
                  <description>32-bit</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WORD_LEN</name>
              <description>Word length in number of bits:

Note: 
- When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
- Don't configure this field as beyond Channel length.
(Note: These bits are connected to AR38U12.RX_CFG.RX_IWL)</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BIT_LEN8</name>
                  <description>8-bit</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN16</name>
                  <description>16-bit</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN18</name>
                  <description>18-bit</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN20</name>
                  <description>20-bit</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN24</name>
                  <description>24-bit</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIT_LEN32</name>
                  <description>32-bit</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BIT_EXTENSION</name>
              <description>When reception word length is shorter than the word length of RX_FIFO_RD, extension mode of upper bit should be set.
'0': Extended by '0'
'1': Extended by sign bit (if MSB word is '1', then it is extended by '1', if MSB is '0' then it is extended by '0')</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCKO_POL</name>
              <description>RX master bit clock polarity.
When this bit is 1, the outgoing rx_sck signal is inverted after it has been transmitted from the I2S receiver core. This bit does not affect the internal serial data capture timing. The word sync (RX_WS) signal is not affected by this bit setting.See RX_CTL.B_CLOCK_INV for more details.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCKI_POL</name>
              <description>RX slave bit clock polarity.
When this bit is 1, the incoming rx_sck signal is inverted before it is received by the I2S receiver core. This bit does not affect the internal serial data capture timing. The word sync (RX_WS) signal is not affected by this bit setting.
'0': When receiver is in slave mode, serial data is sampled on the rising bit clock edge
'1': When receiver is in slave mode, serial data is sampled on the falling bit clock edge</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_WATCHDOG</name>
          <description>Receiver watchdog</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WD_COUNTER</name>
              <description>Start value of the RX watchdog. With the reset value of 0x0000:0000 the counter is disabled. This is clocked by the AHB-Lite system clock 'clk_sys'.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTL</name>
          <description>TX FIFO control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the TX FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the TX FIFO and TX_BUF are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the TX FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer. This field is used only for debugging purposes.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>TX FIFO status</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Number of entries in the TX FIFO. The field value is in the range [0, 256].</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>TX FIFO read pointer: FIFO location from which a data frame is read by the hardware.This field is used only for debugging purposes.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>TX FIFO write pointer: FIFO location at which a new data frame is written by the host. This field is used only for debugging purposes.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>TX FIFO write</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data written into the TX FIFO. Behavior is similar to that of a PUSH operation. 
Note: Don't access to this register while TX_FIFO_CTL.CLEAR is '1'.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTL</name>
          <description>RX FIFO control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the RX FIFO has more entries than the number of this field, a receiver trigger event is generated.
Note: software can configure up to 253 in I2S mode or Left Justified (RX_CTL.I2S_MODE = '0' or '1'). In TDM mode (RX_CTL.I2S_MODE = '2' or '3'), it can configure up to [256 - (RX_CTL.CH_NR+2)].</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the RX FIFO and RX_BUF are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the RX FIFO have no effect. Freeze will not advance the RX FIFO write pointer. This field is used only for debugging purposee.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>RX FIFO status</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Number of entries in the RX FIFO. The field value is in the range [0, 256].</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>RX FIFO read pointer: FIFO location from which a data frame is read by the host. This field is used only for debugging purposes.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>RX FIFO write pointer: FIFO location at which a new data frame is written by the hardware. This field is used only for debugging purposes.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>RX FIFO read</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the RX FIFO. Reading a data frame will remove the data frame from the RX FIFO; i.e. behavior is similar to that of a POP operation. 
Notes: 
 - Don't access to this register while RX_FIFO_CTL.CLEAR is '1'. 
 - Two stored data may be not valid after CMD.RX_START is set '1'. Therefore we recommend software discard those data.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>RX FIFO silent read</description>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the RX FIFO. Reading a data frame will NOT remove the data frame from the RX FIFO; i.e. behavior is similar to that of a PEEK operation. This field is used only for debugging purposes.
Notes: 
 - Don't access to this register while RX_FIFO_CTL.CLEAR is '1'. 
 - Two stored data may be not valid after CMD.RX_START is set '1'. Therefore we recommend software discard those data.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x16D0173</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER</name>
              <description>Less entries in the TX FIFO than the value specified by TRIGGER_LEVEL in TX_FIFO_CTRL.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NOT_FULL</name>
              <description>TX FIFO is not full.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>TX FIFO is empty; i.e. it has 0 entries.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_OVERFLOW</name>
              <description>Attempt to write to a full TX FIFO.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when the IP is ready to transfer data and TX_EMPTY is '1'.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_WD</name>
              <description>Triggers (sets to '1') when the Tx watchdog event occurs.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_TRIGGER</name>
              <description>More entries in the RX FIFO than the value specified by TRIGGER_LEVEL in RX_FIFO_CTRL.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>RX FIFO is not empty.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>RX FIFO is full.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Attempt to write to a full RX FIFO.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Attempt to read from an empty RX FIFO.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_WD</name>
              <description>Triggers (sets to '1') when the Rx watchdog event occurs.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x16D0173</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_WD</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_WD</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x16D0173</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_WD</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_WD</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x16D0173</resetMask>
          <fields>
            <field>
              <name>TX_TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_WD</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_WD</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>