<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.1" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd" >
  <name>NUC029EE_v1</name>
  <version>1.0</version>
  <description>NUC029EE_v1 SVD file</description>
  <!-- Bus Interface Properties -->
  <!-- Cortex-M0 is byte addressable -->
  <addressUnitBits>8</addressUnitBits>
  <!-- the maximum data bit width accessible within a single transfer is 32bits -->
  <width>32</width>

  <!-- Register Default Properties -->
  <!-- the size of the registers is set to a bit width of 32. This can be overruled for individual peripherals and/or registers -->
  <size>32</size>
  <!-- the access to all registers is set to be readable and writeable. This can be overruled for individual peripherals and/or registers -->
  <access>read-write</access>
  <!-- for demonstration purposes the resetValue for all registers of the device is set to be 0. This can be overruled within the description -->
  <resetValue>0</resetValue>
  <!-- the resetMask = 0 specifies that by default no register of this device has a defined reset value -->
  <resetMask>0</resetMask>

  <peripherals>
    <peripheral>
      <name>GCR</name>
      <description>GCR Register Map</description>
      <groupName>GCR</groupName>
      <baseAddress>0x50000000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x18</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x24</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x30</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x5C</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x90</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDID</displayName>
          <description>Part Device Identification Number Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x20140018</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDID</name>
              <description>Part Device Identification Number\nThis register reflects device part number code. Software can read this register to identify which device is used.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RSTSRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RSTSRC</displayName>
          <description>System Reset Source Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>RSTS_POR</name>
              <description>Power-On Reset Flag\nThe RSTS_POR Flag is set by the 'Reset Signal' from the Power-On Reset (POR) vontroller or bit CHIP_RST (IPRSTC1[0]) to indicate the previous reset source\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from POR or CHIP_RST (IPRSTC1[0])</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power-on Reset (POR) or CHIP_RST (IPRSTC1[0]) had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_RESET</name>
              <description>Reset Pin Reset Flag\nThe RSTS_RESET flag is set by the 'Reset Signal' from the nRESET Pin to indicate the previous reset source\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from nRESET pin</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Pin nRESET had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_WDT</name>
              <description>Watchdog Timer Reset Flag\nThe RSTS_WDT flag is set by the 'Reset Signal' from the watchdog timer or window watchdog timer to indicate the previous reset source.\nNote1: Write 1 to clear this bit to 0.\nNote2: Watchdog Timer register WTRF(WTCR[2]) bit is set if the system has been reset by WDT time-out reset. Window Watchdog Timer register WWDTRF(WWDTSR) bit is set if the system has been reset by WWDT time-out reset.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from watchdog timer or window watchdog timer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The watchdog timer or window watchdog timer had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_LVR</name>
              <description>Low Voltage Reset Flag\nThe RSTS_LVR flag is set by the 'Reset Signal' from the Low-Voltage-Reset controller to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from LVR</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LVR controller had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_BOD</name>
              <description>Brown-Out Detector Reset Flag\nThe RSTS_BOD flag is set by the 'Reset Signal' from the Brown-Out Detector to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from BOD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The BOD had issued the reset signal to reset the system</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_SYS</name>
              <description>SYS Reset Flag\nThe RSTS_SYS flag Is set by the 'Reset Signal' from the Cortex-M0 kernel to indicate the previous reset source.\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from Cortex-M0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Cortex-M0 had issued the reset signal to reset the system by writing 1 to bit SYSRESETREQ (AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M0 kernel</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTS_CPU</name>
              <description>CPU Reset Flag\nThe RSTS_CPU flag Is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 To reset Cortex-M0 kernel and flash memory controller (FMC).\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No reset from CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST(IPRSTC1[1]) to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRSTC1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRSTC1</displayName>
          <description>Peripheral Reset Control Register 1</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHIP_RST</name>
              <description>CHIP One-Shot Reset (Write Protect)\nSetting this bit will reset the whole chip, including CPU kernel and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.\nThe CHIP_RST is the same as the POR reset, all the chip controllers are reset and the chip setting from flash are also reload.\nFor the difference between CHIP_RST and SYSRESETREQ, please refer to section 5.2.2\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CHIP normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CHIP one-shot reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_RST</name>
              <description>CPU Kernel One-Shot Reset (Write Protect)\nSetting this bit will only reset the CPU kernel and Flash Memory Controller(FMC), and this bit will automatically return 0 after the two clock cycles\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CPU normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CPU one-shot reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Controller Reset (Write Protect)\nSetting this bit to 1 will generate a reset signal to the PDMA. User needs to set this bit to 0 to release from reset state.\nNote1: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.\nNote2: Setting PDMA_RST bit to 1 will generate asynchronous reset signal to PDMA module. Users need to set PDMA_RST to 0 to release PDMA module from reset state.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_RST</name>
              <description>EBI Controller Reset (Write-protection Bit)\nSet this bit to 1 will generate a reset signal to the EBI. User need to set this bit to 0 to release from the reset state.\nThis bit is the protected bit, It means programming this bit needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IPRSTC2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IPRSTC2</displayName>
          <description>Peripheral Reset Control Register 2</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPIO_RST</name>
              <description>GPIO Controller Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_RST</name>
              <description>Timer0 Controller Reset</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_RST</name>
              <description>Timer1 Controller Reset</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_RST</name>
              <description>Timer2 Controller Reset</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_RST</name>
              <description>Timer3 Controller Reset</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer3 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer3 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_RST</name>
              <description>I2C0 Controller Reset</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1_RST</name>
              <description>I2C1 Controller Reset</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_RST</name>
              <description>SPI0 Controller Reset</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_RST</name>
              <description>SPI1 Controller Reset</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_RST</name>
              <description>UART0 Controller Reset</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART0 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_RST</name>
              <description>UART1 Controller Reset</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART1 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART2_RST</name>
              <description>UART2 Controller Reset </description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART2 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART2 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM03_RST</name>
              <description>PWM03 Controller Reset</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM03 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM03 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM45_RST</name>
              <description>PWM45 Controller Reset</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM45 controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM45 controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USBD_RST</name>
              <description>USB Device Controller Reset</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB device controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB device controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RST</name>
              <description>ADC Controller Reset</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC controller normal operation</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC controller reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>BODCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>BODCR</displayName>
          <description>Brown-out Detector Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000080</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>BOD_EN</name>
              <description>Brown-Out Detector Enable Bit (Write Protect)\nThe default value is set by flash memory controller user configuration register CBODEN(CONFIG0[23]) bit.\nNote: This bit is the protected bit. It means programming this needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_VL</name>
              <description>Brown-Out Detector Threshold Voltage Selection (Write Protect)\nThe default value is set by flash momory controller user configuration register CBOV(CONFIG0[22:21]) bit .\nNote: This bit is the protected bit. It means programming this needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out voltage is 2.2V</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out voltage is 2.7V</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Brown-out voltage is 3.7V</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Brown-out voltage is 4.4V</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_RSTEN</name>
              <description>Brown-Out Reset Enable Bit (Write Protect)\nWhile the Brown-out Detector function is enabled (BOD_EN high) and BOD reset function is enabled (BOD_RSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BOD_OUT high).\nNote1: While the BOD function is enabled (BOD_EN high) and BOD interrupt function is enabled (BOD_RSTEN low), BOD will assert an interrupt if BOD_OUT is high. BOD interrupt will keep till to the BOD_EN set to 0. BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BOD_EN low).\nNote2: The default value is set by flash controller user configuration register CBORST(CONFIG0[20]) bit. \nNote3: This bit is the protected bit. It means programming this needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out 'INTERRUPT' function Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out 'RESET' function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_INTF</name>
              <description>Brown-Out Detector Interrupt Flag\nNote: Write 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BOD_VL setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When Brown-out Detector detects the VDD is dropped down through the voltage of BOD_VL setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to 1 and the Brown-out interrupt is requested if Brown-out interrupt is enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_LPM</name>
              <description>Brown-Out Detector Low Power Mode (Write Protect)\nNote1: The BOD consumes about 100 uA in Normal mode, and the low power mode can reduce the current to about 1/10 but slow the BOD response.\nNote2: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BOD operated in Normal mode (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BOD Low Power mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_OUT</name>
              <description>Brown-Out Detector Output Status</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Brown-out Detector output status is 0. It means the detected voltage is higher than BOD_VL setting or BOD_EN is 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Brown-out Detector output status is 1. It means the detected voltage is lower than BOD_VL setting. If the BOD_EN is 0, BOD function disabled, this bit always responds to 0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LVR_EN</name>
              <description>Low Voltage Reset Enable Bit (Write Protect)\nThe LVR function reset the chip when the input power voltage is lower than LVR circuit setting. LVR function is enabled by default.\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low Voltage Reset function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Low Voltage Reset function Enabled - After enabling the bit, the LVR function will be active with 100us delay for LVR output stable (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEMPCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEMPCR</displayName>
          <description>Temperature Sensor Control Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VTEMP_EN</name>
              <description>Temperature Sensor Enable Bit\nThis bit is used to enable/disable temperature sensor function.\nNote: After this bit is set to 1, the value of temperature can be obtained from ADC conversion result by ADC channel selecting channel 7 and alternative multiplexer channel selecting temperature sensor. Please refer to the ADC function chapter for detail ADC conversion functional description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Temperature sensor function Disabled (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Temperature sensor function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PORCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PORCR</displayName>
          <description>Power-on-reset Controller Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>POR_DIS_CODE</name>
              <description>Power-On-Reset Enable Bit (Write Protect)\nWhen powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again. User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.\nThe POR function will be active again when  this field is set to another value or chip is reset by other reset source, including:\nnRESET, Watchdog Timer reset, Window Watchdog Timer reset, LVR reset, BOD reset, ICE reset command and the software-chip reset function\nNote: This bit is the protected bit. It means programming this needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPA_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPA_MFP</displayName>
          <description>GPIOA Multiple Function and Input Type Control Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPA_MFP0</name>
              <description>PA.0 Pin Function Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC0 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP1</name>
              <description>PA.1 Pin Function Selection\nBit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]) and GPA_MFP[1] determine the PA.1 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP1) value and function mapping is as following list.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP2</name>
              <description>PA.2 Pin Function Selection\nBits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]) and GPA_MFP[2] determine the PA.2 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP2) value and function mapping is as following list.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP3</name>
              <description>PA.3 Pin Function Selection\nBits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]) and GPA_MFP[3] determine the PA.3 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP3) value and function mapping is as following list.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP4</name>
              <description>PA.4 Pin Function Selection\nBits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]) and GPA_MFP[4] determine the PA.4 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP4) value and function mapping is as following list.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP5</name>
              <description>PA.5 Pin Function Selection\nBits EBI_HB_EN[0] (ALT_MFP[16]), EBI_EN (ALT_MFP[11]) and GPA_MFP[5] determine the PA.5 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP5) value and function mapping is as following list,</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP6</name>
              <description>PA.6 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]) and GPA_MFP[6] determine the PA.6 function.\n(EBI_EN, GPA_MFP6) value and function mapping is as following list.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP7</name>
              <description>Reserved.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP8</name>
              <description>PA.8 Pin Function Selection\nBit GPA_MFP[8] determines the PA.9 function.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PA.8</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0_SDA function is selected to the pin PA.8</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP9</name>
              <description>PA.9 Pin Function Selection\nBit GPA_MFP[9] determines the PA.9 function.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0_SCL function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP10</name>
              <description>PA.10 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]) and GPA_MFP[10] determine the PA.10 function.\n(EBI_EN, GPA_MFP10) value and function mapping is as following list.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP11</name>
              <description>PA.11 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]) and GPA_MFP[11] determine the PA.11 function.\n(EBI_EN, GPA_MFP11) value and function mapping is as following list.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP12</name>
              <description>PA.12 Pin Function Selection\nBits EBI_HB_EN[5] (ALT_MFP[21]),  EBI_EN (ALT_MFP[11]) and GPA_MFP[12] determine the PA.12 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP12) value and function mapping is as following list.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP13</name>
              <description>PA.13 Pin Function Selection\nBits EBI_HB_EN[6] (ALT_MFP[22]),  EBI_EN (ALT_MFP[11]) and GPA_MFP[13] determine the PA.13 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP13) value and function mapping is as following list.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP14</name>
              <description>PA.14 Pin Function Selection\nBits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]) and GPA_MFP[14] determine the PA.14 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP14) value and function mapping is as following list.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_MFP15</name>
              <description>PA.15 Pin Function Selection</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM3 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPA_TYPEn</name>
              <description>Trigger Function Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOA[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPB_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPB_MFP</displayName>
          <description>GPIOB Multiple Function and Input Type Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPB_MFP0</name>
              <description>PB.0 Pin Function Selection\nBit GPB_MFP[0] determines the PB.0 function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PB.0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0_RXD function is selected to the pin PB.0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP1</name>
              <description>PB.1 Pin Function Selection\nBit GPB_MFP[1] determines the PB.1 function.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PB.1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0_TXD function is selected to the pin PB.1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP2</name>
              <description>PB.2 Pin Function Selection\nBits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_TM2 (ALT_MFP2[4]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.\n(EBI_nWRL_EN, EBI_EN, PB2_TM2, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP3</name>
              <description>PB.3 Pin Function Selection\nBits EBI_nWRH_EN (ALT_MFP[14]), EBI_EN (ALT_MFP[11]), PB3_TM3 (ALT_MFP2[5]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.\n(EBI_nWRH_EN, EBI_EN,  PB3_TM3, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP4</name>
              <description>PB.4 Pin Function Selection\nBit GPB_MFP[4] determines the PB.4 function.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PB.4</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1_RXD function is selected to the pin PB.4</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP5</name>
              <description>PB 5 Pin Function Selection\nBit GPB_MFP[5] determines the PB.5 function.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PB.5</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1_TXD function is selected to the pin PB.5</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP6</name>
              <description>PB.6 Pin Function Selection\nBit EBI_EN (ALT_MFP[11]), GPB_MFP[6] determines the PB.6 function.\n(EBI_EN, GPB_MFP6) value and function mapping is as following list.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP7</name>
              <description>PB.7 Pin Function Selection\nBit EBI_EN (ALT_MFP[11]), GPB_MFP[7] determines the PB.7 function.\n(EBI_EN, GPB_MFP7) value and function mapping is as following list.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP8</name>
              <description>PB.8 Pin Function Selection\nBits PB8_CLKO (ALT_MFP[29]) and GPB_MFP[8] determine the PB.8 function.\n(PB8_CLKO, GPB_MFP8) value and function mapping is as following list.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP9</name>
              <description>PB.9 Pin Function Selection\nBits PB9_S11 (ALT_MFP[1]) and GPB_MFP[9] determine the PB.9 function.\n(PB9_S11, GPB_MFP9) value and function mapping is as following list.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP10</name>
              <description>PB.10 Pin Function Selection\nBits PB10_S01 (ALT_MFP[0]) and GPB_MFP[10] determine the PB.10 function.\n(PB10_S01, GPB_MFP10) value and function mapping is as following list.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP11</name>
              <description>PB.11 Pin Function Selection\nBits PB11_PWM4 (ALT_MFP[4]) and GPB_MFP[11] determine the PB.11 function.\n(PB11_PWM4, GPB_MFP11) value and function mapping is as following list.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP12</name>
              <description>Reserved.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP13</name>
              <description>PB.13 Pin Function Selection</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PB.13</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>AD1 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP14</name>
              <description>PB.14 Pin Function Selection\nBits PB14_15_EBI (ALT_MFP2[1]) and GPB_MFP[14] determine the PB.14 function.\n(PB14_15_EBI, GPB_MFP14) value and function mapping is as following list</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_MFP15</name>
              <description>PB.15 Pin Function Selection\nBits PB14_15_EBI (ALT_MFP2[1]),  PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15] determine the PB.15 function.\n(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPB_TYPEn</name>
              <description>Trigger Function Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOB[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOB[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPC_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPC_MFP</displayName>
          <description>GPIOC Multiple Function and Input Type Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPC_MFP0</name>
              <description>PC.0 Pin Function Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0_SS0 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP1</name>
              <description>PC.1 Pin Function Selection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0_CLK function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP2</name>
              <description>PC.2 Pin Function Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0_MISO0 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP3</name>
              <description>PC.3 Pin Function Selection</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0_MOSI0 function is selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP4</name>
              <description>Reserved.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP5</name>
              <description>Reserved.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP6</name>
              <description>PC.6 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]) and GPC_MFP[6] determine the PC.6 function.\n(EBI_EN, GPB_MFP6) value and function mapping is as following list.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP7</name>
              <description>PC.7 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]) and GPC_MFP[7] determine the PC.7 function.\n(EBI_EN, GPC_MFP7) value and function mapping is as following list.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP8</name>
              <description>PC.8 Pin Function Selection\nBits EBI_MCLK_EN (ALT_MFP[12]), EBI_EN (ALT_MFP[11]),  GPC_MFP[8] determine the PC.8 function.\n(EBI_MCLK_EN, EBI_EN, GPC_MFP8) value and function mapping is as following list.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP9</name>
              <description>PC.9 Pin Function Selection\nBit GPC_MFP[9] determines the PC.9 function.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PC.9</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1_CLK function is selected to the pin PC.9</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP10</name>
              <description>PC.10 Pin Function Selection\nBit GPC_MFP[10] determines the PC.10 function.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PC.10</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1_MISO0 function is selected to the pin PC.10</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP11</name>
              <description>PC.11 Pin Function Selection\nBit GPC_MFP[11] determines the PC.11 function.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PC.11</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1_MOSI0 function is selected to the pin PC.11</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP12</name>
              <description>Reserved.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP13</name>
              <description>Reserved.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP14</name>
              <description>PC.14 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]) and GPC_MFP[14] determine the PC.14 function.\n(EBI_EN, GPC_MFP14) value and function mapping is as following list</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_MFP15</name>
              <description>PC.15 Pin Function Selection\nBits EBI_EN (ALT_MFP[11]) and GPC_MFP[15] determine the PC.15 function.\n(EBI_EN, GPC_MFP15) value and function mapping is as following list</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPC_TYPEn</name>
              <description>Trigger Function Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOC[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOC[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPE_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPE_MFP</displayName>
          <description>GPIOE Multiple Function and Input Type Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GPE_MFP5</name>
              <description>PE.5 Pin Function Selection\nBits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.\n(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPE_TYPEn</name>
              <description>Trigger Function Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOE[15:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOE[15:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPF_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPF_MFP</displayName>
          <description>GPIOF Multiple Function and Input Type Control Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>GPF_MFP0</name>
              <description>PF.0 Pin Function Selection\nBit GPF_MFP[0] determines the PF.0 function\nNote: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PF.0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>XT1_OUT function is selected to the pin PF.0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPF_MFP1</name>
              <description>PF.1 Pin Function Selection \nBit GPF_MFP[1] determines the PF.1 function.\nNote: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO function is selected to the pin PF.1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>XT1_IN function is selected to the pin PF.1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>GPF_TYPEn</name>
              <description>Trigger Function Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIOF[3:0] I/O input Schmitt Trigger function Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOF[3:0] I/O input Schmitt Trigger function Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ALT_MFP</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALT_MFP</displayName>
          <description>Alternative Multiple Function Pin Control Register</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PB10_S01</name>
              <description>PB.10 Pin Alternative Function Selection\nBits PB10_S01 (ALT_MFP[0]) and GPB_MFP[10] determine the PB.10 function.\n(PB10_S01, GPB_MFP10) value and function mapping is as following list.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB9_S11</name>
              <description>PB.9 Pin Alternative Function Selection\nBits PB9_S11 (ALT_MFP[1]) and GPB_MFP[9] determine the PB.9 function.\n(PB9_S11, GPB_MFP9) value and function mapping is as following list.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB14_S31</name>
              <description>PB.14 Pin Alternative Function Selection\nBits PB14_15_EBI (ALT_MFP2[1]) and GPB_MFP[14] determine the PB.14 function.\n(PB14_15_EBI, GPB_MFP14) value and function mapping is as following list</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB11_PWM4</name>
              <description>PB.11 Pin Alternative Function Selection\nBits PB11_PWM4 (ALT_MFP[4]) and GPB_MFP[11] determine the PB.11 function.\n(PB11_PWM4, GPB_MFP11) value and function mapping is as following list.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_EN</name>
              <description>EBI_EN is use to switch GPIO function to EBI function (AD[15:0], ALE, RE, WE, CS, MCLK), it need additional registers EBI_EN[7:0] and EBI_MCLK_EN for some GPIO to switch to EBI function(AD[15:8], MCLK)</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_MCLK_EN</name>
              <description>Bits EBI_MCLK_EN (ALT_MFP[12]), EBI_EN (ALT_MFP[11]),  GPC_MFP[8] determine the PC.8 function.\n(EBI_MCLK_EN, EBI_EN, GPC_MFP8) value and function mapping is as following list.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_nWRL_EN</name>
              <description>Bits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_TM2 (ALT_MFP2[4]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.\n(EBI_nWRL_EN, EBI_EN, PB2_TM2, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_nWRH_EN</name>
              <description>Bits EBI_nWRH_EN (ALT_MFP[14]), EBI_EN (ALT_MFP[11]), PB3_TM3 (ALT_MFP2[5]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.\n(EBI_nWRH_EN, EBI_EN,  PB3_TM3, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN0</name>
              <description>Bits EBI_HB_EN[0] (ALT_MFP[16]), EBI_EN (ALT_MFP[11]) and GPA_MFP[5] determine the PA.5 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP5) value and function mapping is as following list,</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN1</name>
              <description>Bits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]) and GPA_MFP[4] determine the PA.4 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP4) value and function mapping is as following list.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN2</name>
              <description>Bits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]) and GPA_MFP[3] determine the PA.3 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP3) value and function mapping is as following list.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN3</name>
              <description>Bits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]) and GPA_MFP[2] determine the PA.2 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP2) value and function mapping is as following list.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN4</name>
              <description>Bit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]) and GPA_MFP[1] determine the PA.1 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP1) value and function mapping is as following list.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN5</name>
              <description>Bits EBI_HB_EN[5] (ALT_MFP[21]),  EBI_EN (ALT_MFP[11]) and GPA_MFP[12] determine the PA.12 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP12) value and function mapping is as following list.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN6</name>
              <description>Bits EBI_HB_EN[6] (ALT_MFP[22]),  EBI_EN (ALT_MFP[11]) and GPA_MFP[13] determine the PA.13 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP13) value and function mapping is as following list.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_HB_EN7</name>
              <description>Bits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]) and GPA_MFP[14] determine the PA.14 function.\n(EBI_HB_EN, EBI_EN, GPA_MFP14) value and function mapping is as following list.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB15_T0EX</name>
              <description>PB.15 Pin Alternative Function Selection\nBits PB14_15_EBI (ALT_MFP2[1]),  PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15] determine the PB.15 function.\n(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE5_T1EX</name>
              <description>PE.5 Pin Alternative Function Selection\nBits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.\n(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB2_T2EX</name>
              <description>PB.2 Pin Alternative Function Selection\nBits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_TM2 (ALT_MFP2[4]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.\n(EBI_nWRL_EN, EBI_EN, PB2_TM2, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB3_T3EX</name>
              <description>PB.3 Pin Alternative Function Selection\nBits EBI_nWRH_EN (ALT_MFP[14]), EBI_EN (ALT_MFP[11]), PB3_TM3 (ALT_MFP2[5]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.\n(EBI_nWRH_EN, EBI_EN,  PB3_TM3, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB8_CLKO</name>
              <description>PB.8 Pin Alternative Function Selection\nBits PB8_CLKO (ALT_MFP[29]) and GPB_MFP[8] determine the PB.8 function.\n(PB8_CLKO, GPB_MFP8) value and function mapping is as following list.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ALT_MFP2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ALT_MFP2</displayName>
          <description>Alternative Multiple Function Pin Control Register 2</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PB14_15_EBI</name>
              <description>PB .14 and PB.15 Pin Alternative Function Selection\nBits PB14_15_EBI (ALT_MFP2[1]),  PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15] determine the PB.15 function.\n(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB15_TM0</name>
              <description>PB.15 Pin Alternative Function Selection\nBits PB14_15_EBI (ALT_MFP2[1]),  PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15] determine the PB.15 function.\n(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PE5_TM1</name>
              <description>PE.5 Pin Alternative Function Selection\nBits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.\n(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB2_TM2</name>
              <description>PB.2 Pin Alternative Function Selection\nBits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_TM2 (ALT_MFP2[4]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.\n(EBI_nWRL_EN, EBI_EN, PB2_TM2, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PB3_TM3</name>
              <description>PB.3 Pin Alternative Function Selection\nBits EBI_nWRH_EN (ALT_MFP[14]), EBI_EN (ALT_MFP[11]), PB3_TM3 (ALT_MFP2[5]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.\n(EBI_nWRH_EN, EBI_EN,  PB3_TM3, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRCTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRCTCTL</displayName>
          <description>IRC Trim Control Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM_SEL</name>
              <description>Trim Frequency Selection\nThis field indicates the target frequency of internal 22.1184 MHz high speed oscillator will trim to precise 22.1184MHz or 24MHz automatically.\nIf no any target frequency is selected (TRIM_SEL is 00), the HIRC auto trim function is disabled.\nDuring auto trim operation, if clock error detected because of CLKERR_STOP_EN is set to 1 or trim retry limitation counts reached, this field will be cleared to 00 automatically.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>HIRC auto trim function Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>HIRC auto trim function Enabled and HIRC trimmed to 22.1184 MHz</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>HIRC auto trim function Enabled and HIRC trimmed to 24 MHz</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_LOOP</name>
              <description>Trim Calculation Loop\nThis field defines that trim value calculation is based on how many 32.768 kHz clocks in.\nFor example, if TRIM_LOOP is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 32.768 kHz clock.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim value calculation is based on average difference in 4 clocks</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim value calculation is based on average difference in 8 clocks</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Trim value calculation is based on average difference in 16 clocks</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Trim value calculation is based on average difference in 32 clocks</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_RETRY_CNT</name>
              <description>Trim Value Update Limitation Count\nThe field defines that how many times of HIRC trim value is updated by auto trim circuit before the HIRC frequency locked.\nOnce the HIRC locked, the internal trim value update counter will be reset.\nIf the trim value update counter reached this limitation value and frequency of HIRC still doesn't lock, the auto trim operation will be disabled and TRIM_SEL will be cleared to 00.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim retry count limitation is 64</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim retry count limitation is 128</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Trim retry count limitation is 256</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Trim retry count limitation is 512</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKERR_STOP_EN</name>
              <description>Clock Error Stop Enable Bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The trim operation is kept going if clock is inaccuracy</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The trim operation is stopped if clock is inaccuracy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRCTIEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRCTIEN</displayName>
          <description>IRC Trim Interrupt Enable Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TRIM_FAIL_IEN</name>
              <description>Trim Failure Interrupt Enable Bit\nThis bit controls if an interrupt will be triggered while HIRC trim value update limitation count reached and HIRC frequency still not locked on target frequency set by TRIM_SEL (IRCTCTL[1:0]).\nIf this bit is high and TRIM_FAIL_INT (IRCTRIMINT[1]) is set during auto trim operation. An interrupt will be triggered to notify that HIRC trim value update limitation count was reached.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TRIM_FAIL_INT (IRCTRIMINT[1]) status to trigger an interrupt to CPU Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TRIM_FAIL_INT (IRCTRIMINT[1]) status to trigger an interrupt to CPU Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKERR_IEN</name>
              <description>Clock Error Interrupt Enable Bit\nThis bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim operation.\nIf this bit is set to1, and CLKERR_INT (IRCTRIMINT[2]) is set during auto trim operation. An interrupt will be triggered to notify the clock frequency is inaccuracy.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CLKERR_INT (IRCTRIMINT[2]) status to trigger an interrupt to CPU Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CLKERR_INT (IRCTRIMINT[2]) status to trigger an interrupt to CPU Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>IRCTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRCTSTS</displayName>
          <description>IRC Trim Interrupt Status Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQ_LOCK</name>
              <description>HIRC Frequency Lock Status\nThis bit indicates the internal 22.1184 MHz high speed oscillator frequency is locked.\nThis is a status bit and doesn't trigger any interrupt.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_FAIL_INT</name>
              <description>Trim Failure Interrupt Status\nThis bit indicates that internal 22.1184 MHz high speed oscillator trim value update limitation count reached and the internal 22.1184 MHz high speed oscillator clock frequency still doesn't be locked. Once this bit is set, the auto trim operation stopped and TRIM_SEL (IRCTCTL[1:0]) will be cleared to 00 by hardware automatically.\nIf this bit is set and TRIM_FAIL_IEN (IRCTIEN[1]) is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached. Write 1 to clear this to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim value update limitation count did not reach</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim value update limitation count reached and internal 22.1184 MHz high speed oscillator frequency was still not locked</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKERR_INT</name>
              <description>Clock Error Interrupt Status\nWhen the frequency of external 32.768 kHz low speed crystal or internal 22.1184 MHz high speed oscillator is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy\nOnce this bit is set to 1, the auto trim operation stopped and TRIM_SEL (IRCTCTL[1:0]) will be cleared to 00 by hardware automatically if CLKERR_STOP_EN (IRCTCTL[8]) is set to 1.\nIf this bit is set and CLKERR_IEN (IRCTIEN [2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy. Write 1 to clear this to 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock frequency is accurate</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock frequency is inaccurate</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>HIRCTCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>HIRCTCTL</displayName>
          <description>HIRC Trim Control Register</description>
          <addressOffset>0x90</addressOffset>
          <access>read-write</access>
          <resetValue>0x00080000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQSEL</name>
              <description>Trim Frequency Selection\nThis field indicates the target frequency of 48 MHz internal high speed RC oscillator (HIRC) auto trim.\nDuring auto trim operation, if clock error detected with CESTOPEN is set to 1 or trim retry limitation count reached, this field will be cleared to 00 automatically.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable HIRC auto trim function</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable HIRC auto trim function and trim HIRC to 48 MHz</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Reserved.</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPSEL</name>
              <description>Trim Calculation Loop Selection\nThis field defines that trim value calculation is based on how many reference clocks.\nNote: For example, if LOOPSEL is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 clocks of reference clock.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim value calculation is based on average difference in 4 clocks of reference clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim value calculation is based on average difference in 8 clocks of reference clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Trim value calculation is based on average difference in 16 clocks of reference clock</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Trim value calculation is based on average difference in 32 clocks of reference clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRYCNT</name>
              <description>Trim Value Update Limitation Count\nThis field defines that how many times the auto trim circuit will try to update the HIRC trim value before the frequency of HIRC locked.\nOnce the HIRC locked, the internal trim value update counter will be reset.\nIf the trim value update counter reached this limitation value and frequency of HIRC still doesn't lock, the auto trim operation will be disabled and FREQSEL will be cleared to 00.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim retry count limitation is 64 loops</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim retry count limitation is 128 loops</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Trim retry count limitation is 256 loops</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Trim retry count limitation is 512 loops</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CESTOPEN</name>
              <description>Clock Error Stop Enable Bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The trim operation is keep going if clock is inaccuracy</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The trim operation is stopped if clock is inaccuracy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOUNDEN</name>
              <description>Boundary Enable</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Boundary function is disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Boundary function is enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BOUNDARY</name>
              <description>Boundary Selection\nFill the boundary range from 1 to 31, 0 is reserved.\nNote: This field is effective only when the BOUNDEN(SYS_HIRCTCTL[9]) is enable.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>HIRCTIEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>HIRCTIEN</displayName>
          <description>HIRC Trim Interrupt Enable Register</description>
          <addressOffset>0x94</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TFALIEN</name>
              <description>Trim Failure Interrupt Enable Bit\nThis bit controls if an interrupt will be triggered while HIRC trim value update limitation count reached and HIRC frequency still not locked on target frequency set by FREQSEL(SYS_HIRCTCTL[1:0]).\nIf this bit is high and TFAILIF(SYS_HIRCTSTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable TFAILIF(SYS_HIRCTSTS[1]) status to trigger an interrupt to CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable TFAILIF(SYS_HIRCTSTS[1]) status to trigger an interrupt to CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKEIEN</name>
              <description>Clock Error Interrupt Enable Bit\nThis bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim operation.\nIf this bit is set to1, and CLKERRIF(SYS_HIRCTSTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the clock frequency is inaccuracy.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable CLKERRIF(SYS_HIRCTSTS[2]) status to trigger an interrupt to CPU</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enable CLKERRIF(SYS_HIRCTSTS[2]) status to trigger an interrupt to CPU</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>HIRCTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>HIRCTSTS</displayName>
          <description>HIRC Trim Interrupt Status Register</description>
          <addressOffset>0x98</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FREQLOCK</name>
              <description>HIRC Frequency Lock Status\nThis bit indicates the HIRC frequency is locked.\nThis is a status bit and doesn't trigger any interrupt\nWrite 1 to clear this to 0. This bit will be set automatically, if the frequecy is lock and the RC_TRIM is enabled. \nNote : reset by powr on reset</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The internal high-speed oscillator frequency doesn't lock at 48 MHz yet</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The internal high-speed oscillator frequency locked at 48 MHz</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFAILIF</name>
              <description>Trim Failure Interrupt Status\nThis bit indicates that HIRC trim value update limitation count reached and the HIRC clock frequency still doesn't be locked. Once this bit is set, the auto trim operation stopped and FREQSEL(SYS_HIRCTCTL[1:0]) will be cleared to 00 by hardware automatically.\nIf this bit is set and TFAILIEN(SYS_HIRCTIEN[1]) is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached. Write 1 to clear this to 0.\nNote : reset by powr on reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Trim value update limitation count does not reach</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Trim value update limitation count reached and HIRC frequency still not locked</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKERIF</name>
              <description>Clock Error Interrupt Status\nWhen the reference clock or 48MHz internal high speed RC oscillator (HIRC) is shift larger to unreasonable value, this bit will be set and to be an indicate that clock frequency is inaccuracy\nOnce this bit is set to 1, the auto trim operation stopped and FREQSEL(SYS_HIRCTCTL[1:0]) will be cleared to 00 by hardware automatically if CESTOPEN(SYS_HIRCTCTL[8]) is set to 1.\nIf this bit is set and CLKEIEN(SYS_HIRCTIEN[2]) is high, an interrupt will be triggered to notify the clock frequency is inaccuracy. Write 1 to clear this to 0.\nNote : reset by powr on reset</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock frequency is accuracy</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock frequency is inaccuracy</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OVBDIF</name>
              <description>Over Boundary Status\nWhen the over boundary function is set, if there occurs the over boundary condition, this flag will be set.\nNote: Write 1 to clear this flag.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Over boundary coundition did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Over boundary coundition occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>REGWRPROT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>REGWRPROT</displayName>
          <description>Register Write Protection Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REGWRPROT</name>
              <description>Register Write-Protection Code (Write Only)\nSome registers have write-protection function. Writing these registers have to disable the protected function by writing the sequence value '59h', '16h', '88h' to this field. After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protection registers can be normal write.\nRegister Write-Protection Disable Index (Read Only)\nThe Protected registers are:\nIPRSTC1: address 0x5000_0008\nBODCR: address 0x5000_0018\nPORCR: address 0x5000_0024\nPWRCON: address 0x5000_0200 (bit[6] is not protected for power wake-up interrupt clear) \nAPBCLK bit[0]: address 0x5000_0208 (bit[0] is Watchdog Timer clock enable)\nCLKSEL0: address 0x5000_0210 (for HCLK and CPU STCLK clock source selection)\nCLKSEL1 bit[1:0]: address 0x5000_0214 (for Watchdog Timer clock source selection)\nNMI_SEL bit[8]: address 0x5000_0380 (for NMI_EN interrupt enable)\nISPCON: address 0x5000_C000 (Flash ISP Control register)\nISPTRG: address 0x5000_C010 (ISP Trigger Control register)\nWTCR: address 0x4000_4000\nFATCON: address 0x5000_C018\nNote: The bits which are write-protected will be noted as' (Write Protect)' beside the description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Write-protection is enabled for writing protected registers. Any write to the protected register is ignored</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write-protection is disabled for writing protected registers</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCS</name>
      <description>SYST_NVIC_SCS Register Map</description>
      <groupName>SYST_NVIC_SCS</groupName>
      <baseAddress>0xE000E000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x10</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x280</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x400</offset>
        <size>0x20</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD00</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD0C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xD1C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SYST_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_CSR</displayName>
          <description>SysTick Control and Status Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>System Tick Counter Enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counter will operate in a multi-shot manner</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TICKINT</name>
              <description>System Tick Interrupt Enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Counting down to 0 does not cause the SysTick exception to be pended. Software can use COUNTFLAG to determine if a count to 0 has occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Counting down to 0 will cause the SysTick exception to be pended. Clearing the SysTick Current Value register by a write in software will not cause SysTick to be pended</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKSRC</name>
              <description>System Tick Clock Source Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source is (optional) external reference clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Core clock used for SysTick</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTFLAG</name>
              <description>Returns 1 If Timer Counted To 0 Since Last Time This Register Was Read\nCOUNTFLAG is set by a count transition from 1 to 0.\nCOUNTFLAG is cleared on read or by a write to the Current Value register.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYST_RVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_RVR</displayName>
          <description>SysTick Reload Value Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RELOAD</name>
              <description>Value to load into the Current Value register when the counter reaches 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYST_CVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYST_CVR</displayName>
          <description>SysTick Current Value Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>CURRENT</name>
              <description>System Tick Current Value\nCurrent counter value. This is the value of the counter at the time it is sampled. The counter does not provide read-modify-write protection. The register is write-clear. A software write of any value will clear the register to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISER</displayName>
          <description>IRQ0 ~ IRQ31 Set-enable Control Register</description>
          <addressOffset>0x100</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETENA</name>
              <description>Interrupt Enable Register\nEnable one or more interrupts. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nWrite Operation:\nRead value indicates the current enable status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt status is Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to enable associated interrupt.\nAssociated interrupt status is Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICER</displayName>
          <description>IRQ0 ~ IRQ31 Clear-enable Control Register</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRENA</name>
              <description>Interrupt Disable Bits\nDisable one or more interrupts. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nWrite Operation:\nRead value indicates the current enable status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt status is Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to disable associated interrupt.\nAssociated interrupt status is Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ISPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ISPR</displayName>
          <description>IRQ0 ~ IRQ31 Set-pending Control Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SETPEND</name>
              <description>Set Interrupt Pending Register\nWrite Operation:\nRead value indicates the current pending status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt in not in pending status</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to set pending state. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nAssociated interrupt is in pending status</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_ICPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_ICPR</displayName>
          <description>IRQ0 ~ IRQ31 Clear-pending Control Register</description>
          <addressOffset>0x280</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRPEND</name>
              <description>Clear Interrupt Pending Register\nWrite Operation:\nRead value indicates the current pending status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nAssociated interrupt in not in pending status</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Write 1 to clear pending state. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).\nAssociated interrupt is in pending status</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR0</displayName>
          <description>IRQ0 ~ IRQ3 Priority Control Register</description>
          <addressOffset>0x400</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_0</name>
              <description>Priority Of IRQ0\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_1</name>
              <description>Priority Of IRQ1\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_2</name>
              <description>Priority Of IRQ2\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_3</name>
              <description>Priority Of IRQ3\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR1</displayName>
          <description>IRQ4 ~ IRQ7 Priority Control Register</description>
          <addressOffset>0x404</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_4</name>
              <description>Priority Of IRQ4\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_5</name>
              <description>Priority Of IRQ5\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_6</name>
              <description>Priority Of IRQ6\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_7</name>
              <description>Priority Of IRQ7\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR2</displayName>
          <description>IRQ8 ~ IRQ11 Priority Control Register</description>
          <addressOffset>0x408</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_8</name>
              <description>Priority Of IRQ8\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_9</name>
              <description>Priority Of IRQ9\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_10</name>
              <description>Priority Of IRQ10\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_11</name>
              <description>Priority Of IRQ11\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR3</displayName>
          <description>IRQ12 ~ IRQ15 Priority Control Register</description>
          <addressOffset>0x40C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_12</name>
              <description>Priority Of IRQ12\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_13</name>
              <description>Priority Of IRQ13\n'0' denotes the highest priority and '3' denotes the lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_14</name>
              <description>Priority Of IRQ14\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority Of IRQ15\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR4</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR4</displayName>
          <description>IRQ16 ~ IRQ19 Priority Control Register</description>
          <addressOffset>0x410</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_16</name>
              <description>Priority Of IRQ16\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_17</name>
              <description>Priority Of IRQ17\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_18</name>
              <description>Priority Of IRQ18\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_19</name>
              <description>Priority Of IRQ19\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR5</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR5</displayName>
          <description>IRQ20 ~ IRQ23 Priority Control Register</description>
          <addressOffset>0x414</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_20</name>
              <description>Priority Of IRQ20\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_21</name>
              <description>Priority Of IRQ21\n'0' denotes the highest priority and '3' denotes the lowest priority</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_22</name>
              <description>Priority Of IRQ22\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_23</name>
              <description>Priority Of IRQ23\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR6</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR6</displayName>
          <description>IRQ24 ~ IRQ27 Priority Control Register</description>
          <addressOffset>0x418</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_24</name>
              <description>Priority Of IRQ24\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_25</name>
              <description>Priority Of IRQ25\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_26</name>
              <description>Priority Of IRQ26\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_27</name>
              <description>Priority Of IRQ27\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>NVIC_IPR7</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NVIC_IPR7</displayName>
          <description>IRQ28 ~ IRQ31 Priority Control Register</description>
          <addressOffset>0x41C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_28</name>
              <description>Priority Of IRQ28\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_29</name>
              <description>Priority Of IRQ29\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_30</name>
              <description>Priority Of IRQ30\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_31</name>
              <description>Priority Of IRQ31\n'0' denotes the highest priority and '3' denotes the lowest priority.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CPUID</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CPUID</displayName>
          <description>CPUID Register</description>
          <addressOffset>0xD00</addressOffset>
          <access>read-only</access>
          <resetValue>0x410CC200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>REVISION</name>
              <description>Revision Number\nRead as 0x0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARTNO</name>
              <description>Part Number Of The Processor\nRead as 0xC20.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PART</name>
              <description>Architecture Of The Processor\nRead as 0xC for ARMv6-M parts</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IMPLEMENTER</name>
              <description>Implementer Code Assigned By ARM</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ICSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ICSR</displayName>
          <description>Interrupt Control and State Register</description>
          <addressOffset>0xD04</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VECTACTIVE</name>
              <description>Contains The Active Exception Number</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Thread mode</description>
                    <value>0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTPENDING</name>
              <description>Indicates The Exception Number Of The Highest Priority Pending Enabled Exception:</description>
              <bitOffset>12</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No pending exceptions</description>
                    <value>0</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRPENDING</name>
              <description>Interrupt Pending Flag, Excluding NMI And Faults:\nThis bit is read only.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRPREEMPT</name>
              <description>If Set, A Pending Exception Will Be Serviced On Exit From The Debug Halt State\nThis bit is read only.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSTCLR</name>
              <description>SysTick Exception Clear-Pending Bit\nWrite Operation:\nThis is a write only bit. When you want to clear PENDST bit, you must 'write 0 to PENDSTSET and write 1 to PENDSTCLR' at the same time.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Removes the pending state from the SysTick exception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSTSET</name>
              <description>SysTick Exception Set-Pending Bit\nWrite Operation:</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nSysTick exception is not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes SysTick exception state to pending.\nSysTick exception is pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVCLR</name>
              <description>PendSV Clear-Pending Bit\nWrite Operation:\nThis is a write only bit. When you want to clear PENDSV bit, you must 'write 0 to PENDSVSET and write 1 to PENDSVCLR' at the same time.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Removes the pending state from the PendSV exception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PENDSVSET</name>
              <description>PendSV Set-Pending Bit\nWrite Operation:\nNote: Writing 1 to this bit is the only way to set the PendSV exception state to pending.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nPendSV exception is not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes PendSV exception state to pending.\nPendSV exception is pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NMIPENDSET</name>
              <description>NMI Set-Pending Bit\nWrite Operation:\nBecause NMI is the highest-priority exception, normally the processor enters the NMI exception handler as soon as it detects a write of 1 to this bit. Entering the handler then clears this bit to 0. This means a read of this bit by the NMI exception handler returns 1 only if the NMI signal is reasserted while the processor is executing that handler.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect.\nNMI exception not pending</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Changes NMI exception state to pending.\nNMI exception pending</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AIRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AIRCR</displayName>
          <description>Application Interrupt and Reset Control Register</description>
          <addressOffset>0xD0C</addressOffset>
          <access>read-write</access>
          <resetValue>0xFA050000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VECTCLRACTIVE</name>
              <description>Exception Active Status Clear Bit\nReserved for debug use. When writing to the register, user must write 0 to this bit, otherwise behavior is unpredictable.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SYSRESETREQ</name>
              <description>System Reset Request\nWriting this bit 1 will cause a reset signal to be asserted to the chip to indicate a reset is requested.\nThe bit is a write only bit and self-clears as part of the reset sequence.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VECTORKEY</name>
              <description>Register Access Key\nWrite Operation:\nWhen writing to this register, the VECTORKEY field need to be set to 0x05FA, otherwise the write operation would be ignored. The VECTORKEY filed is used to prevent accidental write to this register from resetting the system or clearing of the exception status.\nRead Operation:\nRead as 0xFA05.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SCR</displayName>
          <description>System Control Register</description>
          <addressOffset>0xD10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SLEEPONEXIT</name>
              <description>Sleep-On-Exit Enable Bit\nThis bit indicates sleep-on-exit when returning from Handler mode to Thread mode.\nSetting this bit to 1 enables an interrupt driven application to avoid returning to an empty main application..</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Do not sleep when returning to Thread mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enter Sleep or Deep Sleep when returning from ISR to Thread mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEEPDEEP</name>
              <description>Processor Deep Sleep And Sleep Mode Selection\nControls whether the processor uses sleep or deep sleep as its low power mode:</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Sleep mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Deep Sleep mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SEVONPEND</name>
              <description>Send Event On Pending Bit\nWhen an event or interrupt enters pending state, the event signal wakes up the processor from WFE. If the processor is not waiting for an event, the event is registered and affects the next WFE.\nThe processor also wakes up on execution of an SEV instruction or an external event.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Only enabled interrupts or events can wake-up the processor, disabled interrupts are excluded</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled events and all interrupts, including disabled interrupts, can wake-up the processor</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR2</displayName>
          <description>System Handler Priority Register 2</description>
          <addressOffset>0xD1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_11</name>
              <description>Priority Of System Handler 11 - SVCall\n'0' denotes the highest priority and '3' denotes the lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SHPR3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SHPR3</displayName>
          <description>System Handler Priority Register 3</description>
          <addressOffset>0xD20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRI_14</name>
              <description>Priority Of System Handler 14 - PendSV\n'0' denotes the highest priority and '3' denotes the lowest priority</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRI_15</name>
              <description>Priority Of System Handler 15 - SysTick\n'0' denotes the highest priority and '3' denotes the lowest priority</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>INT</name>
      <description>INT Register Map</description>
      <groupName>INT</groupName>
      <baseAddress>0x50000300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>IRQ0_SRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>IRQ0_SRC</displayName>
          <description>IRQ0 (BOD) Interrupt Source Identity</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>INT_SRC</name>
              <description>Interrupt Source\nDefine the interrupt sources for interrupt event.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ1_SRC</name>
          <displayName>IRQ1_SRC</displayName>
          <description>IRQ1 (WDT) Interrupt Source Identity</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ2_SRC</name>
          <displayName>IRQ2_SRC</displayName>
          <description>IRQ2 (EINT0) Interrupt Source Identity</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ3_SRC</name>
          <displayName>IRQ3_SRC</displayName>
          <description>IRQ3 (EINT1) Interrupt Source Identity</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ4_SRC</name>
          <displayName>IRQ4_SRC</displayName>
          <description>IRQ4 (GPA/B) Interrupt Source Identity</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ5_SRC</name>
          <displayName>IRQ5_SRC</displayName>
          <description>IRQ5 (GPC/E/F) Interrupt Source Identity</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ6_SRC</name>
          <displayName>IRQ6_SRC</displayName>
          <description>IRQ6 (PWMA) Interrupt Source Identity</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ7_SRC</name>
          <displayName>IRQ7_SRC</displayName>
          <description>IRQ7 (PWMB) Interrupt Source Identity</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ8_SRC</name>
          <displayName>IRQ8_SRC</displayName>
          <description>IRQ8 (TMR0) Interrupt Source Identity</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ9_SRC</name>
          <displayName>IRQ9_SRC</displayName>
          <description>IRQ9 (TMR1) Interrupt Source Identity</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ10_SRC</name>
          <displayName>IRQ10_SRC</displayName>
          <description>IRQ10 (TMR2) Interrupt Source Identity</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ11_SRC</name>
          <displayName>IRQ11_SRC</displayName>
          <description>IRQ11 (TMR3) Interrupt Source Identity</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ12_SRC</name>
          <displayName>IRQ12_SRC</displayName>
          <description>IRQ12 (UART0/2) Interrupt Source Identity</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ13_SRC</name>
          <displayName>IRQ13_SRC</displayName>
          <description>IRQ13 (UART1) Interrupt Source Identity</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ14_SRC</name>
          <displayName>IRQ14_SRC</displayName>
          <description>IRQ14 (SPI0) Interrupt Source Identity</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ15_SRC</name>
          <displayName>IRQ15_SRC</displayName>
          <description>IRQ15 (SPI1) Interrupt Source Identity</description>
          <addressOffset>0x3C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ16_SRC</name>
          <displayName>IRQ16_SRC</displayName>
          <description>Reserved.</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ17_SRC</name>
          <displayName>IRQ17_SRC</displayName>
          <description>Reserved.</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ18_SRC</name>
          <displayName>IRQ18_SRC</displayName>
          <description>IRQ18 (I2C0) Interrupt Source Identity</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ19_SRC</name>
          <displayName>IRQ19_SRC</displayName>
          <description>IRQ19 (I2C1) Interrupt Source Identity</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ20_SRC</name>
          <displayName>IRQ20_SRC</displayName>
          <description>Reserved.</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ21_SRC</name>
          <displayName>IRQ21_SRC</displayName>
          <description>Reserved.</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ22_SRC</name>
          <displayName>IRQ22_SRC</displayName>
          <description>Reserved.</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ23_SRC</name>
          <displayName>IRQ23_SRC</displayName>
          <description>IRQ23 (USBD) Interrupt Source Identity</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ24_SRC</name>
          <displayName>IRQ24_SRC</displayName>
          <description>Reserved.</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ25_SRC</name>
          <displayName>IRQ25_SRC</displayName>
          <description>Reserved.</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ26_SRC</name>
          <displayName>IRQ26_SRC</displayName>
          <description>IRQ26 (PDMA) Interrupt Source Identity</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ27_SRC</name>
          <displayName>IRQ27_SRC</displayName>
          <description>Reserved.</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ28_SRC</name>
          <displayName>IRQ28_SRC</displayName>
          <description>IRQ28 (PWRWU) Interrupt Source Identity</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ29_SRC</name>
          <displayName>IRQ29_SRC</displayName>
          <description>IRQ29 (ADC) Interrupt Source Identity</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ30_SRC</name>
          <displayName>IRQ30_SRC</displayName>
          <description>IRQ30 (IRC) Interrupt Source Identity</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="IRQ0_SRC">
          <name>IRQ31_SRC</name>
          <displayName>IRQ31_SRC</displayName>
          <description>IRQ31 (RTC) Interrupt Source Identity</description>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register>
          <name>NMI_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>NMI_SEL</displayName>
          <description>NMI Source Interrupt Select Control Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NMI_SEL</name>
              <description>NMI Interrupt Source Selection\nThe NMI interrupt to Cortex-M0 can be selected from one of the peripheral interrupt by setting NMI_SEL.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>NMI_EN</name>
              <description>NMI Interrupt Enable Bit (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>NMI interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>NMI interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MCU_IRQ</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MCU_IRQ</displayName>
          <description>MCU Interrupt Request Source Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MCU_IRQ</name>
              <description>MCU IRQ Source Register\nThe MCU_IRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to Cortex-M0. There are two modes to generate interrupt to Cortex-M0, the normal mode and test mode.\nThe MCU_IRQ collects all interrupts from each peripheral and synchronizes them and interrupts the Cortex-M0.\nWhen the MCU_IRQ[n] is 0: Set MCU_IRQ[n] 1 will generate an interrupt to Cortex-M0 NVIC[n].\nWhen the MCU_IRQ[n] is 1 (mean an interrupt is assert), setting 1 to the MCU_IRQ[n] 1 will clear the interrupt and setting MCU_IRQ[n] 0: has no effect</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>MCU_IRQCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>MCU_IRQCR</displayName>
          <description>MCU Interrupt Request Control Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FAST_IRQ</name>
              <description>Fast IRQ Latency Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MCU IRQ latency is fixed at 13 clock cycles of HCLK, MCU will enter IRQ handler after this fixed latency when interrupt happened</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MCU IRQ latency will not fixed, MCU will enter IRQ handler as soon as possible when interrupt happened</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CLK</name>
      <description>CLK Register Map</description>
      <groupName>CLK</groupName>
      <baseAddress>0x50000200</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PWRCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PWRCON</displayName>
          <description>System Power-down Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000010</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>XTL12M_EN</name>
              <description>4~24 MHz External High Speed Crystal Oscillator (HXT) Enable Bit (Write Protect)\nThe bit default value is set by flash controller user configuration register CONFIG0 [26:24]. When the default clock source is from 4~24 MHz external high speed crystal oscillator, this  bit is set to 1 automatically.\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4 ~ 24 MHz external high speed crystal oscillators (HXT) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4~24 MHz external high speed crystal oscillator (HXT) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>XTL32K_EN</name>
              <description>32.768 KHz External Low Speed Crystal Oscillator (LXT) Enable Bit (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) Enabled (Normal operation)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC22M_EN</name>
              <description>22.1184 MHz Internal High Speed RC Oscillator (HIRC) Enable Bit (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>22.1184 MHz internal high speed RC oscillator (HIRC) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>22.1184 MHz internal high speed RC oscillator (HIRC) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC10K_EN</name>
              <description>10 KHz Internal Low Speed RC Oscillator (LIRC) Enable Bit (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WU_DLY</name>
              <description>Wake-Up Delay Counter Enable Bit (Write Protect)\nWhen the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.\nThe delayed clock cycle is 4096 clock cycles when chip work at external 4~24 MHz high speed crystal, and 256 clock cycles when chip work at internal 22.1184 MHz high speed oscillator.\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock cycles delay Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock cycles delay Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WU_INT_EN</name>
              <description>Power-Down Mode Wake-Up Interrupt Enable Bit (Write Protect)\nNote1: The interrupt will occur when both PD_WU_STS and PD_WU_INT_EN are high.\nNote2: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power-down mode wake-up interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Power-down mode wake-up interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WU_STS</name>
              <description>Power-Down Mode Wake-Up Interrupt Status\nSet by 'Power-down wake-up event', it indicates that resume from Power-down mode' \nThe flag is set if the GPIO, USB, UART, WDT, I2C, TIMER, BOD or RTC wake-up occurred\nWrite 1 to clear the bit to 0.\nNote: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_DOWN_EN</name>
              <description>System Power-Down Enable Bit (Write Protect)\nWhen this bit is set to 1, Power-down mode is enabled and chip Power-down behavior will depends on the PD_WAIT_CPU bit\n(a) If the PD_WAIT_CPU is 0, the chip enters Power-down mode immediately after the PWR_DOWN_EN bit set.\n(b) if the PD_WAIT_CPU is 1, the chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode (recommend)\nWhen chip wakes up from Power-down mode, this bit is cleared by hardware. User needs to set this bit again for next Power-down.\nIn Power-down mode, 4~24 MHz external high speed crystal oscillator and the 22.1184 MHz internal high speed RC oscillator will be disabled in this mode, but the 32.768 kHz external low speed crystal oscillator and 10 kHz internal low speed oscillator are not controlled by Power-down mode.\nIn Power- down mode, the PLL and system clock are disabled, and ignored the clock source selection. The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from 32.768 kHz external low speed crystal oscillator or the internal 10 kHz low speed oscillator.\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip operating normally or chip in Idle mode because of WFI command</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip enters Power-down mode instantly or waits CPU sleep command WFI</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PD_WAIT_CPU</name>
              <description>Power-Down Entry Condition Control (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip enters Power-down mode when the PWR_DOWN_EN bit is set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip enters Power- down mode when the both PD_WAIT_CPU and PWR_DOWN_EN bits are set to 1 and CPU run WFI instruction</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OSC48M_EN</name>
              <description>48 MHz Internal High Speed RC Oscillator (HIRC48) Enable Bit (Write Protect)\nNote: This bit is write protected. Refer to the SYS_REGLCTL register.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>48 MHz internal high speed RC oscillator (HIRC48) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>48 MHz internal high speed RC oscillator (HIRC48) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AHBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AHBCLK</displayName>
          <description>AHB Devices Clock Enable Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_EN</name>
              <description>PDMA Controller Clock Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA peripherial clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA peripherial clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISP_EN</name>
              <description>Flash ISP Controller Clock Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Flash ISP peripherial clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Flash ISP peripherial clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EBI_EN</name>
              <description>EBI Controller Clock Enable Control</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI engine clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI engine clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>APBCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>APBCLK</displayName>
          <description>APB Devices Clock Enable Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>WDT_EN</name>
              <description>Watchdog Timer Clock Enable Bit (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog Timer clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog Timer clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_EN</name>
              <description>Real-Time-Clock APB Interface Clock Enable Bit\nThis bit is used to control the RTC APB clock only, The RTC peripheral clock source is selected from RTC_SEL_10K(CLKSEL2[18]). It can be selected to the 32.768 kHz external low speed crystal oscillator or 10 kHz internal low speed RC oscillator.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_EN</name>
              <description>Timer0 Clock Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_EN</name>
              <description>Timer1 Clock Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_EN</name>
              <description>Timer2 Clock Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_EN</name>
              <description>Timer3 Clock Enable Bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer3 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer3 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FDIV_EN</name>
              <description>Frequency Divider Output Clock Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FDIV clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FDIV clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C0_EN</name>
              <description>I2C0 Clock Enable Bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C1_EN</name>
              <description>I2C1 Clock Enable Bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_EN</name>
              <description>SPI0 Clock Enable Bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_EN</name>
              <description>SPI1 Clock Enable Bit</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_EN</name>
              <description>UART0 Clock Enable Bit</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART0 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART0 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_EN</name>
              <description>UART1 Clock Enable Bit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART1 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART1 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART2_EN</name>
              <description>UART2 Clock Enable Bit</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART2 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART2 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01_EN</name>
              <description>PWM_01 Clock Enable Bit</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM01 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM01 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM23_EN</name>
              <description>PWM_23 Clock Enable Bit</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM23 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM23 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM45_EN</name>
              <description>PWM_45 Clock Enable Bit</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM45 clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM45 clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USBD_EN</name>
              <description>USB 2.0 FS Device Controller Clock Enable Bit</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_EN</name>
              <description>Analog-Digital-Converter (ADC) Clock Enable Bit</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC clock Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC clock Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSTATUS</displayName>
          <description>Clock Status Monitor Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFF00</resetMask>
          <fields>
            <field>
              <name>XTL12M_STB</name>
              <description>4~24 MHz External High Speed Crystal Oscillator (HXT) Clock Source Stable Flag (Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4~24 MHz external high speed crystal oscillator (HXT) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4~24 MHz external high speed crystal oscillator (HXT) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>XTL32K_STB</name>
              <description>32.768 KHz External Low Speed Crystallator Oscillator (LXT) Clock Source Stable Flag (Read Only)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>32.768 kHz external low speed crystal oscillator (LXT) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PLL_STB</name>
              <description>Internal PLL Clock Source Stable Flag (Read Only)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Internal PLL clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal PLL clock is stable in normal mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OSC10K_STB</name>
              <description>Internal 10 KHz Low Speed Oscillator (LIRC) Clock Source Stable Flag (Read Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) clock  is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>10 kHz internal low speed RC oscillator (LIRC) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OSC22M_STB</name>
              <description>22.1184 MHz Internal High Speed RC Oscillator (HIRC) Clock Source Stable Flag (Read Only)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>22.1184 MHz internal high speed RC oscillator (HIRC) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>22.1184 MHz internal high speed RC oscillator (HIRC) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>OSC48M_STB</name>
              <description>48 MHz Internal High Speed RC Oscillator (HIRC48) Clock Source Stable Flag (Read Only)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>48MHz internal high speed RC oscillator (HIRC48) clock is not stable or disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>48MHz internal high speed RC oscillator (HIRC48) clock is stable and enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_SW_FAIL</name>
              <description>Clock Switching Fail Flag (Read Only)\nThis bit is an index that if current system clock source is match as user defined at HCLK_S (CLKSEL[2:0]). When user switch system clock, the system clock source will keep old clock until the new clock is stable. During the period that waiting new clock stable, this bit will be an index shows system clock source is not match as user wanted.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock switching success</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock switching failure</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL0</displayName>
          <description>Clock Source Select Control Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000030</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>HCLK_S</name>
              <description>HCLK Clock Source Select (Write Protect)\nBefore clock switching, the related clock sources (both pre-select and new-select) must be enabled\nThe 3-bit default value is reloaded from the value of CFOSC (CONFIG0[26:24]) in user configuration register of Flash controller by any reset. Therefore the default value is either 000b or 111b.\nThese bits are protected bit, It means programming this bit needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from PLL clock</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from  22.1184 MHz internalhigh speed RC oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STCLK_S</name>
              <description>Cortex-M0 SysTick Clock Source Select (Write Protect)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock/2</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from HCLK/2</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock/2</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_S</name>
              <description>USB Clock Source Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 48 MHz high speed RC oscillator clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL1</displayName>
          <description>Clock Source Select Control Register 1</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WDT_S</name>
              <description>Watchdog Timer Clock Source Select (Write Protect)\nNote: This bit is the protected bit, and programming it needs to write '59h', '16h', and '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Reserved.</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK/2048 clock</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_S</name>
              <description>ADC Clock Source Select</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_S</name>
              <description>SPI0 Clock Source Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from HCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_S</name>
              <description>SPI1 Clock Source Selection</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from PLL clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from HCLK</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR0_S</name>
              <description>TIMER0 Clock Source Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external trigger</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR1_S</name>
              <description>TIMER1 Clock Source Selection</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external trigger</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR2_S</name>
              <description>TIMER2 Clock Source Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from external 4~24 MHz high speed crystal oscillator clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from external 32.768 kHz low speed crystal oscillator clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external trigger</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from internal 10 kHz low speed RC oscillator clock</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from internal 22.1184 MHz high speed RC oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TMR3_S</name>
              <description>TIMER3 Clock Source Selection</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from external trigger</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_S</name>
              <description>UART Clock Source Selection</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from PLL clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01_S</name>
              <description>PWM0 And PWM1 Clock Source Selection\nPWM0 and PWM1 used the same peripheral clock source; both of them used the same prescaler. The peripheral clock source of PWM0 and PWM1 is defined by PWM01_S (CLKSEL1[29:28]) and PWM01_S_E (CLKSEL2[8]).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM23_S</name>
              <description>PWM2 And PWM3 Clock Source Selection\nPWM2 and PWM3 used the same peripheral clock source; both of them used the same prescaler. The peripheral clock source of PWM2 and PWM3 is defined by PWM23_S (CLKSEL1[31:30]) and PWM23_S_E (CLKSEL2[9]).</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock.\nReserved</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock.\nReserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK.\nReserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock.\nClock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKDIV</displayName>
          <description>Clock Divider Number Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>HCLK_N</name>
              <description>HCLK Clock Divide Number From HCLK Clock Source</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_N</name>
              <description>USB Clock Divide Number From PLL Clock</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_N</name>
              <description>UART Clock Divide Number From UART Clock Source</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_N</name>
              <description>ADC Clock Divide Number From ADC Clock Source</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLKSEL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLKSEL2</displayName>
          <description>Clock Source Select Control Register 2</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x000200FF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRQDIV_S</name>
              <description>Clock Divider Clock Source Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM45_S</name>
              <description>PWM4 And PWM5 Clock Source Selection\nPWM4 and PWM5 used the same peripheral clock source; both of them used the same prescaler. The peripheral clock source of PWM4 and PWM5 is defined by PWM45_S (CLKSEL2[5:4]) and PWM45_S_E (CLKSEL2[10]).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 4~24 MHz external high speed crystal oscillator clock.\nReserved</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock.\nReserved</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK.\nReserved</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 22.1184 MHz internal high speed RC oscillator clock.\nClock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01_S_E</name>
              <description>PWM0 And PWM1 Clock Source Selection Extend\nPWM0 and PWM1 used the same peripheral clock source; both of them used the same prescaler. The peripheral clock source of PWM0 and PWM1 is defined by PWM01_S (CLKSEL1[29:28]) and PWM01_S_E (CLKSEL2[8]).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM23_S_E</name>
              <description>PWM2 And PWM3 Clock Source Selection Extend\nPWM2 and PWM3 used the same peripheral clock source; both of them used the same prescaler. The perpherial clock source of PWM2 and PWM3 is defined by PWM23_S (CLKSEL1[31:30]) and PWM23_S_E (CLKSEL2[9]).</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM45_S_E</name>
              <description>PWM4 And PWM5 Clock Source Selection Extend\nPWM4 and PWM5 used the same peripheral clock source; both of them used the same prescaler. The peripheral clock source of PWM4 and PWM5 is defined by PWM45_S (CLKSEL2[5:4]) and PWM45_S_E (CLKSEL2[10]).</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WWDT_S</name>
              <description>Window Watchdog Timer Clock Source Selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Clock source from HCLK/2048 clock</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTC_SEL_10K</name>
              <description>RTC Clock Source Selection</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Clock source from 32.768 kHz external low speed crystal oscillator clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock source from 10 kHz internal low speed RC oscillator clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PLLCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PLLCON</displayName>
          <description>PLL Control Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x0005C22E</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FB_DV</name>
              <description>PLL Feedback Divider Control Bits\nRefer to the formulas below the table.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IN_DV</name>
              <description>PLL Input Divider Control Bits\nRefer to the formulas below the table.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OUT_DV</name>
              <description>PLL Output Divider Control Bits\nRefer to the formulas below the table.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD</name>
              <description>Power-Down Mode\nIf the PWR_DOWN_EN bit is set to 1 in PWRCON register, the PLL will enter Power-down mode too.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL is in Normal mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL is in Power-down mode (default)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BP</name>
              <description>PLL Bypass Control</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL is in Normal mode (default)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL clock output is same as PLL source clock input</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>OE</name>
              <description>PLL OE (FOUT Enable) Pin Control</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL FOUT Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL FOUT is fixed low</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PLL_SRC</name>
              <description>PLL Source Clock Selection</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PLL source clock from 4~24 MHz external high speed crystal oscillator</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PLL source clock from 22.1184 MHz internal high speed RC oscillator</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FRQDIV</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FRQDIV</displayName>
          <description>Frequency Divider Control Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FSEL</name>
              <description>Divider Output Frequency Selection Bits\nThe formula of output frequency is\nFin is the input clock frequency.\nFout is the frequency of divider output clock.\nN is the 4-bit value of FSEL[3:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_EN</name>
              <description>Frequency Divider Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Frequency Divider function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Frequency Divider function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER1</name>
              <description>Frequency Divider One Enable Bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Frequency divider will output clock with source frequency divided by FSEL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Frequency divider will output clock with source frequency</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKO_1HZ_EN</name>
              <description>Clock Output 1Hz Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1 Hz clock output for 32.768 kHz external low speed crystal oscillator clock frequency compensation Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1 Hz clock output for 32.768 kHz external low speed crystal oscillator clock frequency compensation Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FMC</name>
      <description>FMC Register Map</description>
      <groupName>FMC</groupName>
      <baseAddress>0x5000C000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ISPCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPCON</displayName>
          <description>ISP Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPEN</name>
              <description>ISP Enable Bit (Write Protect )\nISP function enable bit. Set this bit to enable ISP function.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BS</name>
              <description>Boot Select (Write Protect )\nSet/clear this bit to select next booting from LDROM/APROM, respectively. This bit also functions as chip booting status flag, which can be used to check where chip booted from. This bit is initiated with the inversed value of CBS in CONFIG0 after any reset is happened except CPU reset (RSTS_CPU is 1) or system reset (RSTS_SYS) is happened</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Boot from APROM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Boot from LDROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APUEN</name>
              <description>APROM Update Enable Bit (Write Protect)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>APROM cannot be updated when chip runs in APROM</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>APROM can be updated when chip runs in APROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFGUEN</name>
              <description>Enable Config Update By ISP (Write Protect)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP update config-bit Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP update config-bit Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LDUEN</name>
              <description>LDROM Update Enable Bit (Write Protect)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LDROM cannot be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LDROM can be updated when chip runs in APROM</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISPFF</name>
              <description>ISP Fail Flag (Write Protect)\nThis bit is set by hardware when a triggered ISP meets any of the following conditions:\n(1) APROM writes to itself if APUEN is set to 0\n(2) LDROM writes to itself if LDUEN is set to 0\n(3) CONFIG is erased/programmed if CFGUEN is set to 0\n(4) Destination address is illegal, such as over an available range\nWrite 1 to clear to this bit to 0.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPADR</displayName>
          <description>ISP Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPADR</name>
              <description>ISP Address\nThe NuMicro NUC029 series has a maximum of 32Kx32 (128 KB) embedded Flash, which supports word program only. ISPADR[1:0] must be kept 00b for ISP operation.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPDAT</displayName>
          <description>ISP Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPDAT</name>
              <description>ISP Data\nWrite data to this register before ISP program operation\nRead data from this register after ISP read operation</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPCMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPCMD</displayName>
          <description>ISP Command Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPCMD</name>
              <description>ISP Command\nISP command table is shown below:</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Read</description>
                    <value>0x00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Read Unique ID</description>
                    <value>0x04</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Read Company ID (0xDA)</description>
                    <value>0x0b</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>33</name>
                    <description>Program</description>
                    <value>0x21</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>34</name>
                    <description>Page Erase</description>
                    <value>0x22</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>46</name>
                    <description>Set Vector Page Re-Map</description>
                    <value>0x2e</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPTRG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPTRG</displayName>
          <description>ISP Trigger Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPGO</name>
              <description>ISP Start Trigger (Write-Protection Bit)\nWrite 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.\nThis bit is the protected bit, It means programming this bit needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP operation finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP progressed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DFBADR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DFBADR</displayName>
          <description>Data Flash Base Address</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFF00000</resetMask>
          <fields>
            <field>
              <name>DFBADR</name>
              <description>Data Flash Base Address\nThis register indicates Data Flash start address. It is read only.\nTthe Data Flash size is defined by user configuration, register content is loaded from CONFIG1 when chip is powered on.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FATCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FATCON</displayName>
          <description>Flash Access Time Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FOMSEL0</name>
              <description>Chip Frequency Optimization Mode Select 0 (Write-Protection Bit)\nWhen CPU frequency is lower than 72 MHz, user can modify flash access delay cycle by FOMSEL1 and FOMSEL0 to improve system performance.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>FOMSEL1</name>
              <description>Chip Frequency Optimization Mode Select1 (Write-protection Bit)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ISPSTA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ISPSTA</displayName>
          <description>ISP Status Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISPGO</name>
              <description>ISP Start Trigger (Read Only)\nWrite 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.\nNote: This bit is the same as ISPTRG bit0</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ISP operation finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ISP operation progressed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CBS</name>
              <description>Chip Boot Selection (Read Only)\nThis is a mirror of CBS in CONFIG0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ISPFF</name>
              <description>ISP Fail Flag (Write-Protection Bit)\nThis bit is set by hardware when a triggered ISP meets any of the following conditions:\n(1) APROM writes to itself\n(2) LDROM writes to itself\n(3) CONFIG is erased/programmed if CFGUEN is set to 0\n(4) Destination address is illegal, such as over an available range\nWrite 1 to clear this bit.\nNote: The function of this bit is the same as ISPCON bit6</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VECMAP</name>
              <description>Vector Page Mapping Address (Read Only)\nThe current flash address space 0x0000_0000~0x0000_01FF is mapping to address {VECMAP[11:0], 9'h000} ~ {VECMAP[11:0], 9'h1FF}</description>
              <bitOffset>9</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EBI</name>
      <description>EBI Register Map</description>
      <groupName>EBI</groupName>
      <baseAddress>0x50010000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>EBICON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>EBICON</displayName>
          <description>External Bus Interface General Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ExtEN</name>
              <description>EBI Enable\nThis bit is the functional enable bit for EBI.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ExtBW16</name>
              <description>EBI Data Width 16-bit/8-bit\nThis bit defines if the data bus is 8-bit or 16-bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI data width is 8-bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI data width is 16-bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MCLKDIV</name>
              <description>External Output Clock Divider</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExttALE</name>
              <description>Expand Time of ALE\nThis field is used for control the ALE pulse width (tALE) for latch the address </description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>EXTIME</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>EXTIME</displayName>
          <description>External Bus Interface Timing Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ExttACC</name>
              <description>EBI Data Access Time\nExttACC defines data access time (tACC).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExttAHD</name>
              <description>EBI Data Access Hold Time\nExttAHD defines data access hold time (tAHD).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExtIW2X</name>
              <description>Idle State Cycle After Write\nWhen write action is finished, idle state is inserted and nCS signal return to high if ExtIW2X is not zero.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ExtIR2R</name>
              <description>Idle State Cycle Between Read-Read\nWhen read action is finished and the next action is going to read, idle state is inserted and nCS signal return to high if ExtIR2R is not zero.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>EBICON2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>EBICON2</displayName>
          <description>External Bus Interface General Control Register 2</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WBUFF_EN</name>
              <description>EBI Write Buffer Enable</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>EBI write buffer disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>EBI write buffer enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RAHD_OFF</name>
              <description>Access Hold Time Disable Control When Read</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>tAHD is controlled by ExttAHD when read through EBI</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>No tAHD when read through EBI</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAHD_OFF</name>
              <description>Access Hold Time Disable Control When Write</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>tAHD is controlled by ExttAHD when write through EBI</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>No tAHD when write through EBI</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO Register Map</description>
      <groupName>GPIO</groupName>
      <baseAddress>0x50004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xC0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x100</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x140</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x180</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x200</offset>
        <size>0xC0</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x300</offset>
        <size>0x50</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>GPIOA_PMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_PMD</displayName>
          <description>GPIO Port A Pin I/O Mode Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>PMD0</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD1</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD2</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD3</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD4</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD5</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD6</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD7</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD8</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD9</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD10</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD11</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD12</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD13</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD14</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PMD15</name>
              <description>GPIOx I/O Pin[N] Mode Control\nDetermine each I/O mode of GPIOx pins.\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [n] pin is in Input mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [n] pin is in Push-pull Output mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>GPIO port [n] pin is in Open-drain Output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>GPIO port [n] pin is in Quasi-bidirectional mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_OFFD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_OFFD</displayName>
          <description>GPIO Port A Pin Digital Input Path Disable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OFFD</name>
              <description>GPIOx Pin[N] Digital Input Path Disable Bit\nEach of these bits is used to control if the digital input path of corresponding GPIO pin is disabled. If input is analog signal, users can disable GPIO digital input path to avoid current leakage.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I/O digital input path Enabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I/O digital input path Disabled (digital input tied to low)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DOUT</displayName>
          <description>GPIO Port A Data Output Value Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DOUT0</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT1</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT2</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT3</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT4</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT5</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT6</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT7</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT8</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT9</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT10</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT11</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT12</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT13</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT14</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DOUT15</name>
              <description>GPIOx Pin[N] Output Value\nEach of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIO port [A/B/C/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DMASK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DMASK</displayName>
          <description>GPIO Port A Data Output Write Mask Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DMASK0</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK1</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK2</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK3</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK4</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK5</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK6</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK7</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK8</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK9</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK10</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK11</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK12</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK13</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK14</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMASK15</name>
              <description>Port [A/B/C/E/F] Data Output Write Mask\nThese bits are used to protect the corresponding register of  GPIOx_DOUT[n] bit. When the  DMASK[n] bit is set to 1, the corresponding GPIOx_DOUT[n] bit is protected. If the write signal is masked, write data to the protect bit is ignored\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIOx_DOUT[n] bit can be updated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIOx_DOUT[n] bit protected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_PIN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_PIN</displayName>
          <description>GPIO Port A Pin Value Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFF0000</resetMask>
          <fields>
            <field>
              <name>PIN0</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN1</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN2</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN3</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN4</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN5</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN6</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN7</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN8</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN9</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN10</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN11</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN12</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN13</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN14</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PIN15</name>
              <description>Port [A/B/C/E/F] Pin Values\nEach bit of the register reflects the actual status of the respective GPIO pin. If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_DBEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_DBEN</displayName>
          <description>GPIO Port A De-bounce Enable Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBEN0</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN1</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN2</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN3</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN4</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN5</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN6</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN7</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN8</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN9</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN10</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN11</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN12</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN13</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN14</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBEN15</name>
              <description>Port [A/B/C/E/F] Input Signal De-Bounce Enable Bit\nDBEN[n] is used to enable the de-bounce function for each corresponding bit. If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0]\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit[n] de-bounce function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit[n] de-bounce function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_IMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_IMD</displayName>
          <description>GPIO Port A Interrupt Mode Control Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IMD0</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD1</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD2</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD3</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD4</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD5</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD6</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD7</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD8</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD9</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD10</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD11</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD12</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD13</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD14</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IMD15</name>
              <description>Port [A/B/C/E/F] Edge Or Level Detection Interrupt Control\nIMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge trigger interrupt</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Level trigger interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_IEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_IEN</displayName>
          <description>GPIO Port A Interrupt Enable Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>IF_EN0</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN1</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN2</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN3</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN4</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN5</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN6</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN7</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN8</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN9</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN10</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN11</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN12</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN13</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN14</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IF_EN15</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Falling Edge Or Input Level Low\nIF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function\nWhen setting the IF_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'low' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'high-to-low' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] state low-level or high-to-low change interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN0</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN1</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN2</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN3</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN4</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN5</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN6</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN7</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN8</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN9</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN10</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN11</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN12</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN13</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN14</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IR_EN15</name>
              <description>Port [A/B/C/E/F] Interrupt Enabled By Input Rising Edge Or Input Level High\nIR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wake-up function \nWhen setting the IR_EN[n] bit to 1:\nIf the interrupt is level trigger, the input PIN[n] state at level 'high' will generate the interrupt.\nIf the interrupt is edge trigger, the input PIN[n] state change from 'low-to-high' will generate the interrupt.\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PIN[n] level-high or low-to-high interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PIN[n] level-high or low-to-high interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>GPIOA_ISRC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOA_ISRC</displayName>
          <description>GPIO Port A Interrupt Source Flag Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ISRC0</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC1</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC2</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC3</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC4</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC5</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC6</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC7</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC8</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC9</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC10</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC11</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC12</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC13</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC14</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ISRC15</name>
              <description>Port [A/B/C/E/F] Interrupt Source Flag\nRead :\nNote2: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No interrupt at GPIOx[n].\nNo action</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>GPIOx[n] generates an interrupt.\nClear the corresponding pending interrupt</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOB_PMD</name>
          <displayName>GPIOB_PMD</displayName>
          <description>GPIO Port B Pin I/O Mode Control Register</description>
          <addressOffset>0x40</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOB_OFFD</name>
          <displayName>GPIOB_OFFD</displayName>
          <description>GPIO Port B Pin Digital Input Path Disable Register</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOB_DOUT</name>
          <displayName>GPIOB_DOUT</displayName>
          <description>GPIO Port B Data Output Value Register</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOB_DMASK</name>
          <displayName>GPIOB_DMASK</displayName>
          <description>GPIO Port B Data Output Write Mask Register</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOB_PIN</name>
          <displayName>GPIOB_PIN</displayName>
          <description>GPIO Port B Pin Value Register</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOB_DBEN</name>
          <displayName>GPIOB_DBEN</displayName>
          <description>GPIO Port B De-bounce Enable Register</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOB_IMD</name>
          <displayName>GPIOB_IMD</displayName>
          <description>GPIO Port B Interrupt Mode Control Register</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOB_IEN</name>
          <displayName>GPIOB_IEN</displayName>
          <description>GPIO Port B Interrupt Enable Register</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOB_ISRC</name>
          <displayName>GPIOB_ISRC</displayName>
          <description>GPIO Port B Interrupt Source Flag Register</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOC_PMD</name>
          <displayName>GPIOC_PMD</displayName>
          <description>GPIO Port C Pin I/O Mode Control Register</description>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOC_OFFD</name>
          <displayName>GPIOC_OFFD</displayName>
          <description>GPIO Port C Pin Digital Input Path Disable Register</description>
          <addressOffset>0x84</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOC_DOUT</name>
          <displayName>GPIOC_DOUT</displayName>
          <description>GPIO Port C Data Output Value Register</description>
          <addressOffset>0x88</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOC_DMASK</name>
          <displayName>GPIOC_DMASK</displayName>
          <description>GPIO Port C Data Output Write Mask Register</description>
          <addressOffset>0x8C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOC_PIN</name>
          <displayName>GPIOC_PIN</displayName>
          <description>GPIO Port C Pin Value Register</description>
          <addressOffset>0x90</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOC_DBEN</name>
          <displayName>GPIOC_DBEN</displayName>
          <description>GPIO Port C De-bounce Enable Register</description>
          <addressOffset>0x94</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOC_IMD</name>
          <displayName>GPIOC_IMD</displayName>
          <description>GPIO Port C Interrupt Mode Control Register</description>
          <addressOffset>0x98</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOC_IEN</name>
          <displayName>GPIOC_IEN</displayName>
          <description>GPIO Port C Interrupt Enable Register</description>
          <addressOffset>0x9C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOC_ISRC</name>
          <displayName>GPIOC_ISRC</displayName>
          <description>GPIO Port C Interrupt Source Flag Register</description>
          <addressOffset>0xA0</addressOffset>
       </register>
       <register>
          <name>GPIOD_PMD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOD_PMD</displayName>
          <description>GPIO Port D Pin I/O Mode Control Register</description>
          <addressOffset>0xC0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>GPIOD_OFFD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOD_OFFD</displayName>
          <description>GPIO Port D Pin Digital Input Path Disable Register</description>
          <addressOffset>0xC4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>GPIOD_DOUT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOD_DOUT</displayName>
          <description>GPIO Port D Data Output Value Register</description>
          <addressOffset>0xC8</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000FFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register>
          <name>GPIOD_DMASK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>GPIOD_DMASK</displayName>
          <description>GPIO Port D Data Output Write Mask Register</description>
          <addressOffset>0xCC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOE_PMD</name>
          <displayName>GPIOE_PMD</displayName>
          <description>GPIO Port E Pin I/O Mode Control Register</description>
          <addressOffset>0x100</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOE_OFFD</name>
          <displayName>GPIOE_OFFD</displayName>
          <description>GPIO Port E Pin Digital Input Path Disable Register</description>
          <addressOffset>0x104</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOE_DOUT</name>
          <displayName>GPIOE_DOUT</displayName>
          <description>GPIO Port E Data Output Value Register</description>
          <addressOffset>0x108</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOE_DMASK</name>
          <displayName>GPIOE_DMASK</displayName>
          <description>GPIO Port E Data Output Write Mask Register</description>
          <addressOffset>0x10C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOE_PIN</name>
          <displayName>GPIOE_PIN</displayName>
          <description>GPIO Port E Pin Value Register</description>
          <addressOffset>0x110</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOE_DBEN</name>
          <displayName>GPIOE_DBEN</displayName>
          <description>GPIO Port E De-bounce Enable Register</description>
          <addressOffset>0x114</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOE_IMD</name>
          <displayName>GPIOE_IMD</displayName>
          <description>GPIO Port E Interrupt Mode Control Register</description>
          <addressOffset>0x118</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOE_IEN</name>
          <displayName>GPIOE_IEN</displayName>
          <description>GPIO Port E Interrupt Enable Register</description>
          <addressOffset>0x11C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOE_ISRC</name>
          <displayName>GPIOE_ISRC</displayName>
          <description>GPIO Port E Interrupt Source Flag Register</description>
          <addressOffset>0x120</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PMD">
          <name>GPIOF_PMD</name>
          <displayName>GPIOF_PMD</displayName>
          <description>GPIO Port F Pin I/O Mode Control Register</description>
          <addressOffset>0x140</addressOffset>
       </register>
       <register derivedFrom="GPIOA_OFFD">
          <name>GPIOF_OFFD</name>
          <displayName>GPIOF_OFFD</displayName>
          <description>GPIO Port F Pin Digital Input Path Disable Register</description>
          <addressOffset>0x144</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DOUT">
          <name>GPIOF_DOUT</name>
          <displayName>GPIOF_DOUT</displayName>
          <description>GPIO Port F Data Output Value Register</description>
          <addressOffset>0x148</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DMASK">
          <name>GPIOF_DMASK</name>
          <displayName>GPIOF_DMASK</displayName>
          <description>GPIO Port F Data Output Write Mask Register</description>
          <addressOffset>0x14C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_PIN">
          <name>GPIOF_PIN</name>
          <displayName>GPIOF_PIN</displayName>
          <description>GPIO Port F Pin Value Register</description>
          <addressOffset>0x150</addressOffset>
       </register>
       <register derivedFrom="GPIOA_DBEN">
          <name>GPIOF_DBEN</name>
          <displayName>GPIOF_DBEN</displayName>
          <description>GPIO Port F De-bounce Enable Register</description>
          <addressOffset>0x154</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IMD">
          <name>GPIOF_IMD</name>
          <displayName>GPIOF_IMD</displayName>
          <description>GPIO Port F Interrupt Mode Control Register</description>
          <addressOffset>0x158</addressOffset>
       </register>
       <register derivedFrom="GPIOA_IEN">
          <name>GPIOF_IEN</name>
          <displayName>GPIOF_IEN</displayName>
          <description>GPIO Port F Interrupt Enable Register</description>
          <addressOffset>0x15C</addressOffset>
       </register>
       <register derivedFrom="GPIOA_ISRC">
          <name>GPIOF_ISRC</name>
          <displayName>GPIOF_ISRC</displayName>
          <description>GPIO Port F Interrupt Source Flag Register</description>
          <addressOffset>0x160</addressOffset>
       </register>
       <register>
          <name>DBNCECON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DBNCECON</displayName>
          <description>External Interrupt De-bounce Control Register</description>
          <addressOffset>0x180</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000020</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DBCLKSEL</name>
              <description>De-Bounce Sampling Cycle Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBCLKSRC</name>
              <description>De-Bounce Counter Clock Source Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>De-bounce counter clock source is the HCLK</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>De-bounce counter clock source is the internal 10 kHz low speed oscillator</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ICLK_ON</name>
              <description>Interrupt Clock On Mode\nIt is recommended to disable this bit to save system power if no special application concern.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge detection circuit is active only if I/O pin corresponding GPIOx_IEN bit is set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>All I/O pins edge detection circuit is always active after reset</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PA0_PDIO</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PA0_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x200</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFF0</resetMask>
          <fields>
            <field>
              <name>Pxn_PDIO</name>
              <description>GPIO Px.N Pin Data Input/Output\nWrite this bit can control one GPIO pin output value\nNote3: The PA.7, PB.12, PC.4, PC.5, PC.12, PC.13 pin is ignored.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding GPIO pin set to low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding GPIO pin set to high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA1_PDIO</name>
          <displayName>PA1_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x204</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA2_PDIO</name>
          <displayName>PA2_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x208</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA3_PDIO</name>
          <displayName>PA3_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x20C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA4_PDIO</name>
          <displayName>PA4_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x210</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA5_PDIO</name>
          <displayName>PA5_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x214</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA6_PDIO</name>
          <displayName>PA6_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x218</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA7_PDIO</name>
          <displayName>PA7_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x21C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA8_PDIO</name>
          <displayName>PA8_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x220</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA9_PDIO</name>
          <displayName>PA9_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x224</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA10_PDIO</name>
          <displayName>PA10_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x228</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA11_PDIO</name>
          <displayName>PA11_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x22C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA12_PDIO</name>
          <displayName>PA12_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x230</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA13_PDIO</name>
          <displayName>PA13_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x234</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA14_PDIO</name>
          <displayName>PA14_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x238</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PA15_PDIO</name>
          <displayName>PA15_PDIO</displayName>
          <description>GPIO PA.n Pin Data Input/Output Register</description>
          <addressOffset>0x23C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PB0_PDIO</name>
          <displayName>PB0_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x240</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB1_PDIO</name>
          <displayName>PB1_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x244</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB2_PDIO</name>
          <displayName>PB2_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x248</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB3_PDIO</name>
          <displayName>PB3_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x24C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB4_PDIO</name>
          <displayName>PB4_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x250</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB5_PDIO</name>
          <displayName>PB5_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x254</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB6_PDIO</name>
          <displayName>PB6_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x258</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB7_PDIO</name>
          <displayName>PB7_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x25C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB8_PDIO</name>
          <displayName>PB8_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x260</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB9_PDIO</name>
          <displayName>PB9_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x264</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB10_PDIO</name>
          <displayName>PB10_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x268</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB11_PDIO</name>
          <displayName>PB11_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x26C</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB12_PDIO</name>
          <displayName>PB12_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x270</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB13_PDIO</name>
          <displayName>PB13_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x274</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB14_PDIO</name>
          <displayName>PB14_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x278</addressOffset>
       </register>
       <register derivedFrom="PB0_PDIO">
          <name>PB15_PDIO</name>
          <displayName>PB15_PDIO</displayName>
          <description>GPIO PB.n Pin Data Input/Output Register</description>
          <addressOffset>0x27C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PC0_PDIO</name>
          <displayName>PC0_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x280</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC1_PDIO</name>
          <displayName>PC1_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x284</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC2_PDIO</name>
          <displayName>PC2_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x288</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC3_PDIO</name>
          <displayName>PC3_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x28C</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC4_PDIO</name>
          <displayName>PC4_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x290</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC5_PDIO</name>
          <displayName>PC5_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x294</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC6_PDIO</name>
          <displayName>PC6_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x298</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC7_PDIO</name>
          <displayName>PC7_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x29C</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC8_PDIO</name>
          <displayName>PC8_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x2A0</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC9_PDIO</name>
          <displayName>PC9_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x2A4</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC10_PDIO</name>
          <displayName>PC10_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x2A8</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC11_PDIO</name>
          <displayName>PC11_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x2AC</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC12_PDIO</name>
          <displayName>PC12_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x2B0</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC13_PDIO</name>
          <displayName>PC13_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x2B4</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC14_PDIO</name>
          <displayName>PC14_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x2B8</addressOffset>
       </register>
       <register derivedFrom="PC0_PDIO">
          <name>PC15_PDIO</name>
          <displayName>PC15_PDIO</displayName>
          <description>GPIO PC.n Pin Data Input/Output Register</description>
          <addressOffset>0x2BC</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PE0_PDIO</name>
          <displayName>PE0_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x300</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE1_PDIO</name>
          <displayName>PE1_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x304</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE2_PDIO</name>
          <displayName>PE2_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x308</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE3_PDIO</name>
          <displayName>PE3_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x30C</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE4_PDIO</name>
          <displayName>PE4_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x310</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE5_PDIO</name>
          <displayName>PE5_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x314</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE6_PDIO</name>
          <displayName>PE6_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x318</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE7_PDIO</name>
          <displayName>PE7_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x31C</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE8_PDIO</name>
          <displayName>PE8_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x320</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE9_PDIO</name>
          <displayName>PE9_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x324</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE10_PDIO</name>
          <displayName>PE10_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x328</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE11_PDIO</name>
          <displayName>PE11_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x32C</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE12_PDIO</name>
          <displayName>PE12_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x330</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE13_PDIO</name>
          <displayName>PE13_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x334</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE14_PDIO</name>
          <displayName>PE14_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x338</addressOffset>
       </register>
       <register derivedFrom="PE0_PDIO">
          <name>PE15_PDIO</name>
          <displayName>PE15_PDIO</displayName>
          <description>GPIO PE.n Pin Data Input/Output Register</description>
          <addressOffset>0x33C</addressOffset>
       </register>
       <register derivedFrom="PA0_PDIO">
          <name>PF0_PDIO</name>
          <displayName>PF0_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output Register</description>
          <addressOffset>0x340</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF1_PDIO</name>
          <displayName>PF1_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output Register</description>
          <addressOffset>0x344</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF2_PDIO</name>
          <displayName>PF2_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output Register</description>
          <addressOffset>0x348</addressOffset>
       </register>
       <register derivedFrom="PF0_PDIO">
          <name>PF3_PDIO</name>
          <displayName>PF3_PDIO</displayName>
          <description>GPIO PF.n Pin Data Input/Output Register</description>
          <addressOffset>0x34C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CRC</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008E00</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0xC</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x14</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x1C</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>CRC_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_CTL</displayName>
          <description>CRC Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x20000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRCCEN</name>
              <description>CRC Channel Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC operation Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_RST</name>
              <description>CRC Engine Reset\nNote: When operated in CPU PIO mode, setting this bit will reload the initial seed value (CRC_SEED register).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal CRC state machine and internal buffer. The others contents of CRC_CTL register will not be cleared. This bit will be cleared automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nThis bit is used to trigger the CRC DMA transfer.\nNote1: If this bit asserts which indicates the CRC engine operation in CRC DMA mode, do not fill in any data in CRC_WDATA register.\nNote2: When CRC DMA transfer completed, this bit will be cleared automatically.\nNote3: If the bus error occurs when CRC DMA transfer data, all CRC DMA transfer will be stopped. Software must reset all DMA channel before trigger DMA again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC DMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WDATA_RVS</name>
              <description>Write Data Order Reverse\nThis bit is used to enable the bit order reverse function for write data value in CRC_WDATA register.\nNote: If the write data is 0xAABBCCDD, the bit order reverse for CRC write data in is 0x55DD33BB</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit order reverse for CRC write data in Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit order reverse for CRC write data in Enabled (per byte)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHECKSUM_RVS</name>
              <description>Checksum Reverse\nThis bit is used to enable the bit order reverse function for write data value in CRC_CHECKSUM register.\nNote: If the checksum result is 0XDD7B0F2E, the bit order reverse for CRC checksum is 0x74F0DEBB</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit order reverse for CRC checksum Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit order reverse for CRC checksum Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WDATA_COM</name>
              <description>Write Data 1's Complement\nThis bit is used to enable the 1's complement function for write data value in CRC_WDATA register.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1's complement for CRC write data in Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1's complement for CRC write data in Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHECKSUM_COM</name>
              <description>Checksum 1's Complement\nThis bit is used to enable the 1's complement function for checksum result in CRC_CHECKSUM register.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>1's complement for CRC checksum Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>1's complement for CRC checksum Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CPU_WDLEN</name>
              <description>CPU Write Data Length\nThis field indicates the CPU write data length only when operating in CPU PIO mode.\nNote1: This field is only valid when operating in CPU PIO mode.\nNote2: When the write data length is 8-bit mode, the valid data in CRC_WDATA register is only CRC_WDATA [7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_WDATA register is only CRC_WDATA [15:0].</description>
              <bitOffset>28</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The write data length is 8-bit mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The write data length is 16-bit mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The write data length is 32-bit mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_MODE</name>
              <description>CRC Polynomial Mode\nThis field indicates the CRC operation polynomial mode.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CRC-CCITT Polynomial Mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC-8 Polynomial Mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>CRC-16 Polynomial Mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>CRC-32 Polynomial Mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMASAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMASAR</displayName>
          <description>CRC DMA Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_DMASAR</name>
              <description>CRC DMA Transfer Source Address Register\nThis field indicates a 32-bit source address of CRC DMA.\nNote: The source address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMABCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMABCR</displayName>
          <description>CRC DMA Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_DMABCR</name>
              <description>CRC DMA Transfer Byte Count Register\nThis field indicates a 16-bit total transfer byte count number of CRC DMA</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMACSAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMACSAR</displayName>
          <description>CRC DMA Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_DMACSAR</name>
              <description>CRC DMA Current Source Address Register (Read Only)\nThis field indicates the current source address where the CRC DMA transfer just occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMACBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMACBCR</displayName>
          <description>CRC DMA Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_DMACBCR</name>
              <description>CRC DMA Current Remained Byte Count Register (Read Only)\nThis field indicates the current remained byte count of CRC DMA.\nNote: Setting CRC_RST (CRC_CTL[1]) bit to 1 will clear this register value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMAIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMAIER</displayName>
          <description>CRC DMA Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_TABORT_IE</name>
              <description>CRC DMA Read/Write Target Abort Interrupt Enable Bit\nEnable this bit will generate the CRC DMA Target Abort interrupt signal while CRC_TARBOT_IF (CRC_DMAISR[0]) bit is set to 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during CRC DMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during CRC DMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_BLKD_IE</name>
              <description>CRC DMA Block Transfer Done Interrupt Enable Bit\nEnable this bit will generate the CRC DMA Transfer Done interrupt signal while CRC_BLKD_IF (CRC_DMAISR[1]) bit is set to 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when CRC DMA transfer done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when CRC DMA transfer done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_DMAISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_DMAISR</displayName>
          <description>CRC DMA Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_TABORT_IF</name>
              <description>CRC DMA Read/Write Target Abort Interrupt Flag\nThis bit indicates that CRC bus has error or not during CRC DMA transfer.\nIt is cleared by writing 1 to it through software.\nNote: The bit filed indicate bus master received error response or not. If bus master received error response, it means that CRC transfer target abort is happened. DMA will stop transfer and respond this event to software then CRC state machine goes to IDLE state. When target abort occurred, software must reset DMA before transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus error response received during CRC DMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus error response received during CRC DMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_BLKD_IF</name>
              <description>CRC DMA Block Transfer Done Interrupt Flag\nThis bit indicates that CRC DMA transfer has finished or not.\nIt is cleared by writing 1 to it through software..\n(When CRC DMA transfer done, TRIG_EN (CRC_CTL[23]) bit will be cleared automatically)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished if TRIG_EN (CRC_CTL[23]) bit has enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CRC transfer done if TRIG_EN (CRC_CTL[23]) bit has enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_WDATA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_WDATA</displayName>
          <description>CRC Write Data Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_WDATA</name>
              <description>CRC Write Data Register\nWhen operating in CPU PIO mode, software can write data to this field to perform CRC operation.\nWhen operating in DMA mode, this field indicates the DMA read data from memory and cannot be written.\nNote: When the write data length is 8-bit mode, the valid data in CRC_WDATA register is only CRC_WDATA [7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_WDATA register is only CRC_WDATA [15:0].</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_SEED</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_SEED</displayName>
          <description>CRC Seed Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_SEED</name>
              <description>CRC Seed Register\nThis field indicates the CRC seed value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRC_CHECKSUM</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRC_CHECKSUM</displayName>
          <description>CRC Checksum Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-only</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRC_CHECKSUM</name>
              <description>CRC Checksum Register\nThis fields indicates the CRC checksum result</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH0</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to '1'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH1</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008100</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to '1'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH2</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008200</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to '1'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH3</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008300</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to '1'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH4</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008400</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to '1'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH5</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008500</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to '1'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH6</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008600</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to '1'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH7</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008700</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to '1'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_CH8</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008800</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x28</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x80</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_CSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSR0</displayName>
          <description>PDMA Channel x Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMACEN</name>
              <description>PDMA Channel Enable Bit\nSetting this bit to 1 enables PDMA operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SW_RST</name>
              <description>Software Engine Reset</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal state machine, pointers and internal buffer. The contents of control register will not be cleared. This bit will be automatically cleared after few clock cycles</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE_SEL</name>
              <description>PDMA Mode Selection</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Memory to Memory mode (Memory-to-Memory)</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Peripheral to Memory mode (Peripheral-to-Memory)</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Memory to Peripheral mode (Memory-to-Peripheral)</description>
                    <value>#10</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SAD_SEL</name>
              <description>Transfer Source Address Direction Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer source address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DAD_SEL</name>
              <description>Transfer Destination Address Direction Selection</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transfer destination address is increasing successively</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Transfer destination address is fixed. (This feature can be used when data where transferred from multiple sources to a single destination)</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>APB_TWS</name>
              <description>Peripheral Transfer Width Selection\nNote: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode (Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One word (32-bit) is transferred for every PDMA operation</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>One byte (8-bit) is transferred for every PDMA operation</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>One half-word (16-bit) is transferred for every PDMA operation</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIG_EN</name>
              <description>Trigger Enable Bit\nNote: When PDMA transfer completed, this bit will be cleared automatically.\nIf the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data read or write transfer Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR1</name>
          <displayName>PDMA_CSR1</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR2</name>
          <displayName>PDMA_CSR2</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR3</name>
          <displayName>PDMA_CSR3</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR4</name>
          <displayName>PDMA_CSR4</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR5</name>
          <displayName>PDMA_CSR5</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR6</name>
          <displayName>PDMA_CSR6</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR7</name>
          <displayName>PDMA_CSR7</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSR0">
          <name>PDMA_CSR8</name>
          <displayName>PDMA_CSR8</displayName>
          <description>PDMA Channel x Control Register</description>
          <alternateRegister>PDMA_CSR0</alternateRegister>
          <addressOffset>0x0</addressOffset>
       </register>
       <register>
          <name>PDMA_SAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SAR0</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SAR</name>
              <description>PDMA Transfer Source Address Register\nThis field indicates a 32-bit source address of PDMA.\nNote: The source address must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR1</name>
          <displayName>PDMA_SAR1</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR2</name>
          <displayName>PDMA_SAR2</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR3</name>
          <displayName>PDMA_SAR3</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR4</name>
          <displayName>PDMA_SAR4</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR5</name>
          <displayName>PDMA_SAR5</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR6</name>
          <displayName>PDMA_SAR6</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR7</name>
          <displayName>PDMA_SAR7</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="PDMA_SAR0">
          <name>PDMA_SAR8</name>
          <displayName>PDMA_SAR8</displayName>
          <description>PDMA Channel x Source Address Register</description>
          <alternateRegister>PDMA_SAR0</alternateRegister>
          <addressOffset>0x4</addressOffset>
       </register>
       <register>
          <name>PDMA_DAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_DAR0</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_DAR</name>
              <description>PDMA Transfer Destination Address Register\nThis field indicates a 32-bit destination address of PDMA.\nNote: The destination address must be word alignment</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR1</name>
          <displayName>PDMA_DAR1</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR2</name>
          <displayName>PDMA_DAR2</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR3</name>
          <displayName>PDMA_DAR3</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR4</name>
          <displayName>PDMA_DAR4</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR5</name>
          <displayName>PDMA_DAR5</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR6</name>
          <displayName>PDMA_DAR6</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR7</name>
          <displayName>PDMA_DAR7</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="PDMA_DAR0">
          <name>PDMA_DAR8</name>
          <displayName>PDMA_DAR8</displayName>
          <description>PDMA Channel x Destination Address Register</description>
          <alternateRegister>PDMA_DAR0</alternateRegister>
          <addressOffset>0x8</addressOffset>
       </register>
       <register>
          <name>PDMA_BCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_BCR0</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_BCR</name>
              <description>PDMA Transfer Byte Count Register\nThis field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR1</name>
          <displayName>PDMA_BCR1</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR2</name>
          <displayName>PDMA_BCR2</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR3</name>
          <displayName>PDMA_BCR3</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR4</name>
          <displayName>PDMA_BCR4</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR5</name>
          <displayName>PDMA_BCR5</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR6</name>
          <displayName>PDMA_BCR6</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR7</name>
          <displayName>PDMA_BCR7</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="PDMA_BCR0">
          <name>PDMA_BCR8</name>
          <displayName>PDMA_BCR8</displayName>
          <description>PDMA Channel x Transfer Byte Count Register</description>
          <alternateRegister>PDMA_BCR0</alternateRegister>
          <addressOffset>0xC</addressOffset>
       </register>
       <register>
          <name>PDMA_POINT0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_POINT0</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x0000FFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_POINT</name>
              <description>PDMA Internal Buffer Pointer Register (Read Only)\nThis field indicates the internal buffer pointer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT1</name>
          <displayName>PDMA_POINT1</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT2</name>
          <displayName>PDMA_POINT2</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT3</name>
          <displayName>PDMA_POINT3</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT4</name>
          <displayName>PDMA_POINT4</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT5</name>
          <displayName>PDMA_POINT5</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT6</name>
          <displayName>PDMA_POINT6</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT7</name>
          <displayName>PDMA_POINT7</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="PDMA_POINT0">
          <name>PDMA_POINT8</name>
          <displayName>PDMA_POINT8</displayName>
          <description>PDMA Channel x Internal Buffer Pointer Register</description>
          <alternateRegister>PDMA_POINT0</alternateRegister>
          <addressOffset>0x10</addressOffset>
       </register>
       <register>
          <name>PDMA_CSAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CSAR0</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CSAR</name>
              <description>PDMA Current Source Address Register (Read Only)\nThis field indicates the source address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR1</name>
          <displayName>PDMA_CSAR1</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR2</name>
          <displayName>PDMA_CSAR2</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR3</name>
          <displayName>PDMA_CSAR3</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR4</name>
          <displayName>PDMA_CSAR4</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR5</name>
          <displayName>PDMA_CSAR5</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR6</name>
          <displayName>PDMA_CSAR6</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR7</name>
          <displayName>PDMA_CSAR7</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="PDMA_CSAR0">
          <name>PDMA_CSAR8</name>
          <displayName>PDMA_CSAR8</displayName>
          <description>PDMA Channel x Current Source Address Register</description>
          <alternateRegister>PDMA_CSAR0</alternateRegister>
          <addressOffset>0x14</addressOffset>
       </register>
       <register>
          <name>PDMA_CDAR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CDAR0</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CDAR</name>
              <description>PDMA Current Destination Address Register (Read Only)\nThis field indicates the destination address where the PDMA transfer just occurred.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR1</name>
          <displayName>PDMA_CDAR1</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR2</name>
          <displayName>PDMA_CDAR2</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR3</name>
          <displayName>PDMA_CDAR3</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR4</name>
          <displayName>PDMA_CDAR4</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR5</name>
          <displayName>PDMA_CDAR5</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR6</name>
          <displayName>PDMA_CDAR6</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR7</name>
          <displayName>PDMA_CDAR7</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="PDMA_CDAR0">
          <name>PDMA_CDAR8</name>
          <displayName>PDMA_CDAR8</displayName>
          <description>PDMA Channel x Current Destination Address Register</description>
          <alternateRegister>PDMA_CDAR0</alternateRegister>
          <addressOffset>0x18</addressOffset>
       </register>
       <register>
          <name>PDMA_CBCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_CBCR0</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_CBCR</name>
              <description>PDMA Current Byte Count Register (Read Only)\nThis field indicates the current remained byte count of PDMA.\nNote: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to '1'.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR1</name>
          <displayName>PDMA_CBCR1</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR2</name>
          <displayName>PDMA_CBCR2</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR3</name>
          <displayName>PDMA_CBCR3</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR4</name>
          <displayName>PDMA_CBCR4</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR5</name>
          <displayName>PDMA_CBCR5</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR6</name>
          <displayName>PDMA_CBCR6</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR7</name>
          <displayName>PDMA_CBCR7</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDMA_CBCR0">
          <name>PDMA_CBCR8</name>
          <displayName>PDMA_CBCR8</displayName>
          <description>PDMA Channel x Current Transfer Byte Count Register</description>
          <alternateRegister>PDMA_CBCR0</alternateRegister>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>PDMA_IER0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_IER0</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IE</name>
              <description>PDMA Read/Write Target Abort Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Target abort interrupt generation Disabled during PDMA transfer</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Target abort interrupt generation Enabled during PDMA transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IE</name>
              <description>PDMA Block Transfer Done Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Interrupt generator Disabled when PDMA transfer is done</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Interrupt generator Enabled when PDMA transfer is done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER1</name>
          <displayName>PDMA_IER1</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER2</name>
          <displayName>PDMA_IER2</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER3</name>
          <displayName>PDMA_IER3</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER4</name>
          <displayName>PDMA_IER4</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER5</name>
          <displayName>PDMA_IER5</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER6</name>
          <displayName>PDMA_IER6</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER7</name>
          <displayName>PDMA_IER7</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="PDMA_IER0">
          <name>PDMA_IER8</name>
          <displayName>PDMA_IER8</displayName>
          <description>PDMA Channel x Interrupt Enable Register</description>
          <alternateRegister>PDMA_IER0</alternateRegister>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PDMA_ISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_ISR0</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TABORT_IF</name>
              <description>PDMA Read/Write Target Abort Interrupt Flag\nWrite 1 to clear this bit to 0.\nNote: This bit filed indicates bus master received ERROR response or not. If bus master received ERROR response, it means that target abort is happened. PDMA controller will stop transfer and respond this event to software then goes to IDLE state. When target abort occurred, software must reset PDMA, and then transfer those data again.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus ERROR response received</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus ERROR response received</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BLKD_IF</name>
              <description>PDMA Block Transfer Done Interrupt Flag\nThis bit indicates that PDMA has finished all transfers.\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Not finished</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Done</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR1</name>
          <displayName>PDMA_ISR1</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR2</name>
          <displayName>PDMA_ISR2</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR3</name>
          <displayName>PDMA_ISR3</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR4</name>
          <displayName>PDMA_ISR4</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR5</name>
          <displayName>PDMA_ISR5</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR6</name>
          <displayName>PDMA_ISR6</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR7</name>
          <displayName>PDMA_ISR7</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="PDMA_ISR0">
          <name>PDMA_ISR8</name>
          <displayName>PDMA_ISR8</displayName>
          <description>PDMA Channel x Interrupt Status Register</description>
          <alternateRegister>PDMA_ISR0</alternateRegister>
          <addressOffset>0x24</addressOffset>
       </register>
       <register>
          <name>PDMA_SBUF0_C0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_SBUF0_C0</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <addressOffset>0x80</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDMA_SBUF0</name>
              <description>PDMA Shared Buffer FIFO 0 (Read Only)\nEach channel has its own 1 word internal buffer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C1</name>
          <displayName>PDMA_SBUF0_C1</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C2</name>
          <displayName>PDMA_SBUF0_C2</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C3</name>
          <displayName>PDMA_SBUF0_C3</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C4</name>
          <displayName>PDMA_SBUF0_C4</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C5</name>
          <displayName>PDMA_SBUF0_C5</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C6</name>
          <displayName>PDMA_SBUF0_C6</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C7</name>
          <displayName>PDMA_SBUF0_C7</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="PDMA_SBUF0_C0">
          <name>PDMA_SBUF0_C8</name>
          <displayName>PDMA_SBUF0_C8</displayName>
          <description>PDMA Channel x Shared Buffer FIFO 0 Register</description>
          <alternateRegister>PDMA_SBUF0_C0</alternateRegister>
          <addressOffset>0x80</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PDMA_GCR</name>
      <description>PDMA Register Map</description>
      <groupName>PDMA</groupName>
      <baseAddress>0x50008F00</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PDMA_GCRCSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_GCRCSR</displayName>
          <description>PDMA Global Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLK0_EN</name>
              <description>PDMA Controller Channel 0 Clock Enable Bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK1_EN</name>
              <description>PDMA Controller Channel 1 Clock Enable Bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK2_EN</name>
              <description>PDMA Controller Channel 2 Clock Enable Bit </description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK3_EN</name>
              <description>PDMA Controller Channel 3 Clock Enable Bit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK4_EN</name>
              <description>PDMA Controller Channel 4 Clock Enable Bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK5_EN</name>
              <description>PDMA Controller Channel 5 Clock Enable Bit</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK6_EN</name>
              <description>PDMA Controller Channel 6 Clock Enable Bit</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK7_EN</name>
              <description>PDMA Controller Channel 7 Clock Enable Bit</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK8_EN</name>
              <description>PDMA Controller Channel 8 Clock Enable Bit </description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRC_CLK_EN</name>
              <description>CRC Controller Clock Enable Bit</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_PDSSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_PDSSR0</displayName>
          <description>PDMA Service Selection Control Register 0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPI0_RXSEL</name>
              <description>PDMA SPI0 RX Selection\n0000: CH0\n0001: CH1\n0010: CH2\n0011: CH3 \n0100: CH4 \n0101: CH5\n0110: CH6\n0111: CH7\n1000: CH8\nOthers : Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI0_TXSEL</name>
              <description>PDMA SPI0 TX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral SPI0 TX. Software can configure the TX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_RXSEL</name>
              <description>PDMA SPI1 RX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral SPI1 RX. Software can configure the RX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI1_TXSEL</name>
              <description>PDMA SPI1 TX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral SPI1 TX. Software can configure the TX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2_RXSEL</name>
              <description>PDMA SPI2 RX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral SPI2 RX. Software can configure the RX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI2_TXSEL</name>
              <description>PDMA SPI2 TX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral SPI2 TX. Software can configure the TX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3_RXSEL</name>
              <description>PDMA SPI3 RX Selection \nThis field defines which PDMA channel is connected to the on-chip peripheral SPI3 RX. Software can configure the RX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI3_TXSEL</name>
              <description>PDMA SPI3 TX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral SPI3 TX. Software can configure the TX channel setting by this field. The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field. Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_PDSSR1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_PDSSR1</displayName>
          <description>PDMA Service Selection Control Register 1</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>UART0_RXSEL</name>
              <description>PDMA UART0 RX Selection\n0000: CH0\n0001: CH1\n0010: CH2\n0011: CH3 \n0100: CH4 \n0101: CH5\n0110: CH6\n0111: CH7\n1000: CH8\nOthers : Reserved</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART0_TXSEL</name>
              <description>PDMA UART0 TX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral UART0 TX. Software can configure the TX channel setting by this field. The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field. Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_RXSEL</name>
              <description>PDMA UART1 RX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral UART1 RX. Software can configure the RX channel setting by this field. The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field. Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UART1_TXSEL</name>
              <description>PDMA UART1 TX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral UART1 TX. Software can configure the TX channel setting by this field. The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field. Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADC_RXSEL</name>
              <description>PDMA ADC RX Selection\nThis field defines which PDMA channel is connected to the on-chip peripheral ADC RX. Software can configure the RX channel setting by this field. The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field. Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDMA_GCRISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDMA_GCRISR</displayName>
          <description>PDMA Global Interrupt Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INTR0</name>
              <description>Interrupt Status Of Channel 0\nThis bit is the interrupt status of PDMA channel0.\nNote: This bit is read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR1</name>
              <description>Interrupt Status Of Channel 1\nThis bit is the interrupt status of PDMA channel1.\nNote: This bit is read only.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR2</name>
              <description>Interrupt Status Of Channel 2\nThis bit is the interrupt status of PDMA channel2.\nNote: This bit is read only.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR3</name>
              <description>Interrupt Status Of Channel 3\nThis bit is the interrupt status of PDMA channel3.\nNote: This bit is read only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR4</name>
              <description>Interrupt Status Of Channel 4\nThis bit is the interrupt status of PDMA channel4.\nNote: This bit is read only.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR5</name>
              <description>Interrupt Status Of Channel 5 \nThis bit is the interrupt status of PDMA channel5.\nNote: This bit is read only.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR6</name>
              <description>Interrupt Status Of Channel 6 \nThis bit is the interrupt status of PDMA channel6.\nNote: This bit is read only.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR7</name>
              <description>Interrupt Status Of Channel 7 \nThis bit is the interrupt status of PDMA channel7.\nNote: This bit is read only.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR8</name>
              <description>Interrupt Status Of Channel 8 \nThis bit is the interrupt status of PDMA channel8.\nNote: This bit is read only.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTRCRC</name>
              <description>Interrupt Status Of CRC Controller\nThis bit is the interrupt status of CRC controller\nNote: This bit is read only</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR</name>
              <description>Interrupt Status\nThis bit is the interrupt status of PDMA controller.\nNote: This bit is read only.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR01</name>
      <description>TIMER Register Map</description>
      <groupName>TIMER</groupName>
      <baseAddress>0x40010000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TCSR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCSR0</displayName>
          <description>Timer0 Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Prescale Counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDR_EN</name>
              <description>Data Load Enable Bit\nWhen TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Data Register update Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Data Register update Enabled while Timer counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>Wake Up Function Enable Bit</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up trigger event Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up trigger event Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTB</name>
              <description>Counter Mode Enable Bit \nThis bit is for external counting pin function enabled. When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer clock source. Please refer to 6.8.5.6 for detail description.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External counter mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External counter mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CACT</name>
              <description>Timer Active Status (Read Only)\nThis bit indicates the 24-bit up counter status.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24-bit up counter is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>24-bit up counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CRST</name>
              <description>Timer Reset</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset 8-bit prescale counter, 24-bit up counter value and CEN bit if CACT is 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer Operating Mode</description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Timer controller is operated in One-shot mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Timer controller is operated in Periodic mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The Timer controller is operated in Toggle-output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The Timer controller is operated in Continuous Counting mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable Bit\nIf this bit is enabled, when the timer interrupt flag TIF (TISR[0]) is set to 1, the timer interrupt signal is generated and inform to CPU.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>Timer Enable Bit</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_TMR</name>
              <description>ICE Debug Mode Acknowledge Disable Bit (Write Protect)\nTIMER counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects TIMER counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCMPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCMPR0</displayName>
          <description>Timer0 Compare Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCMP</name>
              <description>Timer Compared Value\nTCMP is a 24-bit compared value register. When the internal 24-bit up counter value is equal to TCMP value, the TIF flag will set to 1.\nNote1: Never write 0x0 or 0x1 in TCMP field, or the core will run into unknown state.\nNote2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into TCMP field. But if timer is operating at other modes, the 24-bit up counter will restart counting and using newest TCMP value to be the timer compared value if user writes a new value into TCMP field.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TISR0</displayName>
          <description>Timer0 Interrupt Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Timer Interrupt Flag\nThis bit indicates the interrupt flag status of Timer while TDR value reaches to TCMP value.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TDR value matches the TCMP value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWF</name>
              <description>Timer Wake-Up Flag\nThis bit indicates the interrupt wake-up flag status of Timer.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer does not cause CPU wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CPU wake-up from Idle or Power-down mode if Timer time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TDR0</displayName>
          <description>Timer0 Data Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nIf TDR_EN (TCSR[16]) is set to 1, TDR register will be updated continuously to monitor 24-bit up counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCAP0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCAP0</displayName>
          <description>Timer0 Capture Data Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCAP</name>
              <description>Timer Capture Data Register\nWhen TEXIF (TEXISR[0]) flag and RSTCAPSEL (TEXCON[4]) is set to 1, the current TDR value will be auto-loaded into this TCAP filed immediately.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEXCON0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEXCON0</displayName>
          <description>Timer0 External Control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_PHASE</name>
              <description>Timer External Count Pin Phase Detect Selection\nThis bit indicates the detection phase of TMx_EXT pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A falling edge of TMx_EXT pin will be counted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A rising edge of TMx_EXT pin will be counted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEX_EDGE</name>
              <description>Timer External Capture Pin Edge Detect Selection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A 1 to 0 transition on TMx_EXT pin will be detected</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A 0 to 1 transition on TMx_EXT pin will be detected</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Either 1 to 0 or 0 to 1 transition on TMx_EXT pin will be detected</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXEN</name>
              <description>Timer External Pin Function Enable Bit\nThis bit enables the RSTCAPSEL function on the TMx_EXT pin.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RSTCAPSEL function of TMx_EXT pin will be ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RSTCAPSEL function of TMx_EXT pin is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTCAPSEL</name>
              <description>Timer External Reset Counter / Timer External Capture Mode Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transition on TMx_EXT pin is using to save the TDR value into TCAP.(event capture function)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transition on TMx_EXT pin is using to reset the 24-bit up counter.(event reset counter function)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXIEN</name>
              <description>Timer External Capture Interrupt Enable Bit\nIf TEXIEN enabled, Timer will raise an external capture interrupt signal and inform to CPU while TEXIF flag is set to 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin detection Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin detection Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXDB</name>
              <description>Timer External Capture Input Pin De-Bounce Enable Bit\nIf this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce circuit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCDB</name>
              <description>Timer External Counter Input Pin De-Bounce Enable Bit\nIf this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEXISR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEXISR0</displayName>
          <description>Timer0 External Interrupt Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXIF</name>
              <description>Timer External Capture Interrupt Flag\nThis bit indicates the external capture interrupt flag status.\nWhen TEXEN (TEXCON[3]) enabled, TMx_EXT pin selected as external capture function, and a transition on TMx_EXT pin matched the TEX_EDGE (TEXCON[2:1]) setting, this flag will set to 1 by hardware.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin interrupt did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="TCSR0">
          <name>TCSR1</name>
          <displayName>TCSR1</displayName>
          <description>Timer1 Control and Status Register</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="TCMPR0">
          <name>TCMPR1</name>
          <displayName>TCMPR1</displayName>
          <description>Timer1 Compare Register</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="TISR0">
          <name>TISR1</name>
          <displayName>TISR1</displayName>
          <description>Timer1 Interrupt Status Register</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="TDR0">
          <name>TDR1</name>
          <displayName>TDR1</displayName>
          <description>Timer1 Data Register</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="TCAP0">
          <name>TCAP1</name>
          <displayName>TCAP1</displayName>
          <description>Timer1 Capture Data Register</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="TEXCON0">
          <name>TEXCON1</name>
          <displayName>TEXCON1</displayName>
          <description>Timer1 External Control Register</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="TEXISR0">
          <name>TEXISR1</name>
          <displayName>TEXISR1</displayName>
          <description>Timer1 External Interrupt Status Register</description>
          <addressOffset>0x38</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TMR23</name>
      <description>TIMER Register Map</description>
      <groupName>TIMER</groupName>
      <baseAddress>0x40110000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>TCSR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCSR2</displayName>
          <description>Timer2 Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000005</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PRESCALE</name>
              <description>Prescale Counter</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TDR_EN</name>
              <description>Data Load Enable Bit\nWhen TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Data Register update Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Data Register update Enabled while Timer counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>Wake Up Function Enable Bit</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up trigger event Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up trigger event Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CTB</name>
              <description>Counter Mode Enable Bit \nThis bit is for external counting pin function enabled. When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer clock source. Please refer to 6.8.5.6 for detail description.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External counter mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>External counter mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CACT</name>
              <description>Timer Active Status (Read Only)\nThis bit indicates the 24-bit up counter status.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24-bit up counter is not active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>24-bit up counter is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CRST</name>
              <description>Timer Reset</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset 8-bit prescale counter, 24-bit up counter value and CEN bit if CACT is 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Timer Operating Mode</description>
              <bitOffset>27</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The Timer controller is operated in One-shot mode</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The Timer controller is operated in Periodic mode</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The Timer controller is operated in Toggle-output mode</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The Timer controller is operated in Continuous Counting mode</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Interrupt Enable Bit\nIf this bit is enabled, when the timer interrupt flag TIF (TISR[0]) is set to 1, the timer interrupt signal is generated and inform to CPU.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer Interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Timer Interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CEN</name>
              <description>Timer Enable Bit</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stops/Suspends counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Starts counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_TMR</name>
              <description>ICE Debug Mode Acknowledge Disable Bit (Write Protect)\nTIMER counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects TIMER counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCMPR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCMPR2</displayName>
          <description>Timer2 Compare Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCMP</name>
              <description>Timer Compared Value\nTCMP is a 24-bit compared value register. When the internal 24-bit up counter value is equal to TCMP value, the TIF flag will set to 1.\nNote1: Never write 0x0 or 0x1 in TCMP field, or the core will run into unknown state.\nNote2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into TCMP field. But if timer is operating at other modes, the 24-bit up counter will restart counting and using newest TCMP value to be the timer compared value if user writes a new value into TCMP field.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TISR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TISR2</displayName>
          <description>Timer2 Interrupt Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Timer Interrupt Flag\nThis bit indicates the interrupt flag status of Timer while TDR value reaches to TCMP value.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TDR value matches the TCMP value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TWF</name>
              <description>Timer Wake-Up Flag\nThis bit indicates the interrupt wake-up flag status of Timer.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Timer does not cause CPU wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CPU wake-up from Idle or Power-down mode if Timer time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TDR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TDR2</displayName>
          <description>Timer2 Data Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TDR</name>
              <description>Timer Data Register\nIf TDR_EN (TCSR[16]) is set to 1, TDR register will be updated continuously to monitor 24-bit up counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCAP2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCAP2</displayName>
          <description>Timer2 Capture Data Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TCAP</name>
              <description>Timer Capture Data Register\nWhen TEXIF (TEXISR[0]) flag and RSTCAPSEL (TEXCON[4]) is set to 1, the current TDR value will be auto-loaded into this TCAP filed immediately.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>24</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEXCON2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEXCON2</displayName>
          <description>Timer2 External Control Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_PHASE</name>
              <description>Timer External Count Pin Phase Detect Selection\nThis bit indicates the detection phase of TMx_EXT pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A falling edge of TMx_EXT pin will be counted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A rising edge of TMx_EXT pin will be counted</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEX_EDGE</name>
              <description>Timer External Capture Pin Edge Detect Selection</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A 1 to 0 transition on TMx_EXT pin will be detected</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A 0 to 1 transition on TMx_EXT pin will be detected</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Either 1 to 0 or 0 to 1 transition on TMx_EXT pin will be detected</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXEN</name>
              <description>Timer External Pin Function Enable Bit\nThis bit enables the RSTCAPSEL function on the TMx_EXT pin.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RSTCAPSEL function of TMx_EXT pin will be ignored</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RSTCAPSEL function of TMx_EXT pin is active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTCAPSEL</name>
              <description>Timer External Reset Counter / Timer External Capture Mode Selection</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transition on TMx_EXT pin is using to save the TDR value into TCAP.(event capture function)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transition on TMx_EXT pin is using to reset the 24-bit up counter.(event reset counter function)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXIEN</name>
              <description>Timer External Capture Interrupt Enable Bit\nIf TEXIEN enabled, Timer will raise an external capture interrupt signal and inform to CPU while TEXIF flag is set to 1.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin detection Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin detection Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TEXDB</name>
              <description>Timer External Capture Input Pin De-Bounce Enable Bit\nIf this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce circuit.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TCDB</name>
              <description>Timer External Counter Input Pin De-Bounce Enable Bit\nIf this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx pin de-bounce Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx pin de-bounce Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TEXISR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TEXISR2</displayName>
          <description>Timer2 External Interrupt Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TEXIF</name>
              <description>Timer External Capture Interrupt Flag\nThis bit indicates the external capture interrupt flag status.\nWhen TEXEN (TEXCON[3]) enabled, TMx_EXT pin selected as external capture function, and a transition on TMx_EXT pin matched the TEX_EDGE (TEXCON[2:1]) setting, this flag will set to 1 by hardware.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TMx_EXT pin interrupt did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TMx_EXT pin interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="TCSR2">
          <name>TCSR3</name>
          <displayName>TCSR3</displayName>
          <description>Timer3 Control and Status Register</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="TCMPR2">
          <name>TCMPR3</name>
          <displayName>TCMPR3</displayName>
          <description>Timer3 Compare Register</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="TISR2">
          <name>TISR3</name>
          <displayName>TISR3</displayName>
          <description>Timer3 Interrupt Status Register</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="TDR2">
          <name>TDR3</name>
          <displayName>TDR3</displayName>
          <description>Timer3 Data Register</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="TCAP2">
          <name>TCAP3</name>
          <displayName>TCAP3</displayName>
          <description>Timer3 Capture Data Register</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="TEXCON2">
          <name>TEXCON3</name>
          <displayName>TEXCON3</displayName>
          <description>Timer3 External Control Register</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="TEXISR2">
          <name>TEXISR3</name>
          <displayName>TEXISR3</displayName>
          <description>Timer3 External Interrupt Status Register</description>
          <addressOffset>0x38</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWMA</name>
      <description>PWM Register Map</description>
      <groupName>PWM</groupName>
      <baseAddress>0x40040000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x48</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x48</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PPR</displayName>
          <description>PWM Prescaler Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CP01</name>
              <description>Clock Prescaler 0 (PWM-Timer 0 / 1 For Group A And PWM-Timer 4 / 5 For Group B)\nClock input is divided by (CP01 + 1) before it is fed to the corresponding PWM-timer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CP23</name>
              <description>Clock Prescaler 2 (PWM-Timer2 / 3 For Group A)\nClock input is divided by (CP23 + 1) before it is fed to the corresponding PWM-timer</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZI01</name>
              <description>Dead-Zone Interval For Pair Of Channel 0 And Channel 1 (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\nThese 8-bit determine the Dead-zone length.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZI23</name>
              <description>Dead-Zone Interval For Pair Of Channel2 And Channel3 (PWM2 And PWM3 Pair For PWM Group A)\nThese 8-bit determine the Dead-zone length.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSR</displayName>
          <description>PWM Clock Source Divider Select Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSR0</name>
              <description>PWM Timer 0 Clock Source Divider Selection (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\nSelect clock source divider for PWM timer 0.\n(Table is the same as CSR3)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR1</name>
              <description>PWM Timer 1 Clock Source Divider Selection (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\nSelect clock source divider for PWM timer 1.\n(Table is the same as CSR3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR2</name>
              <description>PWM Timer 2 Clock Source Divider Selection (PWM Timer 2 For Group A)\nSelect clock source divider for PWM timer 2.\n(Table is the same as CSR3)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR3</name>
              <description>PWM Timer 3 Clock Source Divider Selection (PWM Timer 3 For Group A)\nSelect clock source divider for PWM timer 3.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>8</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>16</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>1</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PCR</displayName>
          <description>PWM Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0EN</name>
              <description>PWM-Timer 0 Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding PWM-Timer stops running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding PWM-Timer starts running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0PINV</name>
              <description>PWM-Timer 0 Output Polar Inverse Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 output polar inverse Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 output polar inverse Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0INV</name>
              <description>PWM-Timer 0 Output Inverter Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0MOD</name>
              <description>PWM-Timer 0 Auto-Reload/One-Shot Mode (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\nNote: If there is a transition at this bit, it will cause CNR0 and CMR0 be cleared.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN01</name>
              <description>Dead-Zone 0 Generator Enable (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\nNote: When Dead-zone generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM group B.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN23</name>
              <description>Dead-Zone 2 Generator Enable (PWM2 And PWM3 Pair For PWM Group A)\nNote: When Dead-zone generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair for PWM group A.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1EN</name>
              <description>PWM-Timer 1 Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1PINV</name>
              <description>PWM-Timer 1 Output Polar Inverse Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM1 output polar inverse Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM1 output polar inverse Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1INV</name>
              <description>PWM-Timer 1 Output Inverter Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1MOD</name>
              <description>PWM-Timer 1 Auto-Reload/One-Shot Mode (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\nNote: If there is a transition at this bit, it will cause CNR1 and CMR1 be cleared.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2EN</name>
              <description>PWM-Timer 2 Enable (PWM Timer 2 For Group A)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2PINV</name>
              <description>PWM-Timer 2 Output Polar Inverse Enable (PWM Timer 2 For Group A)</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM2 output polar inverse Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM2 output polar inverse Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2INV</name>
              <description>PWM-Timer 2 Output Inverter Enable (PWM Timer 2 For Group A)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2MOD</name>
              <description>PWM-Timer 2 Auto-Reload/One-Shot Mode (PWM Timer 2 For Group A)\nNote: If there is a transition at this bit, it will cause CNR2 and CMR2 be cleared.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3EN</name>
              <description>PWM-Timer 3 Enable (PWM Timer 3 For Group A)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3PINV</name>
              <description>PWM-Timer 3 Output Polar Inverse Enable (PWM Timer 3 For Group A)</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM3 output polar inverse Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM3 output polar inverse Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3INV</name>
              <description>PWM-Timer 3 Output Inverter Enable (PWM Timer 3 For Group A)</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3MOD</name>
              <description>PWM-Timer 3 Auto-Reload/One-Shot Mode (PWM Timer 3 For Group A)\nNote: If there is a transition at this bit, it will cause CNR3 and CMR3 be cleared.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01TYPE</name>
              <description>PWM01 Aligned Type Selection (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-aligned type</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Center-aligned type</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM23TYPE</name>
              <description>PWM23 Aligned Type Selection (PWM2 And PWM3 Pair For PWM Group A)</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-aligned type</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Center-aligned type</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CNR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CNR0</displayName>
          <description>PWM Counter Register 0</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNRx</name>
              <description>PWM Timer Loaded Value\nCNR determines the PWM period.\nNote: Any write to CNR will take effect in next PWM cycle.\nNote: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to 0xFFFE. If CNR equal to 0xFFFF, the PWM will work unpredictable.\nNote: When CNR value is set to 0, PWM output is always high.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CMR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMR0</displayName>
          <description>PWM Comparator Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMRx</name>
              <description>PWM Comparator Register\nCMR determines the PWM duty.\nNote: Any write to CNR will take effect in next PWM cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDR0</displayName>
          <description>PWM Data Register 0</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDRx</name>
              <description>PWM Data Register\nUser can monitor PDR to know the current value in 16-bit counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR1</name>
          <displayName>CNR1</displayName>
          <description>PWM Counter Register 1</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR1</name>
          <displayName>CMR1</displayName>
          <description>PWM Comparator Register 1</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR1</name>
          <displayName>PDR1</displayName>
          <description>PWM Data Register 1</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR2</name>
          <displayName>CNR2</displayName>
          <description>PWM Counter Register 2</description>
          <addressOffset>0x24</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR2</name>
          <displayName>CMR2</displayName>
          <description>PWM Comparator Register 2</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR2</name>
          <displayName>PDR2</displayName>
          <description>PWM Data Register 2</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR3</name>
          <displayName>CNR3</displayName>
          <description>PWM Counter Register 3</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR3</name>
          <displayName>CMR3</displayName>
          <description>PWM Comparator Register 3</description>
          <addressOffset>0x34</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR3</name>
          <displayName>PDR3</displayName>
          <description>PWM Data Register 3</description>
          <addressOffset>0x38</addressOffset>
       </register>
       <register>
          <name>PBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PBCR</displayName>
          <description>PWM Backward Compatible Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCn</name>
              <description>PWM Backward Compatible Register\nRefer to the CCR0/CCR2 register bit 6, 7, 22, 23 description\nNote: It is recommended that this bit be set to 1 to prevent CFLRIx and CRLRIx from being cleared when writing CCR0/CCR2.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Configure write 0 to clear CFLRI0~3 and CRLRI0~3</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Configure write 1 to clear CFLRI0~3 and CRLRI0~3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIER</displayName>
          <description>PWM Interrupt Enable Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIE0</name>
              <description>PWM Channel 0 Period Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE1</name>
              <description>PWM Channel 1 Period Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE2</name>
              <description>PWM Channel 2 Period Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE3</name>
              <description>PWM Channel 3 Period Interrupt Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE0</name>
              <description>PWM Channel 0 Duty Interrupt Enable Bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE1</name>
              <description>PWM Channel 1 Duty Interrupt Enable Bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE2</name>
              <description>PWM Channel 2 Duty Interrupt Enable Bit</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE3</name>
              <description>PWM Channel 3 Duty Interrupt Enable Bit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INT01TYPE</name>
              <description>PWM01 Interrupt Period Type Selection Bit (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\nNote: This bit is effective when PWM in Center-aligned type only.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMIFn will be set if PWM counter underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMIFn will be set if PWM counter matches CNRn register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INT23TYPE</name>
              <description>PWM23 Interrupt Period Type Selection Bit (PWM2 And PWM3 Pair For PWM Group A)\nNote: This bit is effective when PWM in Center-aligned type only.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMIFn will be set if PWM counter underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMIFn will be set if PWM counter matches CNRn register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PIIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIIR</displayName>
          <description>PWM Interrupt Indication Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIF0</name>
              <description>PWM Channel 0 Period Interrupt Status\nThis bit is set by hardware when PWM0 counter reaches the requirement of interrupt (depend on INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF1</name>
              <description>PWM Channel 1 Period Interrupt Status\nThis bit is set by hardware when PWM1 counter reaches the requirement of interrupt (depend on INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF2</name>
              <description>PWM Channel 2 Period Interrupt Status\nThis bit is set by hardware when PWM2 counter reaches the requirement of interrupt (depend on INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF3</name>
              <description>PWM Channel 3 Period Interrupt Status\nThis bit is set by hardware when PWM3 counter reaches the requirement of interrupt (depend on INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF0</name>
              <description>PWM Channel 0 Duty Interrupt Flag\nFlag is set by hardware when channel 0 PWM counter down count and reaches CMR0, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF1</name>
              <description>PWM Channel 1 Duty Interrupt Flag\nFlag is set by hardware when channel 1 PWM counter down count and reaches CMR1, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF2</name>
              <description>PWM Channel 2 Duty Interrupt Flag\nFlag is set by hardware when channel 2 PWM counter down count and reaches CMR2, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF3</name>
              <description>PWM Channel 3 Duty Interrupt Flag\nFlag is set by hardware when channel 3 PWM counter down count and reaches CMR3, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CCR0</displayName>
          <description>PWM Capture Control Register 0</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV0</name>
              <description>Channel 0 Inverter Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE0</name>
              <description>Channel 0 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 0 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE0</name>
              <description>Channel 0 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 0 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH0EN</name>
              <description>Channel 0 Capture Function Enable\nWhen Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 0 Interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF0</name>
              <description>Channel 0 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI0</name>
              <description>CRLR0 Latched Indicator\nWhen PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI0</name>
              <description>CFLR0 Latched Indicator\nWhen PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to0 if BCn bit is 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV1</name>
              <description>Channel 1 Inverter Enable Bit</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE1</name>
              <description>Channel 1 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 1 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE1</name>
              <description>Channel 1 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 1 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH1EN</name>
              <description>Channel 1 Capture Function Enable Bit\nWhen Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 1 Interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF1</name>
              <description>Channel 1 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI1</name>
              <description>CRLR1 Latched Indicator Bit\nWhen PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit to0 if BCn bit is 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI1</name>
              <description>CFLR1 Latched Indicator Bit\nWhen PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit to 0 if BCn bit is 1.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CCR2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CCR2</displayName>
          <description>PWM Capture Control Register 2</description>
          <addressOffset>0x54</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV2</name>
              <description>Channel 2 Inverter Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE2</name>
              <description>Channel 2 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 2 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE2</name>
              <description>Channel 2 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 2 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH2EN</name>
              <description>Channel 2 Capture Function Enable Bit\nWhen Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 2 Interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 2 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 2 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF2</name>
              <description>Channel 2 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI2</name>
              <description>CRLR2 Latched Indicator\nWhen PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI2</name>
              <description>CFLR2 Latched Indicator\nWhen PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV3</name>
              <description>Channel 3 Inverter Enable Bit</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE3</name>
              <description>Channel 3 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 3 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE3</name>
              <description>Channel 3 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 3 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH3EN</name>
              <description>Channel 3 Capture Function Enable Bit\nWhen Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 3 Interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 3 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 3 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF3</name>
              <description>Channel 3 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI3</name>
              <description>CRLR3 Latched Indicator\nWhen PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI3</name>
              <description>CFLR3 Latched Indicator\nWhen PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRLR0</displayName>
          <description>PWM Capture Rising Latch Register (Channel 0)</description>
          <addressOffset>0x58</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLRx</name>
              <description>Capture Rising Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CFLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CFLR0</displayName>
          <description>PWM Capture Falling Latch Register (Channel 0)</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFLRx</name>
              <description>Capture Falling Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has Falling transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR1</name>
          <displayName>CRLR1</displayName>
          <description>PWM Capture Rising Latch Register (Channel 1)</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR1</name>
          <displayName>CFLR1</displayName>
          <description>PWM Capture Falling Latch Register (Channel 1)</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR2</name>
          <displayName>CRLR2</displayName>
          <description>PWM Capture Rising Latch Register (Channel 2)</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR2</name>
          <displayName>CFLR2</displayName>
          <description>PWM Capture Falling Latch Register (Channel 2)</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR3</name>
          <displayName>CRLR3</displayName>
          <description>PWM Capture Rising Latch Register (Channel 3)</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR3</name>
          <displayName>CFLR3</displayName>
          <description>PWM Capture Falling Latch Register (Channel 3)</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register>
          <name>CAPENR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAPENR</displayName>
          <description>PWM Capture Input 0~3 Enable Register</description>
          <addressOffset>0x78</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CINEN0</name>
              <description>Channel 0 Capture Input Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 0 capture input path Disabled. The input of PWM channel 0 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 0 capture input path Enabled. The input of PWM channel 0 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN1</name>
              <description>Channel 1 Capture Input Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 1 capture input path Disabled. The input of PWM channel 1 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 1 capture input path Enabled. The input of PWM channel 1 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN2</name>
              <description>Channel 2 Capture Input Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 2 capture input path Disabled. The input of PWM channel 2 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 2 capture input path Enabled. The input of PWM channel 2 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN3</name>
              <description>Channel 3 Capture Input Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 3 capture input path Disabled. The input of PWM channel 3 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 3 capture input path Enabled. The input of PWM channel 3 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>POE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>POE</displayName>
          <description>PWM Output Enable for Channel 0~3</description>
          <addressOffset>0x7C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POE0</name>
              <description>Channel 0 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 0 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 0 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE1</name>
              <description>Channel 1 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 1 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 1 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE2</name>
              <description>Channel 2 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 2 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 2 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE3</name>
              <description>Channel 3 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 3 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 3 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCON</displayName>
          <description>PWM Trigger Control for Channel 0~3</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM0TEN</name>
              <description>Channel 0 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 0 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 0 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1TEN</name>
              <description>Channel 1 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 1 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 1 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2TEN</name>
              <description>Channel 2 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 2 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 2 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3TEN</name>
              <description>Channel 3 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 3 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 3 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TSTATUS</displayName>
          <description>PWM Trigger Status Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM0TF</name>
              <description>Channel 0 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up counts to CNR if PWM0TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1TF</name>
              <description>Channel 1 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to CNR if PWM1TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2TF</name>
              <description>Channel 2 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to CNR if PWM2TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3TF</name>
              <description>Channel 3 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to CNR if PWM3TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY0</displayName>
          <description>PWM0 Synchronous Busy Status Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen software writes CNR0/CMR0/PPR or switches PWM0 operation mode (PCR[3]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software needs to check this busy status before writing CNR0/CMR0/PPR or switching PWM0 operation mode (PCR[3]) to make sure previous setting has been updated completely.\nThis bit will be set when software writes CNR0/CMR0/PPR or switches PWM0 operation mode (PCR[3]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY1</displayName>
          <description>PWM1 Synchronous Busy Status Register</description>
          <addressOffset>0x8C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen Software writes CNR1/CMR1/PPR or switches PWM1 operation mode (PCR[11]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software needs to check this busy status before writing CNR1/CMR1/PPR or switching PWM1 operation mode (PCR[11]) to make sure previous setting has been updated completely.\nThis bit will be set when software writes CNR1/CMR1/PPR or switches PWM1 operation mode (PCR[11]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY2</displayName>
          <description>PWM2 Synchronous Busy Status Register</description>
          <addressOffset>0x90</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen Software writes CNR2/CMR2/PPR or switch PWM2 operation mode (PCR[19]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software needs to check this busy status before writing CNR2/CMR2/PPR or switching PWM2 operation mode (PCR[19]) to make sure previous setting has been updated completely.\nThis bit will be set when software writes CNR2/CMR2/PPR or switch PWM2 operation mode (PCR[19]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY3</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY3</displayName>
          <description>PWM3 Synchronous Busy Status Register</description>
          <addressOffset>0x94</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen Software writes CNR3/CMR3/PPR or switch PWM3 operation mode (PCR[27]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software need to check this busy status before writing CNR3/CMR3/PPR or switching PWM3 operation mode (PCR[27]) to make sure previous setting has been updated completely.\nThis bit will be set when Software writes CNR3/CMR3/PPR or switch PWM3 operation mode (PCR[27]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWMB</name>
      <description>PWM Register Map</description>
      <groupName>PWM</groupName>
      <baseAddress>0x40140000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x3C</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x58</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x78</offset>
        <size>0x18</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>PPR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PPR</displayName>
          <description>PWM Prescaler Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CP01</name>
              <description>Clock Prescaler 0 (PWM-Timer 0 / 1 For Group A And PWM-Timer 4 / 5 For Group B)\nClock input is divided by (CP01 + 1) before it is fed to the corresponding PWM-timer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CP23</name>
              <description>Clock Prescaler 2 (PWM-Timer2 / 3 For Group A)\nClock input is divided by (CP23 + 1) before it is fed to the corresponding PWM-timer</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZI01</name>
              <description>Dead-Zone Interval For Pair Of Channel 0 And Channel 1 (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\nThese 8-bit determine the Dead-zone length.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DZI23</name>
              <description>Dead-Zone Interval For Pair Of Channel2 And Channel3 (PWM2 And PWM3 Pair For PWM Group A)\nThese 8-bit determine the Dead-zone length.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CSR</displayName>
          <description>PWM Clock Source Divider Select Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSR0</name>
              <description>PWM Timer 0 Clock Source Divider Selection (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\nSelect clock source divider for PWM timer 0.\n(Table is the same as CSR3)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR1</name>
              <description>PWM Timer 1 Clock Source Divider Selection (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\nSelect clock source divider for PWM timer 1.\n(Table is the same as CSR3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR2</name>
              <description>PWM Timer 2 Clock Source Divider Selection (PWM Timer 2 For Group A)\nSelect clock source divider for PWM timer 2.\n(Table is the same as CSR3)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CSR3</name>
              <description>PWM Timer 3 Clock Source Divider Selection (PWM Timer 3 For Group A)\nSelect clock source divider for PWM timer 3.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>2</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>4</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>8</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>16</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>1</description>
                    <value>#100</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PCR</displayName>
          <description>PWM Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH0EN</name>
              <description>PWM-Timer 0 Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The corresponding PWM-Timer stops running</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The corresponding PWM-Timer starts running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0PINV</name>
              <description>PWM-Timer 0 Output Polar Inverse Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM0 output polar inverse Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM0 output polar inverse Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0INV</name>
              <description>PWM-Timer 0 Output Inverter Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH0MOD</name>
              <description>PWM-Timer 0 Auto-Reload/One-Shot Mode (PWM Timer 0 For Group A And PWM Timer 4 For Group B)\nNote: If there is a transition at this bit, it will cause CNR0 and CMR0 be cleared.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN01</name>
              <description>Dead-Zone 0 Generator Enable (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\nNote: When Dead-zone generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM group B.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DZEN23</name>
              <description>Dead-Zone 2 Generator Enable (PWM2 And PWM3 Pair For PWM Group A)\nNote: When Dead-zone generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair for PWM group A.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1EN</name>
              <description>PWM-Timer 1 Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1PINV</name>
              <description>PWM-Timer 1 Output Polar Inverse Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM1 output polar inverse Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM1 output polar inverse Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1INV</name>
              <description>PWM-Timer 1 Output Inverter Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1MOD</name>
              <description>PWM-Timer 1 Auto-Reload/One-Shot Mode (PWM Timer 1 For Group A And PWM Timer 5 For Group B)\nNote: If there is a transition at this bit, it will cause CNR1 and CMR1 be cleared.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2EN</name>
              <description>PWM-Timer 2 Enable (PWM Timer 2 For Group A)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2PINV</name>
              <description>PWM-Timer 2 Output Polar Inverse Enable (PWM Timer 2 For Group A)</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM2 output polar inverse Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM2 output polar inverse Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2INV</name>
              <description>PWM-Timer 2 Output Inverter Enable (PWM Timer 2 For Group A)</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2MOD</name>
              <description>PWM-Timer 2 Auto-Reload/One-Shot Mode (PWM Timer 2 For Group A)\nNote: If there is a transition at this bit, it will cause CNR2 and CMR2 be cleared.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3EN</name>
              <description>PWM-Timer 3 Enable (PWM Timer 3 For Group A)</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Corresponding PWM-Timer Stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Corresponding PWM-Timer Start Running</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3PINV</name>
              <description>PWM-Timer 3 Output Polar Inverse Enable (PWM Timer 3 For Group A)</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM3 output polar inverse Disable</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM3 output polar inverse Enable</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3INV</name>
              <description>PWM-Timer 3 Output Inverter Enable (PWM Timer 3 For Group A)</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3MOD</name>
              <description>PWM-Timer 3 Auto-Reload/One-Shot Mode (PWM Timer 3 For Group A)\nNote: If there is a transition at this bit, it will cause CNR3 and CMR3 be cleared.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One-shot mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Auto-reload mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM01TYPE</name>
              <description>PWM01 Aligned Type Selection (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-aligned type</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Center-aligned type</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM23TYPE</name>
              <description>PWM23 Aligned Type Selection (PWM2 And PWM3 Pair For PWM Group A)</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Edge-aligned type</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Center-aligned type</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CNR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CNR0</displayName>
          <description>PWM Counter Register 0</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CNRx</name>
              <description>PWM Timer Loaded Value\nCNR determines the PWM period.\nNote: Any write to CNR will take effect in next PWM cycle.\nNote: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to 0xFFFE. If CNR equal to 0xFFFF, the PWM will work unpredictable.\nNote: When CNR value is set to 0, PWM output is always high.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CMR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CMR0</displayName>
          <description>PWM Comparator Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMRx</name>
              <description>PWM Comparator Register\nCMR determines the PWM duty.\nNote: Any write to CNR will take effect in next PWM cycle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PDR0</displayName>
          <description>PWM Data Register 0</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PDRx</name>
              <description>PWM Data Register\nUser can monitor PDR to know the current value in 16-bit counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CNR0">
          <name>CNR1</name>
          <displayName>CNR1</displayName>
          <description>PWM Counter Register 1</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="CMR0">
          <name>CMR1</name>
          <displayName>CMR1</displayName>
          <description>PWM Comparator Register 1</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="PDR0">
          <name>PDR1</name>
          <displayName>PDR1</displayName>
          <description>PWM Data Register 1</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>PBCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PBCR</displayName>
          <description>PWM Backward Compatible Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BCn</name>
              <description>PWM Backward Compatible Register\nRefer to the CCR0/CCR2 register bit 6, 7, 22, 23 description\nNote: It is recommended that this bit be set to 1 to prevent CFLRIx and CRLRIx from being cleared when writing CCR0/CCR2.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Configure write 0 to clear CFLRI0~3 and CRLRI0~3</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Configure write 1 to clear CFLRI0~3 and CRLRI0~3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIER</displayName>
          <description>PWM Interrupt Enable Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIE0</name>
              <description>PWM Channel 0 Period Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE1</name>
              <description>PWM Channel 1 Period Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE2</name>
              <description>PWM Channel 2 Period Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIE3</name>
              <description>PWM Channel 3 Period Interrupt Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE0</name>
              <description>PWM Channel 0 Duty Interrupt Enable Bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE1</name>
              <description>PWM Channel 1 Duty Interrupt Enable Bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE2</name>
              <description>PWM Channel 2 Duty Interrupt Enable Bit</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIE3</name>
              <description>PWM Channel 3 Duty Interrupt Enable Bit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INT01TYPE</name>
              <description>PWM01 Interrupt Period Type Selection Bit (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)\nNote: This bit is effective when PWM in Center-aligned type only.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMIFn will be set if PWM counter underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMIFn will be set if PWM counter matches CNRn register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INT23TYPE</name>
              <description>PWM23 Interrupt Period Type Selection Bit (PWM2 And PWM3 Pair For PWM Group A)\nNote: This bit is effective when PWM in Center-aligned type only.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWMIFn will be set if PWM counter underflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWMIFn will be set if PWM counter matches CNRn register</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>PIIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>PIIR</displayName>
          <description>PWM Interrupt Indication Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWMIF0</name>
              <description>PWM Channel 0 Period Interrupt Status\nThis bit is set by hardware when PWM0 counter reaches the requirement of interrupt (depend on INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF1</name>
              <description>PWM Channel 1 Period Interrupt Status\nThis bit is set by hardware when PWM1 counter reaches the requirement of interrupt (depend on INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF2</name>
              <description>PWM Channel 2 Period Interrupt Status\nThis bit is set by hardware when PWM2 counter reaches the requirement of interrupt (depend on INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMIF3</name>
              <description>PWM Channel 3 Period Interrupt Status\nThis bit is set by hardware when PWM3 counter reaches the requirement of interrupt (depend on INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF0</name>
              <description>PWM Channel 0 Duty Interrupt Flag\nFlag is set by hardware when channel 0 PWM counter down count and reaches CMR0, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF1</name>
              <description>PWM Channel 1 Duty Interrupt Flag\nFlag is set by hardware when channel 1 PWM counter down count and reaches CMR1, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF2</name>
              <description>PWM Channel 2 Duty Interrupt Flag\nFlag is set by hardware when channel 2 PWM counter down count and reaches CMR2, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMDIF3</name>
              <description>PWM Channel 3 Duty Interrupt Flag\nFlag is set by hardware when channel 3 PWM counter down count and reaches CMR3, software can clear this bit by writing a one to it.\nNote: If CMR equal to CNR, this flag is not working in Edge-aligned type selection</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CCR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CCR0</displayName>
          <description>PWM Capture Control Register 0</description>
          <addressOffset>0x50</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INV0</name>
              <description>Channel 0 Inverter Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE0</name>
              <description>Channel 0 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 0 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE0</name>
              <description>Channel 0 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 0 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH0EN</name>
              <description>Channel 0 Capture Function Enable\nWhen Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 0 Interrupt.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 0 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 0 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF0</name>
              <description>Channel 0 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI0</name>
              <description>CRLR0 Latched Indicator\nWhen PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to 0 if the BCn bit is 1.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI0</name>
              <description>CFLR0 Latched Indicator\nWhen PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this bit to0 if BCn bit is 1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INV1</name>
              <description>Channel 1 Inverter Enable Bit</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Inverter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CRL_IE1</name>
              <description>Channel 1 Rising Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 1 has rising transition, Capture will issue an Interrupt.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Rising latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Rising latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CFL_IE1</name>
              <description>Channel 1 Falling Latch Interrupt Enable Bit\nWhen Enabled, if Capture detects PWM group channel 1 has falling transition, Capture will issue an Interrupt.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Falling latch interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Falling latch interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPCH1EN</name>
              <description>Channel 1 Capture Function Enable Bit\nWhen Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).\nWhen Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 1 Interrupt.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Capture function on PWM group channel 1 Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Capture function on PWM group channel 1 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CAPIF1</name>
              <description>Channel 1 Capture Interrupt Indication Flag\nWrite 1 to clear this bit to 0.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CRLRI1</name>
              <description>CRLR1 Latched Indicator Bit\nWhen PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit to0 if BCn bit is 1.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CFLRI1</name>
              <description>CFLR1 Latched Indicator Bit\nWhen PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of PWM down-counter and this bit is set by hardware.\nSoftware can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit to 0 if BCn bit is 1.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CRLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CRLR0</displayName>
          <description>PWM Capture Rising Latch Register (Channel 0)</description>
          <addressOffset>0x58</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CRLRx</name>
              <description>Capture Rising Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CFLR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CFLR0</displayName>
          <description>PWM Capture Falling Latch Register (Channel 0)</description>
          <addressOffset>0x5C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CFLRx</name>
              <description>Capture Falling Latch Register\nLatch the PWM counter when Channel 0/1/2/3 has Falling transition.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="CRLR0">
          <name>CRLR1</name>
          <displayName>CRLR1</displayName>
          <description>PWM Capture Rising Latch Register (Channel 1)</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="CFLR0">
          <name>CFLR1</name>
          <displayName>CFLR1</displayName>
          <description>PWM Capture Falling Latch Register (Channel 1)</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register>
          <name>CAPENR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAPENR</displayName>
          <description>PWM Capture Input 0~3 Enable Register</description>
          <addressOffset>0x78</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CINEN0</name>
              <description>Channel 0 Capture Input Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 0 capture input path Disabled. The input of PWM channel 0 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 0 capture input path Enabled. The input of PWM channel 0 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN1</name>
              <description>Channel 1 Capture Input Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 1 capture input path Disabled. The input of PWM channel 1 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 1 capture input path Enabled. The input of PWM channel 1 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN2</name>
              <description>Channel 2 Capture Input Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 2 capture input path Disabled. The input of PWM channel 2 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 2 capture input path Enabled. The input of PWM channel 2 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CINEN3</name>
              <description>Channel 3 Capture Input Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM Channel 3 capture input path Disabled. The input of PWM channel 3 capture function is always regarded as 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM Channel 3 capture input path Enabled. The input of PWM channel 3 capture function comes from correlative multifunction pin if GPIO multi-function is set as PWM3</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>POE</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>POE</displayName>
          <description>PWM Output Enable for Channel 0~3</description>
          <addressOffset>0x7C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>POE0</name>
              <description>Channel 0 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 0 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 0 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE1</name>
              <description>Channel 1 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 1 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 1 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE2</name>
              <description>Channel 2 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 2 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 2 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>POE3</name>
              <description>Channel 3 Output Enable Bit\nNote: The corresponding GPIO pin must also be switched to PWM function</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 3 output to pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 3 output to pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TCON</displayName>
          <description>PWM Trigger Control for Channel 0~3</description>
          <addressOffset>0x80</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM0TEN</name>
              <description>Channel 0 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 0 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 0 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1TEN</name>
              <description>Channel 1 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 1 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 1 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2TEN</name>
              <description>Channel 2 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 2 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 2 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3TEN</name>
              <description>Channel 3 Center-Aligned Trigger Enable Bit\nPWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to 1.\nNote: This function is only supported when PWM operating at Center-aligned type.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PWM channel 3 trigger ADC function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PWM channel 3 trigger ADC function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TSTATUS</displayName>
          <description>PWM Trigger Status Register</description>
          <addressOffset>0x84</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PWM0TF</name>
              <description>Channel 0 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up counts to CNR if PWM0TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM1TF</name>
              <description>Channel 1 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to CNR if PWM1TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM2TF</name>
              <description>Channel 2 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to CNR if PWM2TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWM3TF</name>
              <description>Channel 3 Center-Aligned Trigger Flag\nFor Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to CNR if PWM3TEN bit is set to 1. After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by PWM.\nSoftware can write 1 to clear this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY0</displayName>
          <description>PWM0 Synchronous Busy Status Register</description>
          <addressOffset>0x88</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen software writes CNR0/CMR0/PPR or switches PWM0 operation mode (PCR[3]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software needs to check this busy status before writing CNR0/CMR0/PPR or switching PWM0 operation mode (PCR[3]) to make sure previous setting has been updated completely.\nThis bit will be set when software writes CNR0/CMR0/PPR or switches PWM0 operation mode (PCR[3]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SYNCBUSY1</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SYNCBUSY1</displayName>
          <description>PWM1 Synchronous Busy Status Register</description>
          <addressOffset>0x8C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>S_BUSY</name>
              <description>PWM Synchronous Busy\nWhen Software writes CNR1/CMR1/PPR or switches PWM1 operation mode (PCR[11]), PWM will have a busy time to update these values completely because PWM clock may be different from system clock domain. Software needs to check this busy status before writing CNR1/CMR1/PPR or switching PWM1 operation mode (PCR[11]) to make sure previous setting has been updated completely.\nThis bit will be set when software writes CNR1/CMR1/PPR or switches PWM1 operation mode (PCR[11]) and will be cleared by hardware automatically when PWM update these value completely.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT</name>
      <description>WDT Register Map</description>
      <groupName>WDT</groupName>
      <baseAddress>0x40004000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>WTCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WTCR</displayName>
          <description>Watchdog Timer Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000700</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WTR</name>
              <description>Reset Watchdog Timer Up Counter (Write Protect)\nNote: This bit will be automatically cleared by hardware.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the internal 18-bit WDT up counter value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTRE</name>
              <description>Watchdog Timer Reset Enable Bit (Write Protect)\nSetting this bit will enable the WDT time-out reset function if the WDT up counter value has not been cleared after the specific WDT reset delay period expires.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT time-out reset function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT time-out reset function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTRF</name>
              <description>Watchdog Timer Time-Out Reset Flag\nThis bit indicates the system has been reset by WDT time-out reset or not.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT time-out reset did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT time-out reset occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIF</name>
              <description>Watchdog Timer Time-Out Interrupt Flag\nThis bit will set to 1 while WDT up counter value reaches the selected WDT time-out interval.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT time-out interrupt did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT time-out interrupt occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTWKE</name>
              <description>Watchdog Timer Time-Out Wake-Up Function Control (Write Protect)\nIf this bit is set to 1, while WTIF is generated to 1 and WTIE enabled, the WDT time-out interrupt signal will generate a wake-up trigger event to chip.\nNote: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT   clock source is selected to 10 kHz oscillator.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up trigger event Disabled if WDT time-out interrupt signal generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up trigger event Enabled if WDT time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTWKF</name>
              <description>Watchdog Timer Time-Out Wake-Up Flag\nThis bit indicates the interrupt wake-up flag status of WDT.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT does not cause chip wake-up</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIE</name>
              <description>Watchdog Timer Time-Out Interrupt Enable Bit (Write Protect)\nIf this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTE</name>
              <description>Watchdog Timer Enable Bit (Write Protect)\nNote: If CWDTEN (CONFIG0[31] Watchdog Enable) bit is set to 0, this bit is forced as 1 and user cannot change this bit to 0.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WDT Disabled. (This action will reset the internal up counter value.)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WDT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WTIS</name>
              <description>Watchdog Timer Time-Out Interval Selection (Write Protect)\nThese three bits select the time-out interval period for the WDT.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24 *TWDT</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>26 * TWDT</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>28 * TWDT</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>210 * TWDT</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>212 * TWDT</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>214 * TWDT</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>216 * TWDT</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>218 * TWDT</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_WDT</name>
              <description>ICE Debug Mode Acknowledge Disable Bit (Write Protect)\nWDT up counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects WDT counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WTCRALT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WTCRALT</displayName>
          <description>Watchdog Timer Alternative Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WTRDSEL</name>
              <description>Watchdog Timer Reset Delay Selection (Write Protect)\nWhen WDT time-out happened, user has a time named WDT Reset Delay Period to clear WDT counter to prevent WDT time-out reset happened. User can select a suitable value of WDT Reset Delay Period for different WDT time-out period.\nThese bits are protected bit. It means programming this bit needs to write '59h', '16h', '88h' to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.\nNote: This register will be reset to 0 if WDT time-out reset happened.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Watchdog Timer Reset Delay Period is 1026 * WDT_CLK</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Watchdog Timer Reset Delay Period is 130 * WDT_CLK</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Watchdog Timer Reset Delay Period is 18 * WDT_CLK</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Watchdog Timer Reset Delay Period is 3 * WDT_CLK</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WWDT</name>
      <description>WWDT Register Map</description>
      <groupName>WWDT</groupName>
      <baseAddress>0x40004100</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>WWDTRLD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDTRLD</displayName>
          <description>Window Watchdog Timer Reload Counter Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTRLD</name>
              <description>WWDT Reload Counter Register\nWriting 0x00005AA5 to this register will reload the WWDT counter value to 0x3F. \nNote: User can only write WWDTRLD to reload WWDT counter value when current WWDT counter value between 0 and WINCMP. If user writes WWDTRLD when current WWDT counter value is larger than WINCMP, WWDT reset signal will generate immediately.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WWDTCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDTCR</displayName>
          <description>Window Watchdog Timer Control Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x003F0800</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTEN</name>
              <description>WWDT Enable Bit\nSet this bit to enable WWDT counter counting</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WWDT counter is stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WWDT counter is starting counting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WWDTIE</name>
              <description>WWDT Interrupt Enable Bit\nIf this bit is enabled, the WWDT counter compare match interrupt signal is generated and inform to CPU.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WWDT counter compare match interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WWDT counter compare match interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIODSEL</name>
              <description>WWDT Counter Prescale Period Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pre-scale is 1; Max time-out period is 1 * 64 * TWWDT</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pre-scale is 2; Max time-out period is 2 * 64 * TWWDT</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Pre-scale is 4; Max time-out period is 4 * 64 * TWWDT</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Pre-scale is 8; Max time-out period is 8 * 64 * TWWDT</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Pre-scale is 16; Max time-out period is 16 * 64 * TWWDT</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Pre-scale is 32; Max time-out period is 32 * 64 * TWWDT</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Pre-scale is 64; Max time-out period is 64 * 64 * TWWDT</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Pre-scale is 128; Max time-out period is 128 * 64 * TWWDT</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>Pre-scale is 192; Max time-out period is 192 * 64 * TWWDT</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>Pre-scale is 256; Max time-out period is 256 * 64 * TWWDT</description>
                    <value>#1001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>Pre-scale is 384; Max time-out period is 384 * 64 * TWWDT</description>
                    <value>#1010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Pre-scale is 512; Max time-out period is 512 * 64 * TWWDT</description>
                    <value>#1011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>12</name>
                    <description>Pre-scale is 768; Max time-out period is 768 * 64 * TWWDT</description>
                    <value>#1100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>13</name>
                    <description>Pre-scale is 1024; Max time-out period is 1024 * 64 * TWWDT</description>
                    <value>#1101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>14</name>
                    <description>Pre-scale is 1536; Max time-out period is 1536 * 64 * TWWDT</description>
                    <value>#1110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>15</name>
                    <description>Pre-scale is 2048; Max time-out period is 2048 * 64 * TWWDT</description>
                    <value>#1111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WINCMP</name>
              <description>WWDT Window Compare Register\nSet this register to adjust the valid reload window. \nNote: User can only write WWDTRLD to reload WWDT counter value when current WWDT counter value between 0 and WINCMP. If user writes WWDTRLD when current WWDT counter value larger than WINCMP, WWDT reset signal will generate immediately.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBGACK_WWDT</name>
              <description>ICE Debug Mode Acknowledge Disable Bit\nWWDT down counter will keep going no matter CPU is held by ICE or not.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ICE debug mode acknowledgement effects WWDT counting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ICE debug mode acknowledgement Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WWDTSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDTSR</displayName>
          <description>Window Watchdog Timer Status Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTIF</name>
              <description>WWDT Compare Match Interrupt Flag\nThis bit indicates the interrupt flag status of WWDT while WWDT counter value matches WINCMP value.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WWDT counter value matches WINCMP value</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WWDTRF</name>
              <description>WWDT Time-Out Reset Flag\nThis bit indicates the system has been reset by WWDT time-out reset or not.\nNote: This bit is cleared by writing 1 to it.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>WWDT time-out reset did not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>WWDT time-out reset occurred</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>WWDTCVR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>WWDTCVR</displayName>
          <description>Window Watchdog Timer Counter Value Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x0000003F</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WWDTCVAL</name>
              <description>WWDT Counter Value\nWWDTCVAL will be updated continuously to monitor 6-bit down counter value.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>RTC</name>
      <description>RTC Register Map</description>
      <groupName>RTC</groupName>
      <baseAddress>0x40008000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x3C</offset>
        <size>0x54</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>INIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>INIR</displayName>
          <description>RTC Initiation Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>INIR_Active</name>
              <description>RTC Active Status (Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC is at reset state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC is at normal active state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>INIR</name>
              <description>RTC Initiation\nWhen RTC block is powered on, RTC is at reset state. User has to write a number (0xa5eb1357) to INIR to make RTC leaving reset state. Once the INIR is written as 0xa5eb1357, the RTC will be in un-reset state permanently.\nThe INIR is a write-only field and read value will be always 0.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>31</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>AER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>AER</displayName>
          <description>RTC Access Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AER</name>
              <description>RTC Register Access Enable Password (Write Only)\nWriting 0xA965 to this register will enable RTC access and keep 1024 RTC clocks.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>ENF</name>
              <description>RTC Register Access Enable Flag (Read Only)\nNote: This bit will be set after AER[15:0] is load a 0xA965, and will be cleared automatically after 1024 RTC clocks.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC register read/write access Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC register read/write access Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>FCR</displayName>
          <description>RTC Frequency Compensation Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000700</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FRACTION</name>
              <description>Fraction Part\nNote: Digit in FCR must be expressed as hexadecimal number..</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INTEGER</name>
              <description>Integer Part\nPlease refer to 6.12.5.4.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TLR</displayName>
          <description>Time Loading Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1SEC</name>
              <description>1-Sec Time Digit (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10SEC</name>
              <description>10-Sec Time Digit (0~5)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MIN</name>
              <description>1-Min Time Digit (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MIN</name>
              <description>10-Min Time Digit (0~5)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1HR</name>
              <description>1-Hour Time Digit (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10HR</name>
              <description>10-Hour Time Digit (0~2)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CLR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CLR</displayName>
          <description>Calendar Loading Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00050101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1DAY</name>
              <description>1-Day Calendar Digit (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10DAY</name>
              <description>10-Day Calendar Digit (0~3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MON</name>
              <description>1-Month Calendar Digit (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MON</name>
              <description>10-Month Calendar Digit (0~1)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1YEAR</name>
              <description>1-Year Calendar Digit (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10YEAR</name>
              <description>10-Year Calendar Digit (0~9)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TSSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TSSR</displayName>
          <description>Time Scale Selection Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_24H_12H</name>
              <description>24-Hour / 12-Hour Time Scale Selection\nIt indicates that RTC TLR and TAR counter are in 24-hour time scale or 12-hour time scale. Please refer to 6.12.5.6.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>24-hour time scale selected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>24-hour time scale selected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>DWR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>DWR</displayName>
          <description>Day of the Week Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000006</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DWR</name>
              <description>Day Of The Week Register </description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Sunday</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Monday</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Tuesday</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Wednesday</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Thursday</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Friday</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Saturday</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Reserved.</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TAR</displayName>
          <description>Time Alarm Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1SEC</name>
              <description>1-Sec Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10SEC</name>
              <description>10-Sec Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MIN</name>
              <description>1-Min Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MIN</name>
              <description>10-Min Time Digit of Alarm Setting (0~5)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1HR</name>
              <description>1-Hour Time Digit of Alarm Setting (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10HR</name>
              <description>10-Hour Time Digit of Alarm Setting (0~2)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>CAR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>CAR</displayName>
          <description>Calendar Alarm Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>_1DAY</name>
              <description>1-Day Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10DAY</name>
              <description>10-Day Calendar Digit of Alarm Setting (0~3)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1MON</name>
              <description>1-Month Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10MON</name>
              <description>10-Month Calendar Digit of Alarm Setting (0~1)</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_1YEAR</name>
              <description>1-Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>_10YEAR</name>
              <description>10-Year Calendar Digit of Alarm Setting (0~9)</description>
              <bitOffset>20</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>LIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>LIR</displayName>
          <description>Leap Year Indicator Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIR</name>
              <description>Leap Year Indication Register (Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>This year is not a leap year</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>This year is a leap year</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RIER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RIER</displayName>
          <description>RTC Interrupt Enable Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AIER</name>
              <description>Alarm Interrupt Enable Bit\nThis bit is used to enable/disable RTC Alarm Interrupt, and generate an interrupt signal if AIF (RIIR[0] RTC Alarm Interrupt Flag) is set to 1.\nNote: This bit will also trigger a wake-up event while system runs in Idle/Power-down mode and RTC Alarm Interrupt signal generated.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC Alarm Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Alarm Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIER</name>
              <description>Time Tick Interrupt Enable Bit\nThis bit is used to enable/disable RTC Time Tick Interrupt, and generate an interrupt signal if TIF (RIIR[1] RTC Time Tick Interrupt Flag) is set to 1.\nNote: This bit will also trigger a wake-up event while system runs in Idle/Power-down mode and RTC Time Tick Interrupt signal generated.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTC Time Tick Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTC Time Tick Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>RIIR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>RIIR</displayName>
          <description>RTC Interrupt Indicator Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AIF</name>
              <description>RTC Alarm Interrupt Flag\nWhen RTC time counters TLR and CLR match the alarm setting time registers TAR and CAR, this bit will be set to 1 and an interrupt will be generated if RTC Alarm Interrupt enabled AIER (RIER[0]) is set to 1. Chip will be wake-up if RTC Alarm Interrupt is enabled when chip is at Power-down mode.\nNote: Write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Alarm condition is not matched</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Alarm condition is matched</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIF</name>
              <description>RTC Time Tick Interrupt Flag\nWhen RTC time tick happened, this bit will be set to 1 and an interrupt will be generated if RTC Tick Interrupt enabled TIER (RIER[1]) is set to 1. Chip will also be wake-up if RTC Tick Interrupt is enabled and this bit is set to 1 when chip is running at Power-down mode.\nNote: Write 1 to clear this bit.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Tick condition does not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tick condition occur</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>TTR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>TTR</displayName>
          <description>RTC Time Tick Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TTR</name>
              <description>Time Tick Register\nThese bits are used to select RTC time tick period for Periodic Time Tick Interrupt request. \nNote: This register can be read back after the RTC register access enable bit ENF (AER[16]) is active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time tick is 1 second</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time tick is 1/2 second</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Time tick is 1/4 second</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Time tick is 1/8 second</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Time tick is 1/16 second</description>
                    <value>#100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Time tick is 1/32 second</description>
                    <value>#101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Time tick is 1/64 second</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Time tick is 1/28 second</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPRCTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPRCTL</displayName>
          <description>RTC Spare Functional Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000080</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SPREN</name>
              <description>SPR Register Enable Bit\nNote: When spare register is disabled, RTC SPR0 ~ SPR19 cannot be accessed.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Spare register is Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Spare register is Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPRRDY</name>
              <description>SPR Register Ready\nThis bit indicates if the registers SPRCTL, SPR0 ~ SPR19 are ready to be accessed.\nAfter user writing registers SPRCTL, SPR0 ~ SPR19, read this bit to check if these registers are updated done is necessary.\nNote: This bit is read only and any write to it won't take any effect.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPRCTL, SPR0 ~ SPR19 updating is in progress</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPRCTL, SPR0 ~ SPR19 are updated done and ready to be accessed</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPR0</displayName>
          <description>RTC Spare Register 0</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
          </fields>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR1</name>
          <displayName>SPR1</displayName>
          <description>RTC Spare Register 1</description>
          <addressOffset>0x44</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR2</name>
          <displayName>SPR2</displayName>
          <description>RTC Spare Register 2</description>
          <addressOffset>0x48</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR3</name>
          <displayName>SPR3</displayName>
          <description>RTC Spare Register 3</description>
          <addressOffset>0x4C</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR4</name>
          <displayName>SPR4</displayName>
          <description>RTC Spare Register 4</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR5</name>
          <displayName>SPR5</displayName>
          <description>RTC Spare Register 5</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR6</name>
          <displayName>SPR6</displayName>
          <description>RTC Spare Register 6</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR7</name>
          <displayName>SPR7</displayName>
          <description>RTC Spare Register 7</description>
          <addressOffset>0x5C</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR8</name>
          <displayName>SPR8</displayName>
          <description>RTC Spare Register 8</description>
          <addressOffset>0x60</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR9</name>
          <displayName>SPR9</displayName>
          <description>RTC Spare Register 9</description>
          <addressOffset>0x64</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR10</name>
          <displayName>SPR10</displayName>
          <description>RTC Spare Register 10</description>
          <addressOffset>0x68</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR11</name>
          <displayName>SPR11</displayName>
          <description>RTC Spare Register 11</description>
          <addressOffset>0x6C</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR12</name>
          <displayName>SPR12</displayName>
          <description>RTC Spare Register 12</description>
          <addressOffset>0x70</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR13</name>
          <displayName>SPR13</displayName>
          <description>RTC Spare Register 13</description>
          <addressOffset>0x74</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR14</name>
          <displayName>SPR14</displayName>
          <description>RTC Spare Register 14</description>
          <addressOffset>0x78</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR15</name>
          <displayName>SPR15</displayName>
          <description>RTC Spare Register 15</description>
          <addressOffset>0x7C</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR16</name>
          <displayName>SPR16</displayName>
          <description>RTC Spare Register 16</description>
          <addressOffset>0x80</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR17</name>
          <displayName>SPR17</displayName>
          <description>RTC Spare Register 17</description>
          <addressOffset>0x84</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR18</name>
          <displayName>SPR18</displayName>
          <description>RTC Spare Register 18</description>
          <addressOffset>0x88</addressOffset>
       </register>
       <register derivedFrom="SPR0">
          <name>SPR19</name>
          <displayName>SPR19</displayName>
          <description>RTC Spare Register 19</description>
          <addressOffset>0x8C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART0</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40050000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return the 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the TX pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RDA_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>THRE_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RLS_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable Bit (Not Available In UART2 Channel)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MODEM_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM_INT Enabled.</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_IEN</name>
              <description>RX Time-Out Interrupt Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TOUT_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TOUT_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable Bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUF_ERR_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUF_ERR_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>UART Wake-Up Function Enable Bit (Not Available In UART2 Channel)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART wake-up function Enabled, when the chip is in Power-down mode, an external CTS change will wake-up chip from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IEN</name>
              <description>LIN Bus Interrupt Enable Bit\nNote: This field is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Lin bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Lin bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time-Out Counter Enable Bit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable Bit (Not Available In UART2 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable Bit (Not Available In UART2 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_EN</name>
              <description>TX DMA Enable Bit (Not Available In UART2 Channel)\nThis bit can enable or disable TX DMA service.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_EN</name>
              <description>RX DMA Enable Bit (Not Available In UART2 Channel)\nThis bit can enable or disable RX DMA service.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RFR is set, all the byte in the receiver FIFO and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TFR is set, all the byte in the transmit FIFO and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if UA_IER [RDA_IEN] enabled, and an interrupt will be generated).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>RX FIFO Interrupt Trigger Level is 30/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>RX FIFO Interrupt Trigger Level is 46/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RX FIFO Interrupt Trigger Level is 62/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Bit\nThe receiver is disabled or not (set 1 to disable receiver)\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before UA_ALT_CSR [RS-485_NMM] is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level For Auto-Flow Control Use (Not Available In UART2 Channel)\nNote: This field is used for RTS auto-flow control.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>RTS Trigger Level is 30/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>RTS Trigger Level is 46/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RTS Trigger Level is 62/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of 'STOP Bit'</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One ' STOP bit' is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 'STOP bit' is generated in the transmitted data. When select 6-,7- and 8-bti word length, 2 'STOP bit' is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable Bit\nThis bit has effect only when PBE (UA_LCR[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MCR</displayName>
          <description>UART Modem Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTS</name>
              <description>RTS (Request-To-Send) Signal Control (Not Available In UART2 Channel)\nThis bit is direct control internal RTS signal active or not, and then drive the RTS pin output with LEV_RTS bit configuration.\nNote1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in UART function mode.\nNote2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS signal is active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS signal is inactive</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LEV_RTS</name>
              <description>RTS Pin Active Level (Not Available In UART2 Channel)\nThis bit defines the active level state of RTS pin output.\nNote1: Refer to Figure 6.136 and Figure 6.137 for UART function mode.\nNote2: Refer to Figure 6.1317 And Figure 6.1318 for RS-485 function mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin output is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin output is low level active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_ST</name>
              <description>RTS Pin State (Read Only) (Not Available In UART2 Channel)\nThis bit mirror from RTS pin output of voltage logic status.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin output is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin output is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MSR</displayName>
          <description>UART Modem Status Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000110</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCTSF</name>
              <description>Detect CTS State Change Flag (Read Only) (Not Available In UART2 Channel)\nThis bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEM_IEN (UA_IER [3]) is set to 1.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS input has not change state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS input has change state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTS_ST</name>
              <description>CTS Pin Status (Read Only) (Not Available In UART2 Channel)\nThis bit mirror from CTS pin input of voltage logic status.\nNote: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LEV_CTS</name>
              <description>CTS Pin Active Level\nThis bit defines the active level state of CTS pin input.\nNote: Refer to Figure 6.135 for more information</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is low level active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow.\nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 64/16/16 bytes of UART0/UART1/UART2, this bit will be set.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (Read Only) \nNote1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='1')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'parity bit', and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'stop bit' (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input(RX) is held in the 'spacing state' (logic 0) for longer than a full word transmission time (that is, the total time of 'start bit' + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, then RX_POINTER increases one. When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.\nThe Maximum value shown in RX_POINTER is 63/15/15 (UART0/UART1/UART2). When the using level of RX FIFO Buffer equal to 64/16/16, the RX_FULL bit is set to 1 and RX_POINTER will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 63/15/15 (UART0/UART1/UART2).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not.\nNote: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO is full or not.\nNote: This bit is set when the number of usage in RX FIFO Buffer is equal to 64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, then TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.\nThe Maximum value shown in TX_POINTER is 63/15/15 (UART0/UART1/UART2). When the using level of TX FIFO Buffer equal to 64/16/16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 63/15/15 (UART0/UART1/UART2).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not.\nNote: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitter FIFO Full (Read Only)\nThis bit indicates TX FIFO full or not.\nThis bit is set when the number of usage in TX FIFO Buffer is equal to 64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted.\nNote: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO equals the RFITL then the RDA_IF(UA_ISR[0]) will be set. If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only)  \nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO or RX FIFO overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set). When BUF_ERR_IF (UA_ISR[5])is set, the transfer is not correct. If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated.0 = No buffer error interrupt flag is generated.\nBuffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IF</name>
              <description>LIN Bus Flag (Read Only)\nNote: This bit is read only. This bit is cleared when LINS_HDET_F(UA_LIN_SR[0]), LIN_BKDET_F(UA_LIN_SR[9]), BIT_ERR_F(UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F(UA_LIN_SR[1]) all are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only)\nThis bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only) \nThis bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_INT</name>
              <description>LIN Bus Interrupt Indicator (Read Only)\nThis bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Bus interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN Bus interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_IF</name>
              <description>In DMA Mode, Receive Line Status Flag (Read Only)\nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF (UA_FSR[6]), FEF (UA_FSR[5]) and PEF (UA_FSR[4]) is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: In UART function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared. \nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and  RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_IF</name>
              <description>In DMA Mode, MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when the bit DCTSF(US_MSR[0]) is cleared by writing 1 on DCTSF (US_MSR[0]).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_IF</name>
              <description>In DMA Mode, Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UA_TOR[7:0]). If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated. \nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_IF</name>
              <description>In DMA Mode, Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX or RX FIFO overflows (TX_OVER_IF (UA__FSR[24]) or RX_OVER_IF (UA_FSR[0])  is set). When BUF_ERR_IF (UA_ISR[5]) is set, the transfer maybe is not correct. If BUF_ERR_IEN (UA_IER [5]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is cleared when both TX_OVER_IF (UA_FSR[24]]) and RX_OVER_IF (UA_FSR[0]) are cleared.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_INT</name>
              <description>In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)\nThis bit is set if RLS_IEN (UA_IER[2])and HW_RLS_IF(UA_ISR[18]) are both set to 1.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_INT</name>
              <description>In DMA Mode, MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3]) and HW_MODEM_IF(UA_ ISR[3]) are both set to 1.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_INT</name>
              <description>In DMA Mode, Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN (UA_IER[4])and HW_TOUT_IF(UA_ISR[20]) are both set to 1.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_INT</name>
              <description>In DMA Mode, Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN (UA_IER[5]) and HW_BUF_ERR_IF (UA_ISR[5])are both set to 1.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time-out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Interrupt Comparator</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value \nThis field is used to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal To 1\nRefer to Table 6.132 for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must  = 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must  = 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable Bit\nRefer to Table 6.132 for more information.\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must  = 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>TX_SELECT</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>IrDA Inverse Transmitting Output Signal Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal.</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>IrDA Inverse Receive Input Signal Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_BKFL</name>
              <description>UART LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: This break field length is UA_LIN_BKFL + 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Break Mode Enable Bit\nNote: When TX break field transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Break mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Break mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (NMM) \nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD)\nNote: It cannot be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) \nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable Bit\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register \nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function Enabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function Enabled</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function Enabled</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_CTL</displayName>
          <description>UART LIN Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x000C0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_EN</name>
              <description>LIN Slave Mode Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_HDET_EN</name>
              <description>LIN Slave Header Detection Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave header detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave header detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_ARS_EN</name>
              <description>LIN Slave Automatic Resynchronization Mode Enable Bit\nNote2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1).\nNote3: The control and interactions of this field are explained in 6.13.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN automatic resynchronization Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN automatic resynchronization Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_DUM_EN</name>
              <description>LIN Slave Divider Update Method Enable Bit\nNote2: This bit used for LIN Slave Automatic Resynchronization mode. (for Non-Automatic Resynchronization mode, this bit should be kept cleared) \nNote3: The control and interactions of this field are explained in 6.13.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UA_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UA_BAUD is updated at the next received character. User must set the bit before checksum reception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MUTE_EN</name>
              <description>LIN Mute Mode Enable Bit\nNote: The exit from mute mode condition and each control and interactions of this field are explained in (LIN slave mode).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN mute mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN mute mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_SHD</name>
              <description>LIN TX Send Header Enable Bit\nThe LIN TX header can be 'break field' or 'break and sync field' or 'break, sync and frame ID field', it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).\nNote1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write it by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).\nNote2: When transmitter header field (it may be 'break' or 'break + sync' or 'break + sync + frame ID' selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Send LIN TX header Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send LIN TX header Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IDPEN</name>
              <description>LIN ID Parity Enable Bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN frame ID parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN frame ID parity Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_EN</name>
              <description>LIN Break Detection Enable Bit</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_DIS</name>
              <description>LIN Receiver Disable Bit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR_EN</name>
              <description>Bit Error Detect Enable Bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit error detection function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKFL</name>
              <description>LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16].\nNote2: This break field length is LIN_BKFL + 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BS_LEN</name>
              <description>LIN Break/Sync Delimiter Length\n\nNote: This bit used for LIN master to sending header field.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN break/sync delimiter length is 1 bit time</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN break/sync delimiter length is 2 bit time.\nThe LIN break/sync delimiter length is 3 bit time</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The LIN break/sync delimiter length is 4 bit time</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_HEAD_SEL</name>
              <description>LIN Header Select</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN header includes 'break field'</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN header includes 'break field' and 'sync field'</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN header includes 'break field', 'sync field' and 'frame ID field'</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_PID</name>
              <description>LIN PID Register\nIf the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and parity in this field.\n\nNote1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).\nNote2: This field can be used for LIN master mode or slave mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_SR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_SR</displayName>
          <description>UART LIN Status Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_HDET_F</name>
              <description>LIN Slave Header Detection Flag (Read Only)\nThis bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.\nNote3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete header ('break + sync + frame ID'), the LINS_HEDT_F will be set whether the frame ID correct or not.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header detected (break + sync + frame ID)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_HERR_F</name>
              <description>LIN Slave Header Error Flag (Read Only)\nThis bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it. The header errors include 'break delimiter is too short (less than 0.5 bit time)', 'frame error in sync field or Identifier field', 'sync field data is not 0x55 in Non-Automatic Resynchronization mode', 'sync field deviation error with Automatic Resynchronization mode', 'sync field measure time-out with Automatic Resynchronization mode' and 'LIN header reception time-out'.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header error not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header error detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_IDPERR_F</name>
              <description>LIN Slave ID Parity Error Flag (Read Only)\nThis bit is set by hardware when receipted frame ID parity is not correct.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receipted frame ID parity is not correct</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_SYNC_F</name>
              <description>LIN Slave Sync Field\nThis bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode. When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.\nNote2: This bit is read only, but it can be cleared by writing 1 to it.\nNote3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The current character is not at LIN sync state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The current character is at LIN sync state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_F</name>
              <description>LIN Break Detection Flag (Read Only)\nThis bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIT_ERR_F</name>
              <description>Bit Error Detect Status Flag (Read Only)\nAt TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART1</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40150000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x3C</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return the 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the TX pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RDA_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>THRE_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RLS_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable Bit (Not Available In UART2 Channel)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MODEM_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_IEN</name>
              <description>RX Time-Out Interrupt Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TOUT_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TOUT_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable Bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUF_ERR_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUF_ERR_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>UART Wake-Up Function Enable Bit (Not Available In UART2 Channel)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART wake-up function Enabled, when the chip is in Power-down mode, an external CTS change will wake-up chip from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IEN</name>
              <description>LIN Bus Interrupt Enable Bit\nNote: This field is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Lin bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Lin bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time-Out Counter Enable Bit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable Bit (Not Available In UART2 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable Bit (Not Available In UART2 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_EN</name>
              <description>TX DMA Enable Bit (Not Available In UART2 Channel)\nThis bit can enable or disable TX DMA service.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_EN</name>
              <description>RX DMA Enable Bit (Not Available In UART2 Channel)\nThis bit can enable or disable RX DMA service.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RFR is set, all the byte in the receiver FIFO and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TFR is set, all the byte in the transmit FIFO and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if UA_IER [RDA_IEN] enabled, and an interrupt will be generated).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>RX FIFO Interrupt Trigger Level is 30/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>RX FIFO Interrupt Trigger Level is 46/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RX FIFO Interrupt Trigger Level is 62/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Bit\nThe receiver is disabled or not (set 1 to disable receiver)\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before UA_ALT_CSR [RS-485_NMM] is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level For Auto-Flow Control Use (Not Available In UART2 Channel)\nNote: This field is used for RTS auto-flow control.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>RTS Trigger Level is 30/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>RTS Trigger Level is 46/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RTS Trigger Level is 62/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of 'STOP Bit'</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One ' STOP bit' is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 'STOP bit' is generated in the transmitted data. When select 6-,7- and 8-bti word length, 2 'STOP bit' is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable Bit\nThis bit has effect only when PBE (UA_LCR[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MCR</displayName>
          <description>UART Modem Control Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000200</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RTS</name>
              <description>RTS (Request-To-Send) Signal Control (Not Available In UART2 Channel)\nThis bit is direct control internal RTS signal active or not, and then drive the RTS pin output with LEV_RTS bit configuration.\nNote1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in UART function mode.\nNote2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS signal is active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS signal is inactive</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LEV_RTS</name>
              <description>RTS Pin Active Level (Not Available In UART2 Channel)\nThis bit defines the active level state of RTS pin output.\nNote1: Refer to Figure 6.136 and Figure 6.137 for UART function mode.\nNote2: Refer to Figure 6.1317 And Figure 6.1318 for RS-485 function mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin output is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin output is low level active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_ST</name>
              <description>RTS Pin State (Read Only) (Not Available In UART2 Channel)\nThis bit mirror from RTS pin output of voltage logic status.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS pin output is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS pin output is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_MSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_MSR</displayName>
          <description>UART Modem Status Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000110</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DCTSF</name>
              <description>Detect CTS State Change Flag (Read Only) (Not Available In UART2 Channel)\nThis bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEM_IEN (UA_IER [3]) is set to 1.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS input has not change state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS input has change state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>CTS_ST</name>
              <description>CTS Pin Status (Read Only) (Not Available In UART2 Channel)\nThis bit mirror from CTS pin input of voltage logic status.\nNote: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is low level voltage logic state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is high level voltage logic state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LEV_CTS</name>
              <description>CTS Pin Active Level\nThis bit defines the active level state of CTS pin input.\nNote: Refer to Figure 6.135 for more information</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS pin input is high level active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS pin input is low level active</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow.\nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 64/16/16 bytes of UART0/UART1/UART2, this bit will be set.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (Read Only) \nNote1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='1')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'parity bit', and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'stop bit' (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input(RX) is held in the 'spacing state' (logic 0) for longer than a full word transmission time (that is, the total time of 'start bit' + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, then RX_POINTER increases one. When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.\nThe Maximum value shown in RX_POINTER is 63/15/15 (UART0/UART1/UART2). When the using level of RX FIFO Buffer equal to 64/16/16, the RX_FULL bit is set to 1 and RX_POINTER will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 63/15/15 (UART0/UART1/UART2).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not.\nNote: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO is full or not.\nNote: This bit is set when the number of usage in RX FIFO Buffer is equal to 64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, then TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.\nThe Maximum value shown in TX_POINTER is 63/15/15 (UART0/UART1/UART2). When the using level of TX FIFO Buffer equal to 64/16/16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 63/15/15 (UART0/UART1/UART2).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not.\nNote: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitter FIFO Full (Read Only)\nThis bit indicates TX FIFO full or not.\nThis bit is set when the number of usage in TX FIFO Buffer is equal to 64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted.\nNote: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO equals the RFITL then the RDA_IF(UA_ISR[0]) will be set. If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only)  \nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO or RX FIFO overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set). When BUF_ERR_IF (UA_ISR[5])is set, the transfer is not correct. If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated.0 = No buffer error interrupt flag is generated.\nBuffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IF</name>
              <description>LIN Bus Flag (Read Only)\nNote: This bit is read only. This bit is cleared when LINS_HDET_F(UA_LIN_SR[0]), LIN_BKDET_F(UA_LIN_SR[9]), BIT_ERR_F(UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F(UA_LIN_SR[1]) all are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only)\nThis bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only) \nThis bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_INT</name>
              <description>LIN Bus Interrupt Indicator (Read Only)\nThis bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Bus interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN Bus interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_IF</name>
              <description>In DMA Mode, Receive Line Status Flag (Read Only)\nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF (UA_FSR[6]), FEF (UA_FSR[5]) and PEF (UA_FSR[4]) is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: In UART function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared. \nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and  RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_IF</name>
              <description>In DMA Mode, MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when the bit DCTSF(US_MSR[0]) is cleared by writing 1 on DCTSF (US_MSR[0]).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_IF</name>
              <description>In DMA Mode, Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UA_TOR[7:0]). If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated. \nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_IF</name>
              <description>In DMA Mode, Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX or RX FIFO overflows (TX_OVER_IF (UA__FSR[24]) or RX_OVER_IF (UA_FSR[0])  is set). When BUF_ERR_IF (UA_ISR[5]) is set, the transfer maybe is not correct. If BUF_ERR_IEN (UA_IER [5]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is cleared when both TX_OVER_IF (UA_FSR[24]]) and RX_OVER_IF (UA_FSR[0]) are cleared.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_INT</name>
              <description>In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)\nThis bit is set if RLS_IEN (UA_IER[2])and HW_RLS_IF(UA_ISR[18]) are both set to 1.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_INT</name>
              <description>In DMA Mode, MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3]) and HW_MODEM_IF(UA_ ISR[3]) are both set to 1.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_INT</name>
              <description>In DMA Mode, Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN (UA_IER[4])and HW_TOUT_IF(UA_ISR[20]) are both set to 1.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_INT</name>
              <description>In DMA Mode, Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN (UA_IER[5]) and HW_BUF_ERR_IF (UA_ISR[5])are both set to 1.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time-out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Interrupt Comparator</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value \nThis field is used to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal To 1\nRefer to Table 6.132 for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must  = 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must  = 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable Bit\nRefer to Table 6.132 for more information.\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must  = 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>TX_SELECT</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>IrDA Inverse Transmitting Output Signal Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>IrDA Inverse Receive Input Signal Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_BKFL</name>
              <description>UART LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: This break field length is UA_LIN_BKFL + 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Break Mode Enable Bit\nNote: When TX break field transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Break mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Break mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (NMM) \nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD)\nNote: It cannot be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) \nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable Bit\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register \nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function Enabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function Enabled</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function Enabled</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_CTL</displayName>
          <description>UART LIN Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x000C0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_EN</name>
              <description>LIN Slave Mode Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_HDET_EN</name>
              <description>LIN Slave Header Detection Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave header detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave header detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_ARS_EN</name>
              <description>LIN Slave Automatic Resynchronization Mode Enable Bit\nNote2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1).\nNote3: The control and interactions of this field are explained in 6.13.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN automatic resynchronization Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN automatic resynchronization Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_DUM_EN</name>
              <description>LIN Slave Divider Update Method Enable Bit\nNote2: This bit used for LIN Slave Automatic Resynchronization mode. (for Non-Automatic Resynchronization mode, this bit should be kept cleared) \nNote3: The control and interactions of this field are explained in 6.13.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UA_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UA_BAUD is updated at the next received character. User must set the bit before checksum reception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MUTE_EN</name>
              <description>LIN Mute Mode Enable Bit\nNote: The exit from mute mode condition and each control and interactions of this field are explained in (LIN slave mode).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN mute mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN mute mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_SHD</name>
              <description>LIN TX Send Header Enable Bit\nThe LIN TX header can be 'break field' or 'break and sync field' or 'break, sync and frame ID field', it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).\nNote1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write it by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).\nNote2: When transmitter header field (it may be 'break' or 'break + sync' or 'break + sync + frame ID' selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Send LIN TX header Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send LIN TX header Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IDPEN</name>
              <description>LIN ID Parity Enable Bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN frame ID parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN frame ID parity Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_EN</name>
              <description>LIN Break Detection Enable Bit</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_DIS</name>
              <description>LIN Receiver Disable Bit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR_EN</name>
              <description>Bit Error Detect Enable Bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit error detection function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKFL</name>
              <description>LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16].\nNote2: This break field length is LIN_BKFL + 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BS_LEN</name>
              <description>LIN Break/Sync Delimiter Length\n\nNote: This bit used for LIN master to sending header field.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN break/sync delimiter length is 1 bit time</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN break/sync delimiter length is 2 bit time.\nThe LIN break/sync delimiter length is 3 bit time</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The LIN break/sync delimiter length is 4 bit time</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_HEAD_SEL</name>
              <description>LIN Header Select</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN header includes 'break field'</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN header includes 'break field' and 'sync field'</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN header includes 'break field', 'sync field' and 'frame ID field'</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_PID</name>
              <description>LIN PID Register\nIf the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and parity in this field.\n\nNote1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).\nNote2: This field can be used for LIN master mode or slave mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_SR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_SR</displayName>
          <description>UART LIN Status Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_HDET_F</name>
              <description>LIN Slave Header Detection Flag (Read Only)\nThis bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.\nNote3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete header ('break + sync + frame ID'), the LINS_HEDT_F will be set whether the frame ID correct or not.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header detected (break + sync + frame ID)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_HERR_F</name>
              <description>LIN Slave Header Error Flag (Read Only)\nThis bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it. The header errors include 'break delimiter is too short (less than 0.5 bit time)', 'frame error in sync field or Identifier field', 'sync field data is not 0x55 in Non-Automatic Resynchronization mode', 'sync field deviation error with Automatic Resynchronization mode', 'sync field measure time-out with Automatic Resynchronization mode' and 'LIN header reception time-out'.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header error not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header error detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_IDPERR_F</name>
              <description>LIN Slave ID Parity Error Flag (Read Only)\nThis bit is set by hardware when receipted frame ID parity is not correct.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receipted frame ID parity is not correct</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_SYNC_F</name>
              <description>LIN Slave Sync Field\nThis bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode. When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.\nNote2: This bit is read only, but it can be cleared by writing 1 to it.\nNote3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The current character is not at LIN sync state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The current character is at LIN sync state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_F</name>
              <description>LIN Break Detection Flag (Read Only)\nThis bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIT_ERR_F</name>
              <description>Bit Error Detect Status Flag (Read Only)\nAt TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>UART2</name>
      <description>UART Register Map</description>
      <groupName>UART</groupName>
      <baseAddress>0x40154000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x18</offset>
        <size>0x24</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>UA_RBR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_RBR</displayName>
          <description>UART Receive Buffer Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>RBR</name>
              <description>Receive Buffer Register (Read Only)\nBy reading this register, the UART will return the 8-bit data received from RX pin (LSB first).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_THR</name>
          <alternateRegister>UA_RBR</alternateRegister>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_THR</displayName>
          <description>UART Transmit Holding Register</description>
          <addressOffset>0x0</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0x00000000</resetMask>
          <fields>
            <field>
              <name>THR</name>
              <description>Transmit Holding Register\nBy writing one byte to this register, the data byte will be stored in transmitter FIFO. The UART Controller will send out the data stored in transmitter FIFO top location through the TX pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IER</displayName>
          <description>UART Interrupt Enable Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IEN</name>
              <description>Receive Data Available Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RDA_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>THRE_IEN</name>
              <description>Transmit Holding Register Empty Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>THRE_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RLS_IEN</name>
              <description>Receive Line Status Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RLS_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>MODEM_IEN</name>
              <description>Modem Status Interrupt Enable Bit (Not Available In UART2 Channel)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>MODEM_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>MODEM_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUT_IEN</name>
              <description>RX Time-Out Interrupt Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TOUT_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TOUT_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUF_ERR_IEN</name>
              <description>Buffer Error Interrupt Enable Bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUF_ERR_INT Masked off</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUF_ERR_INT Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKE_EN</name>
              <description>UART Wake-Up Function Enable Bit (Not Available In UART2 Channel)</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UART wake-up function Enabled, when the chip is in Power-down mode, an external CTS change will wake-up chip from Power-down mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IEN</name>
              <description>LIN Bus Interrupt Enable Bit\nNote: This field is used for LIN function mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Lin bus interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Lin bus interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIME_OUT_EN</name>
              <description>Time-Out Counter Enable Bit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out counter Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out counter Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_RTS_EN</name>
              <description>RTS Auto Flow Control Enable Bit (Not Available In UART2 Channel)\nWhen RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTO_CTS_EN</name>
              <description>CTS Auto Flow Control Enable Bit (Not Available In UART2 Channel)\nWhen CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>CTS auto flow control Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>CTS auto flow control Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_TX_EN</name>
              <description>TX DMA Enable Bit (Not Available In UART2 Channel)\nThis bit can enable or disable TX DMA service.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMA_RX_EN</name>
              <description>RX DMA Enable Bit (Not Available In UART2 Channel)\nThis bit can enable or disable RX DMA service.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX DMA Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX DMA Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FCR</displayName>
          <description>UART FIFO Control Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000101</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RFR</name>
              <description>RX Field Software Reset\nWhen RFR is set, all the byte in the receiver FIFO and RX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the RX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TFR</name>
              <description>TX Field Software Reset\nWhen TFR is set, all the byte in the transmit FIFO and TX internal state machine are cleared.\nNote: This bit will automatically clear at least 3 UART peripherial clock cycles.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the TX internal state machine and pointers</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RFITL</name>
              <description>RX FIFO Interrupt (INT_RDA) Trigger Level\nWhen the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if UA_IER [RDA_IEN] enabled, and an interrupt will be generated).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO Interrupt Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO Interrupt Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RX FIFO Interrupt Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RX FIFO Interrupt Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>RX FIFO Interrupt Trigger Level is 30/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>RX FIFO Interrupt Trigger Level is 46/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RX FIFO Interrupt Trigger Level is 62/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DIS</name>
              <description>Receiver Disable Bit\nThe receiver is disabled or not (set 1 to disable receiver)\nNote: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before UA_ALT_CSR [RS-485_NMM] is programmed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_TRI_LEV</name>
              <description>RTS Trigger Level For Auto-Flow Control Use (Not Available In UART2 Channel)\nNote: This field is used for RTS auto-flow control.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RTS Trigger Level is 1 byte</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RTS Trigger Level is 4 bytes</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>RTS Trigger Level is 8 bytes</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RTS Trigger Level is 14 bytes</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>RTS Trigger Level is 30/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>RTS Trigger Level is 46/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>RTS Trigger Level is 62/14 bytes (High Speed/Normal Speed)</description>
                    <value>#0110</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LCR</displayName>
          <description>UART Line Control Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WLS</name>
              <description>Word Length Selection</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word length is 5-bit</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Word length is 6-bit</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Word length is 7-bit</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Word length is 8-bit</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>NSB</name>
              <description>Number Of 'STOP Bit'</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>One ' STOP bit' is generated in the transmitted data</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>When select 5-bit word length, 1.5 'STOP bit' is generated in the transmitted data. When select 6-,7- and 8-bti word length, 2 'STOP bit' is generated in the transmitted data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PBE</name>
              <description>Parity Bit Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity bit</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity bit is generated on each outgoing character and is checked on each incoming data</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPE</name>
              <description>Even Parity Enable Bit\nThis bit has effect only when PBE (UA_LCR[3]) is set.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Odd number of logic 1's is transmitted and checked in each word</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Even number of logic 1's is transmitted and checked in each word</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SPE</name>
              <description>Stick Parity Enable Bit</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Stick parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0. If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCB</name>
              <description>Break Control Bit\nWhen this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FSR</displayName>
          <description>UART FIFO Status Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x10404000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_OVER_IF</name>
              <description>RX Overflow Error IF (Read Only)\nThis bit is set when RX FIFO overflow.\nIf the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 64/16/16 bytes of UART0/UART1/UART2, this bit will be set.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RS485_ADD_DETF</name>
              <description>RS-485 Address Byte Detection Flag (Read Only) \nNote1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.\nNote2: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receiver detects a data that is not an address bit (bit 9 ='1')</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receiver detects a data that is an address bit (bit 9 ='1')</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>PEF</name>
              <description>Parity Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'parity bit', and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No parity error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Parity error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>FEF</name>
              <description>Framing Error Flag (Read Only)\nThis bit is set to logic 1 whenever the received character does not have a valid 'stop bit' (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No framing error is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Framing error is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIF</name>
              <description>Break Interrupt Flag (Read Only)\nThis bit is set to logic 1 whenever the received data input(RX) is held in the 'spacing state' (logic 0) for longer than a full word transmission time (that is, the total time of 'start bit' + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Break interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Break interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_POINTER</name>
              <description>RX FIFO Pointer (Read Only)\nThis field indicates the RX FIFO Buffer Pointer. When UART receives one byte from external device, then RX_POINTER increases one. When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.\nThe Maximum value shown in RX_POINTER is 63/15/15 (UART0/UART1/UART2). When the using level of RX FIFO Buffer equal to 64/16/16, the RX_FULL bit is set to 1 and RX_POINTER will show 0. As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 63/15/15 (UART0/UART1/UART2).</description>
              <bitOffset>8</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receiver FIFO Empty (Read Only)\nThis bit initiate RX FIFO empty or not.\nNote: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receiver FIFO Full (Read Only)\nThis bit initiates RX FIFO is full or not.\nNote: This bit is set when the number of usage in RX FIFO Buffer is equal to 64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_POINTER</name>
              <description>TX FIFO Pointer (Read Only)\nThis field indicates the TX FIFO Buffer Pointer. When CPU writes one byte into UA_THR, then TX_POINTER increases one. When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.\nThe Maximum value shown in TX_POINTER is 63/15/15 (UART0/UART1/UART2). When the using level of TX FIFO Buffer equal to 64/16/16, the TX_FULL bit is set to 1 and TX_POINTER will show 0. As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 63/15/15 (UART0/UART1/UART2).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmitter FIFO Empty (Read Only)\nThis bit indicates TX FIFO empty or not.\nNote: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmitter FIFO Full (Read Only)\nThis bit indicates TX FIFO full or not.\nThis bit is set when the number of usage in TX FIFO Buffer is equal to 64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_OVER_IF</name>
              <description>TX Overflow Error Interrupt Flag (Read Only)\nIf TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1.\nNote: This bit is read only, but can be cleared by writing '1' to it.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not overflow</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is overflow</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TE_FLAG</name>
              <description>Transmitter Empty Flag (Read Only)\nThis bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted.\nNote: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX FIFO is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX FIFO is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ISR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ISR</displayName>
          <description>UART Interrupt Status Register</description>
          <addressOffset>0x1C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000002</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RDA_IF</name>
              <description>Receive Data Available Interrupt Flag (Read Only)\nWhen the number of bytes in the RX FIFO equals the RFITL then the RDA_IF(UA_ISR[0]) will be set. If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.\nNote: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_IF</name>
              <description>Transmit Holding Register Empty Interrupt Flag (Read Only) \nThis bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.\nNote: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_IF</name>
              <description>Receive Line Interrupt Flag (Read Only)  \nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.\nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_IF</name>
              <description>MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_IF</name>
              <description>Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC. If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.\nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_IF</name>
              <description>Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX FIFO or RX FIFO overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set). When BUF_ERR_IF (UA_ISR[5])is set, the transfer is not correct. If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated.0 = No buffer error interrupt flag is generated.\nBuffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_IF</name>
              <description>LIN Bus Flag (Read Only)\nNote: This bit is read only. This bit is cleared when LINS_HDET_F(UA_LIN_SR[0]), LIN_BKDET_F(UA_LIN_SR[9]), BIT_ERR_F(UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F(UA_LIN_SR[1]) all are cleared.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RDA_INT</name>
              <description>Receive Data Available Interrupt Indicator (Read Only)\nThis bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RDA interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RDA interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>THRE_INT</name>
              <description>Transmit Holding Register Empty Interrupt Indicator (Read Only)\nThis bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No THRE interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>THRE interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RLS_INT</name>
              <description>Receive Line Status Interrupt Indicator (Read Only) \nThis bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>MODEM_INT</name>
              <description>MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TOUT_INT</name>
              <description>Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BUF_ERR_INT</name>
              <description>Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LIN_INT</name>
              <description>LIN Bus Interrupt Indicator (Read Only)\nThis bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No LIN Bus interrupt is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN Bus interrupt is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_IF</name>
              <description>In DMA Mode, Receive Line Status Flag (Read Only)\nThis bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF (UA_FSR[6]), FEF (UA_FSR[5]) and PEF (UA_FSR[4]) is set). If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.\nNote2: In UART function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared. \nNote3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and  RS485_ADD_DETF (UA_FSR[3]) are cleared.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_IF</name>
              <description>In DMA Mode, MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)\nNote: This bit is read only and reset to 0 when the bit DCTSF(US_MSR[0]) is cleared by writing 1 on DCTSF (US_MSR[0]).</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_IF</name>
              <description>In DMA Mode, Time-Out Interrupt Flag (Read Only)\nThis bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UA_TOR[7:0]). If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated. \nNote: This bit is read only and user can read UA_RBR (RX is in active) to clear it.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Time-out interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_IF</name>
              <description>In DMA Mode, Buffer Error Interrupt Flag (Read Only)\nThis bit is set when the TX or RX FIFO overflows (TX_OVER_IF (UA__FSR[24]) or RX_OVER_IF (UA_FSR[0])  is set). When BUF_ERR_IF (UA_ISR[5]) is set, the transfer maybe is not correct. If BUF_ERR_IEN (UA_IER [5]) is enabled, the buffer error interrupt will be generated.\nNote: This bit is cleared when both TX_OVER_IF (UA_FSR[24]]) and RX_OVER_IF (UA_FSR[0]) are cleared.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt flag is generated</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt flag is generated</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_RLS_INT</name>
              <description>In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)\nThis bit is set if RLS_IEN (UA_IER[2])and HW_RLS_IF(UA_ISR[18]) are both set to 1.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No RLS interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RLS interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_MODEM_INT</name>
              <description>In DMA Mode, MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)\nThis bit is set if MODEM_IEN(UA_IER[3]) and HW_MODEM_IF(UA_ ISR[3]) are both set to 1.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Modem interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Modem interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_TOUT_INT</name>
              <description>In DMA Mode, Time-Out Interrupt Indicator (Read Only)\nThis bit is set if TOUT_IEN (UA_IER[4])and HW_TOUT_IF(UA_ISR[20]) are both set to 1.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Tout interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Tout interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>HW_BUF_ERR_INT</name>
              <description>In DMA Mode, Buffer Error Interrupt Indicator (Read Only)\nThis bit is set if BUF_ERR_IEN (UA_IER[5]) and HW_BUF_ERR_IF (UA_ISR[5])are both set to 1.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No buffer error interrupt is generated in DMA mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Buffer error interrupt is generated in DMA mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_TOR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_TOR</displayName>
          <description>UART Time-out Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TOIC</name>
              <description>Time-Out Interrupt Comparator</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DLY</name>
              <description>TX Delay Time Value \nThis field is used to programming the transfer delay time between the last stop bit and next start bit.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_BAUD</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_BAUD</displayName>
          <description>UART Baud Rate Divisor Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x0F000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BRD</name>
              <description>Baud Rate Divider\nThe field indicates the baud rate divider</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER_X</name>
              <description>Divider X</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_ONE</name>
              <description>Divider X Equal To 1\nRefer to Table 6.132 for more information.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must  = 8)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider M = 1 (the equation of M = 1, but BRD [15:0] must  = 3)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV_X_EN</name>
              <description>Divider X Enable Bit\nRefer to Table 6.132 for more information.\nNote: In IrDA mode, this bit must disable.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Divider X Disabled (the equation of M = 16)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must  = 8)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_IRCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_IRCR</displayName>
          <description>UART IrDA Control Register</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_SELECT</name>
              <description>TX_SELECT</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>IrDA Transmitter Disabled and Receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IrDA Transmitter Enabled and Receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_TX</name>
              <description>IrDA Inverse Transmitting Output Signal Control</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse transmitting signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse transmitting output signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INV_RX</name>
              <description>IrDA Inverse Receive Input Signal Control</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None inverse receiving input signal</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Inverse receiving input signal</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_ALT_CSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_ALT_CSR</displayName>
          <description>UART Alternate Control/Status Register</description>
          <addressOffset>0x2C</addressOffset>
          <access>read-write</access>
          <resetValue>0x0000000C</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LIN_BKFL</name>
              <description>UART LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: This break field length is UA_LIN_BKFL + 1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_EN</name>
              <description>LIN RX Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN RX mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN RX mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_TX_EN</name>
              <description>LIN TX Break Mode Enable Bit\nNote: When TX break field transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN TX Break mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN TX Break mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_NMM</name>
              <description>RS-485 Normal Multi-Drop Operation Mode (NMM) \nNote: It cannot be active with RS-485_AAD operation mode.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Normal Multi-drop Operation mode (NMM) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AAD</name>
              <description>RS-485 Auto Address Detection Operation Mode (AAD)\nNote: It cannot be active with RS-485_NMM operation mode.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Address Detection Operation mode (AAD) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_AUD</name>
              <description>RS-485 Auto Direction Mode (AUD) \nNote: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RS-485 Auto Direction Operation mode (AUO) Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RS485_ADD_EN</name>
              <description>RS-485 Address Detection Enable Bit\nThis bit is used to enable RS-485 Address Detection mode. \nNote: This bit is used for RS-485 any operation mode.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Address detection mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Address detection mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_MATCH</name>
              <description>Address Match Value Register \nThis field contains the RS-485 address match values.\nNote: This field is used for RS-485 auto address detection mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_FUN_SEL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_FUN_SEL</displayName>
          <description>UART Function Select Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUN_SEL</name>
              <description>Function Select Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UART function Enabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN function Enabled</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IrDA function Enabled</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>RS-485 function Enabled</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_CTL</displayName>
          <description>UART LIN Control Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x000C0000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_EN</name>
              <description>LIN Slave Mode Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_HDET_EN</name>
              <description>LIN Slave Header Detection Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN slave header detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN slave header detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_ARS_EN</name>
              <description>LIN Slave Automatic Resynchronization Mode Enable Bit\nNote2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1).\nNote3: The control and interactions of this field are explained in 6.13.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN automatic resynchronization Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN automatic resynchronization Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_DUM_EN</name>
              <description>LIN Slave Divider Update Method Enable Bit\nNote2: This bit used for LIN Slave Automatic Resynchronization mode. (for Non-Automatic Resynchronization mode, this bit should be kept cleared) \nNote3: The control and interactions of this field are explained in 6.13.5.8.4. (Slave mode with automatic resynchronization).</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>UA_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time)</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>UA_BAUD is updated at the next received character. User must set the bit before checksum reception</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MUTE_EN</name>
              <description>LIN Mute Mode Enable Bit\nNote: The exit from mute mode condition and each control and interactions of this field are explained in (LIN slave mode).</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN mute mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN mute mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_SHD</name>
              <description>LIN TX Send Header Enable Bit\nThe LIN TX header can be 'break field' or 'break and sync field' or 'break, sync and frame ID field', it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).\nNote1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write it by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).\nNote2: When transmitter header field (it may be 'break' or 'break + sync' or 'break + sync + frame ID' selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Send LIN TX header Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Send LIN TX header Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_IDPEN</name>
              <description>LIN ID Parity Enable Bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN frame ID parity Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN frame ID parity Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_EN</name>
              <description>LIN Break Detection Enable Bit</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break detection Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_RX_DIS</name>
              <description>LIN Receiver Disable Bit</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN receiver Enabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN receiver Disabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BIT_ERR_EN</name>
              <description>Bit Error Detect Enable Bit</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bit error detection function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bit error detection Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKFL</name>
              <description>LIN Break Field Length\nThis field indicates a 4-bit LIN TX break field count.\nNote1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16].\nNote2: This break field length is LIN_BKFL + 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BS_LEN</name>
              <description>LIN Break/Sync Delimiter Length\n\nNote: This bit used for LIN master to sending header field.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN break/sync delimiter length is 1 bit time</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN break/sync delimiter length is 2 bit time.\nThe LIN break/sync delimiter length is 3 bit time</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>The LIN break/sync delimiter length is 4 bit time</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_HEAD_SEL</name>
              <description>LIN Header Select</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The LIN header includes 'break field'</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LIN header includes 'break field' and 'sync field'</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>The LIN header includes 'break field', 'sync field' and 'frame ID field'</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_PID</name>
              <description>LIN PID Register\nIf the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and parity in this field.\n\nNote1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).\nNote2: This field can be used for LIN master mode or slave mode.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>UA_LIN_SR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>UA_LIN_SR</displayName>
          <description>UART LIN Status Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>LINS_HDET_F</name>
              <description>LIN Slave Header Detection Flag (Read Only)\nThis bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.\nNote3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete header ('break + sync + frame ID'), the LINS_HEDT_F will be set whether the frame ID correct or not.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header detected (break + sync + frame ID)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_HERR_F</name>
              <description>LIN Slave Header Error Flag (Read Only)\nThis bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it. The header errors include 'break delimiter is too short (less than 0.5 bit time)', 'frame error in sync field or Identifier field', 'sync field data is not 0x55 in Non-Automatic Resynchronization mode', 'sync field deviation error with Automatic Resynchronization mode', 'sync field measure time-out with Automatic Resynchronization mode' and 'LIN header reception time-out'.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN header error not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN header error detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_IDPERR_F</name>
              <description>LIN Slave ID Parity Error Flag (Read Only)\nThis bit is set by hardware when receipted frame ID parity is not correct.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No active</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receipted frame ID parity is not correct</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_SYNC_F</name>
              <description>LIN Slave Sync Field\nThis bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode. When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.\nNote2: This bit is read only, but it can be cleared by writing 1 to it.\nNote3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The current character is not at LIN sync state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The current character is at LIN sync state</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_BKDET_F</name>
              <description>LIN Break Detection Flag (Read Only)\nThis bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>LIN break not detected</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>LIN break detected</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>BIT_ERR_F</name>
              <description>Bit Error Detect Status Flag (Read Only)\nAt TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C0</name>
      <description>I2C Register Map</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40020000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x3C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CON</displayName>
          <description>I2C Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AA</name>
              <description>Assert Acknowledge Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SI</name>
              <description>I2C Interrupt Flag\nWhen a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI by writing 1 to this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STO</name>
              <description>I2C STOP Control\nIn Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically. In a slave mode, setting STO resets I2C hardware to the defined 'not addressed' slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STA</name>
              <description>I2C START Control\nSetting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENS1</name>
              <description>I2C Controller Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EI</name>
              <description>Interrupt Enable Bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADDR0</displayName>
          <description>I2C Slave Address Register0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GC</name>
              <description>General Call Function</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>General Call Function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>General Call Function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2CADDR</name>
              <description>I2C Address Register\nThe content of this register is irrelevant when I2C is in Master mode. In the slave mode, the seven most significant bits must be loaded with the chip's own address. The I2C hardware will react if either of the address is matched.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CDAT</displayName>
          <description>I2C Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CDAT</name>
              <description>I2C Data Register\nThis field is located with the 8-bit transferred data of I2C serial port.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSTATUS</displayName>
          <description>I2C Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x000000F8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CSTATUS</name>
              <description>I2C Status Register\nThere are 26 possible status codes. \nWhen I2CSTATUS contains 0xF8, no serial interrupt is requested. \n In addition, states 0x00 stands for a Bus Error. A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame. Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CLK</displayName>
          <description>I2C Clock Divided Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CLK</name>
              <description>I2C Clock Divided Register\nNote: The minimum value of I2CLK is 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CTOC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CTOC</displayName>
          <description>I2C Time-out Counter Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Time-Out Flag\nThis bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit EI(I2CON[7]) is set to 1.\nNote: Write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV4</name>
              <description>Time-Out Counter Input Clock Divided By 4\nWhen Enabled, The time-out period is extend 4 times.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ENTI</name>
              <description>Time-Out Counter Enable Bit \nWhen Enabled, the 14-bit time-out counter will start counting when SI(I2CON[3]) is clear. Setting flag SI SI(I2CON[3]) to high will reset counter and re-start up counting after SI SI(I2CON[3]) is cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR1</name>
          <displayName>I2CADDR1</displayName>
          <description>I2C Slave Address Register1</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR2</name>
          <displayName>I2CADDR2</displayName>
          <description>I2C Slave Address Register2</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR3</name>
          <displayName>I2CADDR3</displayName>
          <description>I2C Slave Address Register3</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>I2CADM0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADM0</displayName>
          <description>I2C Slave Address Mask Register0</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CADM</name>
              <description>I2C Address Mask Register\nI2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask Disabled (the received corresponding register bit should be exact the same as address register.)</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask Enabled (the received corresponding address bit is don't care.)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM1</name>
          <displayName>I2CADM1</displayName>
          <description>I2C Slave Address Mask Register1</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM2</name>
          <displayName>I2CADM2</displayName>
          <description>I2C Slave Address Mask Register2</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM3</name>
          <displayName>I2CADM3</displayName>
          <description>I2C Slave Address Mask Register3</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register>
          <name>I2CWKUPCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CWKUPCON</displayName>
          <description>I2C Wake-up Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPEN</name>
              <description>I2C Wake-Up Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CWKUPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CWKUPSTS</displayName>
          <description>I2C Wake-up Status Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPIF</name>
              <description>I2C Wake-Up Flag\nNote: Software can write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip is not woken-up from Power-down mode by I2C</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip is woken-up from Power-down mode by I2C</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>I2C1</name>
      <description>I2C Register Map</description>
      <groupName>I2C</groupName>
      <baseAddress>0x40012000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x3C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>I2CON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CON</displayName>
          <description>I2C Control Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AA</name>
              <description>Assert Acknowledge Control</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SI</name>
              <description>I2C Interrupt Flag\nWhen a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI by writing 1 to this bit.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STO</name>
              <description>I2C STOP Control\nIn Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically. In a slave mode, setting STO resets I2C hardware to the defined 'not addressed' slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STA</name>
              <description>I2C START Control\nSetting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENS1</name>
              <description>I2C Controller Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EI</name>
              <description>Interrupt Enable Bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADDR0</displayName>
          <description>I2C Slave Address Register0</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GC</name>
              <description>General Call Function</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>General Call Function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>General Call Function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>I2CADDR</name>
              <description>I2C Address Register\nThe content of this register is irrelevant when I2C is in Master mode. In the slave mode, the seven most significant bits must be loaded with the chip's own address. The I2C hardware will react if either of the address is matched.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CDAT</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CDAT</displayName>
          <description>I2C Data Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CDAT</name>
              <description>I2C Data Register\nThis field is located with the 8-bit transferred data of I2C serial port.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CSTATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CSTATUS</displayName>
          <description>I2C Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x000000F8</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CSTATUS</name>
              <description>I2C Status Register\nThere are 26 possible status codes. \nWhen I2CSTATUS contains 0xF8, no serial interrupt is requested. \n In addition, states 0x00 stands for a Bus Error. A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame. Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CLK</displayName>
          <description>I2C Clock Divided Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CLK</name>
              <description>I2C Clock Divided Register\nNote: The minimum value of I2CLK is 4.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CTOC</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CTOC</displayName>
          <description>I2C Time-out Counter Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TIF</name>
              <description>Time-Out Flag\nThis bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit EI(I2CON[7]) is set to 1.\nNote: Write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIV4</name>
              <description>Time-Out Counter Input Clock Divided By 4\nWhen Enabled, The time-out period is extend 4 times.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ENTI</name>
              <description>Time-Out Counter Enable Bit \nWhen Enabled, the 14-bit time-out counter will start counting when SI(I2CON[3]) is clear. Setting flag SI SI(I2CON[3]) to high will reset counter and re-start up counting after SI SI(I2CON[3]) is cleared.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR1</name>
          <displayName>I2CADDR1</displayName>
          <description>I2C Slave Address Register1</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR2</name>
          <displayName>I2CADDR2</displayName>
          <description>I2C Slave Address Register2</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register derivedFrom="I2CADDR0">
          <name>I2CADDR3</name>
          <displayName>I2CADDR3</displayName>
          <description>I2C Slave Address Register3</description>
          <addressOffset>0x20</addressOffset>
       </register>
       <register>
          <name>I2CADM0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CADM0</displayName>
          <description>I2C Slave Address Mask Register0</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>I2CADM</name>
              <description>I2C Address Mask Register\nI2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>7</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Mask Disabled (the received corresponding register bit should be exact the same as address register.)</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Mask Enabled (the received corresponding address bit is don't care.)</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM1</name>
          <displayName>I2CADM1</displayName>
          <description>I2C Slave Address Mask Register1</description>
          <addressOffset>0x28</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM2</name>
          <displayName>I2CADM2</displayName>
          <description>I2C Slave Address Mask Register2</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register derivedFrom="I2CADM0">
          <name>I2CADM3</name>
          <displayName>I2CADM3</displayName>
          <description>I2C Slave Address Mask Register3</description>
          <addressOffset>0x30</addressOffset>
       </register>
       <register>
          <name>I2CWKUPCON</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CWKUPCON</displayName>
          <description>I2C Wake-up Control Register</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPEN</name>
              <description>I2C Wake-Up Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>I2C wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>I2C wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>I2CWKUPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>I2CWKUPSTS</displayName>
          <description>I2C Wake-up Status Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WKUPIF</name>
              <description>I2C Wake-Up Flag\nNote: Software can write 1 to clear this bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Chip is not woken-up from Power-down mode by I2C</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Chip is woken-up from Power-down mode by I2C</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI0</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40030000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CNTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL</displayName>
          <description>Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x05003004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>SPI Transfer Control Bit And Busy Status\nIf FIFO mode is disabled, during the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically. Software can read this bit to check if the SPI is in busy status.\nIn FIFO mode, this bit will be controlled by hardware. Software should not modify this bit. In Slave mode, this bit always returns 1 when this register is read by software. In Master mode, this bit reflects the busy or idle status of SPI.\nNote1: When FIFO mode is disabled, all configurations should be set before writing 1 to this GO_BUSY bit.\nNote2: When FIFO mode is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA finishes the data transfer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data transfer stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive On Negative Edge</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data input signal is latched on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data input signal is latched on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit On Negative Edge</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data output signal is changed on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data output signal is changed on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can up to 32 bits.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Send LSB First</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is transmitted/received first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB, bit 0 of the SPI TX0 register, is sent first to the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX0)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI bus clock is idle low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI bus clock is idle high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SP_CYCLE</name>
              <description>Suspend Interval (Master Only)\nThe four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer. The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word. The default value is 0x3. The period of the suspend interval is obtained according to the following equation.\n (SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle\nExample:\nIf the variable clock function is enabled and the transmit FIFO buffer is not empty, the minimum period of suspend interval between the successive transactions is (6.5 + SP_CYCLE) * SPI bus clock cycle.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Unit Transfer Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Unit Transfer Interrupt EnableBit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI unit transfer interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI unit transfer interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode EnableBit</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Byte Reorder Function EnableBit\nNote1: Byte Reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.\nNote2: In Slave mode with level-trigger configuration, the slave select pin must be kept at active state during the byte suspend interval.\nNote3: The Byte Reorder function is not supported when the variable bus clock function or Dual I/O mode is enabled.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Byte Reorder function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte Reorder function Enabled. A byte suspend interval will be inserted among each byte. The period of the byte suspend interval depends on the setting of SP_CYCLE</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO</name>
              <description>FIFO Mode EnableBit\nNote1: Before enabling FIFO mode, the other related settings should be set in advance.\nNote2: In Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1 automatically after writing data to the transmit FIFO buffer; the GO_BUSY bit will be cleared to 0 automatically when the SPI controller is in idle. If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1 and the GO_BUSY bit will be cleared to 0.\nNote3: After clearing this bit to 0, user must wait for at least 2 peripheral clock periods before setting this bit to 1 again.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable Bit (Master Only)\nNote: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode).</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI clock output frequency is fixed and decided only by the value of DIVIDER</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[25].</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[26].</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[27].</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DIVIDER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DIVIDER</displayName>
          <description>Clock Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider 1 Register \nThe value in this field is the frequency divider for generating the SPI peripheral clock, fspi_eclk, and the SPI bus clock of SPI master. The frequency is obtained according to the following equation. \nIf the bit of BCn, SPI_CNTRL2[31], is set to 0,\n\nelse if BCn is set to 1,\n\nwhere \n is the SPI peripheral clock source, which is defined in the CLKSEL1 register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 Register (Master Only)\nThe value in this field is the 2nd frequency divider for generating the second clock of the variable clock function. The frequency is obtained according to the following equation: \n\nIf the VARCLK_EN bit is cleared to 0, this setting is unmeaning.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSR</displayName>
          <description>Slave Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Control Bits (Master Only)\nIf AUTOSS bit is cleared, writing 1 to any bit of this field sets the SPIn_SPISS0 line to an active state and writing 0 sets the line back to inactive state.\nIf the AUTOSS bit is set, writing 0 to this field will keep the SPIn_SPISS0 line at inactive state; writing 1 to this field will select SPIn_SPISS0 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. The active state of SPIn_SPISS0 is specified in SS_LVL. \nNote: SPIn_SPISS0 is defined as the slave select input in Slave mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level\nThis bit defines the active status of slave select signal (SPIn_SPISS0).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The slave select signal SPIn_SPISS0 is active on low-level/falling-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal SPIn_SPISS0 is active on high-level/rising-edge</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Select Function Enable Bit (Master Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is cleared, slave select signals will be asserted/de-asserted by setting /clearing the corresponding bits of SPI_SSR[1:0]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set, SPIn_SPISS0 signals will be generated automatically. It means that device/slave select signal, which is set in SPI_SSR[1:0], will be asserted by the SPI controller when transmit/receive is started, and will be de-asserted after each transmit/receive is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger Enable Bit (Slave Only)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave select signal is edge-trigger. This is the default value. The SS_LVL bit decides the signal is active after a falling-edge or rising-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal is level-trigger. The SS_LVL bit decides the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Accomplish Flag\nIn Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done. \nNote: This bit is READ only. As the GO_BUSY bit is set to 1 by software, the LTRIG_FLAG will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period. In FIFO mode, this bit has no meaning.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transferred bit length of one transaction does not meet the specified requirement</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transferred bit length meets the specified requirement which defined in TX_BIT_LEN</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe data receive register holds the datum received from SPI data input pin. If FIFO mode is disabled, the last received data can be accessed through software by reading this register. If the FIFO bit is set as 1 and the RX_EMPTY bit, SPI_CNTRL[24] or SPI_STATUS[24], is not set to 1, the receive FIFO buffer can be accessed through software by reading this register. This is a read-only register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Data Transmit Register\nThe data transmit registers hold the data to be transmitted in the next transfer. The number of valid bits depends on the setting of transmit bit length field of the SPI_CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08, the bits TX[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.\nNote 1: When the SPI controller is configured as a slave device and FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the transmit data register should be updated by software before setting the GO_BUSY bit to 1.\nNote 2: In Master mode, SPI controller will start to transfer after 5 peripheral clock cycles since user wrote to this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>Variable Clock Pattern Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x007FFF87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern\nThis register defines the clock pattern of the SPI transfer. If the variable clock function is disabled, this setting is unmeaning. Refer to the 'Variable Clock Function' paragraph for more detail description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DMA</displayName>
          <description>SPI DMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DMA_GO</name>
              <description>Transmit DMA Start\nSetting this bit to 1 will start the transmit PDMA process. SPI controller will issue request to PDMA controller automatically. Hardware will clear this bit to 0 automatically after PDMA transfer done.\nIf the SPI transmit PDMA function is used to transfer data, the GO_BUSY bit should not be set to 1 by software. The PDMA control logic of SPI controller will set it automatically whenever necessary.\nIn Slave mode and when FIFO mode is disabled, the minimal suspend interval between two successive transactions must be larger than (8 SPI clock periods + 14 APB clock periods) for edge-trigger mode or (9.5 SPI clock periods + 14 APB clock periods) for level-trigger mode. If the 2-bit Transfer mode is enabled, additional 18 APB clock periods for the above conditions is required.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_GO</name>
              <description>Receive DMA Start\nSetting this bit to 1 will start the receive PDMA process. The SPI controller will issue request to PDMA controller automatically when the SPI receive buffer is not empty. This bit will be cleared to 0 by hardware automatically after PDMA transfer is done.\nIf the software uses the receive PDMA function to access the received data of SPI and does not use the transmit PDMA function, the GO_BUSY bit should be set by software.\nEnabling FIFO mode is recommended if the software uses more than one PDMA channel to transfer data.\nIn Slave mode and when FIFO mode is disabled, if the software only uses one PDMA channel for SPI receive PDMA function and the other PDMA channels are not in use, the minimal suspend interval between two successive transactions must be larger than (9 SPI slave peripheral clock periods + 4 APB clock periods) for Edge-trigger mode or (9.5 SPI slave peripheral clock periods + 4 APB clock periods) for Level-trigger mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Reset</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the PDMA control logic of the SPI controller. This bit will be cleared to 0 automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_CNTRL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL2</displayName>
          <description>Control and Status Register 2</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00001000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NOSLVSEL</name>
              <description>Slave 3-Wire Mode Enable Bit\nThis is used to ignore the slave select signal in Slave mode. The SPI controller can work with 3-wire interface including SPIn_CLK, SPIn_MISO, and SPIn_MOSI.\nNote: In Slave 3-wire mode, the SS_LTRIG, SPI_SSR[4] will be set as 1 automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4-wire bi-direction interface</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>3-wire bi-direction interface</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_ABORT</name>
              <description>Slave 3-Wire Mode Abort Control\nIn normal operation, there is an interrupt event when the received data meet the required bits which defined in TX_BIT_LEN.\nIf the received bits are less than the requirement and there is no more SPI clock input over the one transfer time in Slave 3-wire mode, the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event. \nNote: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTA_INTEN</name>
              <description>Slave 3-Wire Mode Start Interrupt EnableBit\nUsed to enable interrupt when the transfer has started in Slave 3-wire mode. If there is no transfer done interrupt over the time period which is defined by user after the transfer start, the user can set the SLV_ABORT bit to force the transfer done.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transaction start interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction start interrupt Enabled. It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave 3-Wire Mode Start Interrupt Status\nThis bit indicates if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_STATUS[11].</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared automatically when a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_DIR</name>
              <description>Dual I/O Mode Direction Control</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual Input mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual Output mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_EN</name>
              <description>Dual I/O Mode EnableBit</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual I/O mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual I/O mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_INT_OPT</name>
              <description>Slave Select Inactive Interrupt Option \nThis setting is only available if the SPI controller is configured as level trigger slave device.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will NOT be set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will be set to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCn</name>
              <description>SPI Peripheral Clock Backward Compatible Option\nRefer to the description of SPI_DIVIDER register for details.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Backward compatible clock configuration</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock configuration is not backward compatible</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_FIFO_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_FIFO_CTL</displayName>
          <description>SPI FIFO Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x44000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_CLR</name>
              <description>Clear Receive FIFO Buffer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear receive FIFO buffer. The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CLR</name>
              <description>Clear Transmit FIFO Buffer</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear transmit FIFO buffer. The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_INTEN</name>
              <description>Receive Threshold Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTEN</name>
              <description>Transmit Threshold Interrupt Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOV_INTEN</name>
              <description>Receive FIFO Overrun Interrupt Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO overrun interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO overrun interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT_INTEN</name>
              <description>Receive FIFO Time-Out Interrupt Enable Bit</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_THRESHOLD</name>
              <description>Receive FIFO Threshold\nIf the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting, the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_THRESHOLD</name>
              <description>Transmit FIFO Threshold\nIf the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_STATUS</displayName>
          <description>SPI Status Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x05000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_INTSTS</name>
              <description>Receive FIFO Threshold Interrupt Status (Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value of RX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the receive FIFO buffer is larger than the setting value of RX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVERRUN</name>
              <description>Receive FIFO Overrun Status\nWhen the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTSTS</name>
              <description>Transmit FIFO Threshold Interrupt Status (Read Only)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the transmit FIFO buffer is larger than the setting value of TX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave Start Interrupt Status\nIt is used to dedicate if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_CNTRL2[11].</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared as a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FIFO_COUNT</name>
              <description>Receive FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of receive FIFO buffer.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IF</name>
              <description>SPI Unit Transfer Interrupt Flag\nIt is a mutual mirror bit of SPI_CNTRL[16].\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Time-Out Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No receive FIFO time-out event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock period in Master mode or over 576 SPI peripheral clock period in Slave mode. When the received FIFO buffer is read by software, the time-out status will be cleared automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[26].</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[27].</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FIFO_COUNT</name>
              <description>Transmit FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of transmit FIFO buffer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPI1</name>
      <description>SPI Register Map</description>
      <groupName>SPI</groupName>
      <baseAddress>0x40034000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0xC</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x10</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x20</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x34</offset>
        <size>0x14</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>SPI_CNTRL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL</displayName>
          <description>Control and Status Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x05003004</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>GO_BUSY</name>
              <description>SPI Transfer Control Bit And Busy Status\nIf FIFO mode is disabled, during the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically. Software can read this bit to check if the SPI is in busy status.\nIn FIFO mode, this bit will be controlled by hardware. Software should not modify this bit. In Slave mode, this bit always returns 1 when this register is read by software. In Master mode, this bit reflects the busy or idle status of SPI.\nNote1: When FIFO mode is disabled, all configurations should be set before writing 1 to this GO_BUSY bit.\nNote2: When FIFO mode is disabled and the software uses TX or RX PDMA function to transfer data, this bit will be cleared after the PDMA finishes the data transfer.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data transfer stopped</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_NEG</name>
              <description>Receive On Negative Edge</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Received data input signal is latched on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Received data input signal is latched on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_NEG</name>
              <description>Transmit On Negative Edge</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmitted data output signal is changed on the rising edge of SPI bus clock</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmitted data output signal is changed on the falling edge of SPI bus clock</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_BIT_LEN</name>
              <description>Transmit Bit Length\nThis field specifies how many bits can be transmitted / received in one transaction. The minimum bit length is 8 bits and can up to 32 bits.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LSB</name>
              <description>Send LSB First</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is transmitted/received first</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The LSB, bit 0 of the SPI TX0 register, is sent first to the SPI data output pin, and the first bit received from the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX0)</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CLKP</name>
              <description>Clock Polarity</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI bus clock is idle low</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI bus clock is idle high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SP_CYCLE</name>
              <description>Suspend Interval (Master Only)\nThe four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer. The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word. The default value is 0x3. The period of the suspend interval is obtained according to the following equation.\n (SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle\nExample:\nIf the variable clock function is enabled and the transmit FIFO buffer is not empty, the minimum period of suspend interval between the successive transactions is (6.5 + SP_CYCLE) * SPI bus clock cycle.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IF</name>
              <description>Unit Transfer Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>IE</name>
              <description>Unit Transfer Interrupt EnableBit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI unit transfer interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI unit transfer interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE</name>
              <description>Slave Mode EnableBit</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Master mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>REORDER</name>
              <description>Byte Reorder Function EnableBit\nNote1: Byte Reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.\nNote2: In Slave mode with level-trigger configuration, the slave select pin must be kept at active state during the byte suspend interval.\nNote3: The Byte Reorder function is not supported when the variable bus clock function or Dual I/O mode is enabled.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Byte Reorder function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte Reorder function Enabled. A byte suspend interval will be inserted among each byte. The period of the byte suspend interval depends on the setting of SP_CYCLE</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO</name>
              <description>FIFO Mode EnableBit\nNote1: Before enabling FIFO mode, the other related settings should be set in advance.\nNote2: In Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1 automatically after writing data to the transmit FIFO buffer; the GO_BUSY bit will be cleared to 0 automatically when the SPI controller is in idle. If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1 and the GO_BUSY bit will be cleared to 0.\nNote3: After clearing this bit to 0, user must wait for at least 2 peripheral clock periods before setting this bit to 1 again.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>FIFO mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>FIFO mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>VARCLK_EN</name>
              <description>Variable Clock Enable Bit (Master Only)\nNote: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode).</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SPI clock output frequency is fixed and decided only by the value of DIVIDER</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[25].</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[26].</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_STATUS[27].</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DIVIDER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DIVIDER</displayName>
          <description>Clock Divider Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DIVIDER</name>
              <description>Clock Divider 1 Register \nThe value in this field is the frequency divider for generating the SPI peripheral clock, fspi_eclk, and the SPI bus clock of SPI master. The frequency is obtained according to the following equation. \nIf the bit of BCn, SPI_CNTRL2[31], is set to 0,\n\nelse if BCn is set to 1,\n\nwhere \n is the SPI peripheral clock source, which is defined in the CLKSEL1 register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVIDER2</name>
              <description>Clock Divider 2 Register (Master Only)\nThe value in this field is the 2nd frequency divider for generating the second clock of the variable clock function. The frequency is obtained according to the following equation: \n\nIf the VARCLK_EN bit is cleared to 0, this setting is unmeaning.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_SSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_SSR</displayName>
          <description>Slave Select Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SSR</name>
              <description>Slave Select Control Bits (Master Only)\nIf AUTOSS bit is cleared, writing 1 to any bit of this field sets the SPIn_SPISS0 line to an active state and writing 0 sets the line back to inactive state.\nIf the AUTOSS bit is set, writing 0 to this field will keep the SPIn_SPISS0 line at inactive state; writing 1 to this field will select SPIn_SPISS0 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. The active state of SPIn_SPISS0 is specified in SS_LVL. \nNote: SPIn_SPISS0 is defined as the slave select input in Slave mode.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LVL</name>
              <description>Slave Select Active Level\nThis bit defines the active status of slave select signal (SPIn_SPISS0).</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The slave select signal SPIn_SPISS0 is active on low-level/falling-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The slave select signal SPIn_SPISS0 is active on high-level/rising-edge</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>AUTOSS</name>
              <description>Automatic Slave Select Function Enable Bit (Master Only)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>If this bit is cleared, slave select signals will be asserted/de-asserted by setting /clearing the corresponding bits of SPI_SSR[1:0]</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>If this bit is set, SPIn_SPISS0 signals will be generated automatically. It means that device/slave select signal, which is set in SPI_SSR[1:0], will be asserted by the SPI controller when transmit/receive is started, and will be de-asserted after each transmit/receive is finished</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_LTRIG</name>
              <description>Slave Select Level Trigger Enable Bit (Slave Only)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave select signal is edge-trigger. This is the default value. The SS_LVL bit decides the signal is active after a falling-edge or rising-edge</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Slave select signal is level-trigger. The SS_LVL bit decides the signal is active low or active high</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>LTRIG_FLAG</name>
              <description>Level Trigger Accomplish Flag\nIn Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done. \nNote: This bit is READ only. As the GO_BUSY bit is set to 1 by software, the LTRIG_FLAG will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period. In FIFO mode, this bit has no meaning.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transferred bit length of one transaction does not meet the specified requirement</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transferred bit length meets the specified requirement which defined in TX_BIT_LEN</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_RX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_RX0</displayName>
          <description>Data Receive Register 0</description>
          <addressOffset>0x10</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX</name>
              <description>Data Receive Register\nThe data receive register holds the datum received from SPI data input pin. If FIFO mode is disabled, the last received data can be accessed through software by reading this register. If the FIFO bit is set as 1 and the RX_EMPTY bit, SPI_CNTRL[24] or SPI_STATUS[24], is not set to 1, the receive FIFO buffer can be accessed through software by reading this register. This is a read-only register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_TX0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_TX0</displayName>
          <description>Data Transmit Register 0</description>
          <addressOffset>0x20</addressOffset>
          <access>write-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX</name>
              <description>Data Transmit Register\nThe data transmit registers hold the data to be transmitted in the next transfer. The number of valid bits depends on the setting of transmit bit length field of the SPI_CNTRL register.\nFor example, if TX_BIT_LEN is set to 0x08, the bits TX[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.\nNote 1: When the SPI controller is configured as a slave device and FIFO mode is disabled, if the SPI controller attempts to transmit data to a master, the transmit data register should be updated by software before setting the GO_BUSY bit to 1.\nNote 2: In Master mode, SPI controller will start to transfer after 5 peripheral clock cycles since user wrote to this register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_VARCLK</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_VARCLK</displayName>
          <description>Variable Clock Pattern Register</description>
          <addressOffset>0x34</addressOffset>
          <access>read-write</access>
          <resetValue>0x007FFF87</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>VARCLK</name>
              <description>Variable Clock Pattern\nThis register defines the clock pattern of the SPI transfer. If the variable clock function is disabled, this setting is unmeaning. Refer to the 'Variable Clock Function' paragraph for more detail description.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_DMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_DMA</displayName>
          <description>SPI DMA Control Register</description>
          <addressOffset>0x38</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>TX_DMA_GO</name>
              <description>Transmit DMA Start\nSetting this bit to 1 will start the transmit PDMA process. SPI controller will issue request to PDMA controller automatically. Hardware will clear this bit to 0 automatically after PDMA transfer done.\nIf the SPI transmit PDMA function is used to transfer data, the GO_BUSY bit should not be set to 1 by software. The PDMA control logic of SPI controller will set it automatically whenever necessary.\nIn Slave mode and when FIFO mode is disabled, the minimal suspend interval between two successive transactions must be larger than (8 SPI clock periods + 14 APB clock periods) for edge-trigger mode or (9.5 SPI clock periods + 14 APB clock periods) for level-trigger mode. If the 2-bit Transfer mode is enabled, additional 18 APB clock periods for the above conditions is required.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_DMA_GO</name>
              <description>Receive DMA Start\nSetting this bit to 1 will start the receive PDMA process. The SPI controller will issue request to PDMA controller automatically when the SPI receive buffer is not empty. This bit will be cleared to 0 by hardware automatically after PDMA transfer is done.\nIf the software uses the receive PDMA function to access the received data of SPI and does not use the transmit PDMA function, the GO_BUSY bit should be set by software.\nEnabling FIFO mode is recommended if the software uses more than one PDMA channel to transfer data.\nIn Slave mode and when FIFO mode is disabled, if the software only uses one PDMA channel for SPI receive PDMA function and the other PDMA channels are not in use, the minimal suspend interval between two successive transactions must be larger than (9 SPI slave peripheral clock periods + 4 APB clock periods) for Edge-trigger mode or (9.5 SPI slave peripheral clock periods + 4 APB clock periods) for Level-trigger mode.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDMA_RST</name>
              <description>PDMA Reset</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reset the PDMA control logic of the SPI controller. This bit will be cleared to 0 automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_CNTRL2</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_CNTRL2</displayName>
          <description>Control and Status Register 2</description>
          <addressOffset>0x3C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00001000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NOSLVSEL</name>
              <description>Slave 3-Wire Mode Enable Bit\nThis is used to ignore the slave select signal in Slave mode. The SPI controller can work with 3-wire interface including SPIn_CLK, SPIn_MISO, and SPIn_MOSI.\nNote: In Slave 3-wire mode, the SS_LTRIG, SPI_SSR[4] will be set as 1 automatically.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>4-wire bi-direction interface</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>3-wire bi-direction interface</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_ABORT</name>
              <description>Slave 3-Wire Mode Abort Control\nIn normal operation, there is an interrupt event when the received data meet the required bits which defined in TX_BIT_LEN.\nIf the received bits are less than the requirement and there is no more SPI clock input over the one transfer time in Slave 3-wire mode, the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event. \nNote: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTA_INTEN</name>
              <description>Slave 3-Wire Mode Start Interrupt EnableBit\nUsed to enable interrupt when the transfer has started in Slave 3-wire mode. If there is no transfer done interrupt over the time period which is defined by user after the transfer start, the user can set the SLV_ABORT bit to force the transfer done.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transaction start interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transaction start interrupt Enabled. It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave 3-Wire Mode Start Interrupt Status\nThis bit indicates if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_STATUS[11].</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared automatically when a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_DIR</name>
              <description>Dual I/O Mode Direction Control</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual Input mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual Output mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DUAL_IO_EN</name>
              <description>Dual I/O Mode EnableBit</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Dual I/O mode Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Dual I/O mode Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SS_INT_OPT</name>
              <description>Slave Select Inactive Interrupt Option \nThis setting is only available if the SPI controller is configured as level trigger slave device.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will NOT be set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>As the slave select signal goes to inactive level, the IF bit will be set to 1</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BCn</name>
              <description>SPI Peripheral Clock Backward Compatible Option\nRefer to the description of SPI_DIVIDER register for details.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Backward compatible clock configuration</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clock configuration is not backward compatible</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_FIFO_CTL</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_FIFO_CTL</displayName>
          <description>SPI FIFO Control Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-write</access>
          <resetValue>0x44000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_CLR</name>
              <description>Clear Receive FIFO Buffer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear receive FIFO buffer. The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CLR</name>
              <description>Clear Transmit FIFO Buffer</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No effect</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear transmit FIFO buffer. The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1. This bit will be cleared to 0 by hardware after it is set to 1 by software</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_INTEN</name>
              <description>Receive Threshold Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>RX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>RX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTEN</name>
              <description>Transmit Threshold Interrupt Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>TX threshold interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>TX threshold interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RXOV_INTEN</name>
              <description>Receive FIFO Overrun Interrupt Enable Bit</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO overrun interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO overrun interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT_INTEN</name>
              <description>Receive FIFO Time-Out Interrupt Enable Bit</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Time-out interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Time-out interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_THRESHOLD</name>
              <description>Receive FIFO Threshold\nIf the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting, the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_THRESHOLD</name>
              <description>Transmit FIFO Threshold\nIf the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>SPI_STATUS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>SPI_STATUS</displayName>
          <description>SPI Status Register</description>
          <addressOffset>0x44</addressOffset>
          <access>read-write</access>
          <resetValue>0x05000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RX_INTSTS</name>
              <description>Receive FIFO Threshold Interrupt Status (Read Only)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value of RX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the receive FIFO buffer is larger than the setting value of RX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_OVERRUN</name>
              <description>Receive FIFO Overrun Status\nWhen the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_INTSTS</name>
              <description>Transmit FIFO Threshold Interrupt Status (Read Only)</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>The valid data count within the transmit FIFO buffer is larger than the setting value of TX_THRESHOLD</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TX_THRESHOLD</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>SLV_START_INTSTS</name>
              <description>Slave Start Interrupt Status\nIt is used to dedicate if a transaction has started in Slave 3-wire mode. It is a mutual mirror bit of SPI_CNTRL2[11].</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A transaction has started in Slave 3-wire mode. It will be cleared as a transaction is done or by writing 1 to this bit</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_FIFO_COUNT</name>
              <description>Receive FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of receive FIFO buffer.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>IF</name>
              <description>SPI Unit Transfer Interrupt Flag\nIt is a mutual mirror bit of SPI_CNTRL[16].\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No transaction has been finished since this bit was cleared to 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SPI controller has finished one unit transfer</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Time-Out Interrupt Flag\nNote: This bit will be cleared by writing 1 to itself.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No receive FIFO time-out event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock period in Master mode or over 576 SPI peripheral clock period in Slave mode. When the received FIFO buffer is read by software, the time-out status will be cleared automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RX_EMPTY</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>RX_FULL</name>
              <description>Receive FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[24].</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Receive FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Receive FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_EMPTY</name>
              <description>Transmit FIFO Buffer Empty Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[26].</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not empty</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is empty</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FULL</name>
              <description>Transmit FIFO Buffer Full Indicator (Read Only)\nIt is a mutual mirror bit of SPI_CNTRL[27].</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Transmit FIFO buffer is not full</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Transmit FIFO buffer is full</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>TX_FIFO_COUNT</name>
              <description>Transmit FIFO Data Count (Read Only)\nThis bit field indicates the valid data count of transmit FIFO buffer.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>USBD</name>
      <description>USB Register Map</description>
      <groupName>USB</groupName>
      <baseAddress>0x40060000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x1C</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x8C</offset>
        <size>0x8</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x500</offset>
        <size>0x80</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>USB_INTEN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_INTEN</displayName>
          <description>USB Interrupt Enable Register</description>
          <addressOffset>0x0</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_IE</name>
              <description>Bus Event Interrupt Enable Bit</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>BUS event interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>BUS event interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_IE</name>
              <description>USB Event Interrupt Enable Bit</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB event interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLDET_IE</name>
              <description>Floating Detection Interrupt Enable Bit</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Floating detection Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Floating detection Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_IE</name>
              <description>USB Wake-Up Interrupt Enable Bit</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Wake-up Interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up Interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_EN</name>
              <description>Wake-Up Function Enable Bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB wake-up function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB wake-up function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>INNAK_EN</name>
              <description>Active NAK Function And Its Status In IN Token</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>When device responds NAK after receiving IN token, IN NAK status will not be updated to USBD_EPSTS register, so that the USB interrupt event will not be asserted</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>IN NAK status will be updated to USBD_EPSTS register and the USB interrupt event will be asserted, when the device responds NAK after receiving IN token</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_INTSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_INTSTS</displayName>
          <description>USB Interrupt Event Status Register</description>
          <addressOffset>0x4</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUS_STS</name>
              <description>BUS Interrupt Status\nThe BUS event means that there is one of the suspense or the resume function in the bus.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No BUS event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus event occurred; check USB_ATTR[3:0] to know which kind of bus event was occurred, cleared by write 1 to USB_INTSTS[0]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_STS</name>
              <description>USB Event Interrupt Status\nThe USB event includes the SETUP Token, IN Token, OUT ACK, ISO IN, or ISO OUT events in the bus.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No USB event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred, check EPSTS0~7 to know which kind of USB event occurred. Cleared by write 1 to USB_INTSTS[1] or EPEVT0~7 and SETUP (USB_INTSTS[31])</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>FLDET_STS</name>
              <description>Floating Detection Interrupt Status</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>There is not attached/detached event in the USB</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>There is attached/detached event in the USB bus and it is cleared by write 1 to USB_INTSTS[2]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_STS</name>
              <description>Wake-Up Interrupt Status</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Wake-up event occurred</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Wake-up event occurred, cleared by write 1 to USB_INTSTS[3]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SOSOF_STS</name>
              <description>Start of Frame Interrupt Status</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>SOF event does not occur</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SOF event occurred, cleared by write 1 to USBD_INTSTS[4]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT0</name>
              <description>Endpoint 0's USB Event Status</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 0</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 0, check USB_EPSTS[10:8] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[16] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT1</name>
              <description>Endpoint 1's USB Event Status</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 1</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 1, check USB_EPSTS[13:11] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[17] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT2</name>
              <description>Endpoint 2's USB Event Status</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 2</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 2, check USB_EPSTS[16:14] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[18] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT3</name>
              <description>Endpoint 3's USB Event Status</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 3</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 3, check USB_EPSTS[19:17] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[19] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT4</name>
              <description>Endpoint 4's USB Event Status</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 4</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 4, check USB_EPSTS[22:20] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[20] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT5</name>
              <description>Endpoint 5's USB Event Status</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 5</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 5, check USB_EPSTS[25:23] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[21] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT6</name>
              <description>Endpoint 6's USB Event Status</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 6</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 6, check USB_EPSTS[28:26] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[22] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>EPEVT7</name>
              <description>Endpoint 7's USB Event Status</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No event occurred on endpoint 7</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB event occurred on Endpoint 7, check USB_EPSTS[31:29] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[23] or USB_INTSTS[1]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SETUP</name>
              <description>Setup Event Status</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Setup event</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>SETUP event occurred, cleared by write 1 to USB_INTSTS[31]</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_FADDR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_FADDR</displayName>
          <description>USB Device Function Address Register</description>
          <addressOffset>0x8</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FADDR</name>
              <description>USB Device Function Address</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_EPSTS</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_EPSTS</displayName>
          <description>USB Endpoint Status Register</description>
          <addressOffset>0xC</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>OVERRUN</name>
              <description>Overrun\nIt indicates that the received data is over the maximum payload number or not.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No overrun</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Out Data is more than the Max Payload in MXPLD register or the Setup Data is more than 8 Bytes</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS0</name>
              <description>Endpoint 0 Bus Status\nThese bits are used to indicate the current status of this endpoint</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS1</name>
              <description>Endpoint 1 Bus Status\nThese bits are used to indicate the current status of this endpoint</description>
              <bitOffset>11</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS2</name>
              <description>Endpoint 2 Bus Status\nThese bits are used to indicate the current status of this endpoint</description>
              <bitOffset>14</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS3</name>
              <description>Endpoint 3 Bus Status\nThese bits are used to indicate the current status of this endpoint</description>
              <bitOffset>17</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS4</name>
              <description>Endpoint 4 Bus Status\nThese bits are used to indicate the current status of this endpoint</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS5</name>
              <description>Endpoint 5 Bus Status\nThese bits are used to indicate the current status of this endpoint</description>
              <bitOffset>23</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS6</name>
              <description>Endpoint 6 Bus Status\nThese bits are used to indicate the current status of this endpoint</description>
              <bitOffset>26</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>EPSTS7</name>
              <description>Endpoint 7 Bus Status\nThese bits are used to indicate the current status of this endpoint</description>
              <bitOffset>29</bitOffset>
              <bitWidth>3</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>In ACK</description>
                    <value>#000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>In NAK</description>
                    <value>#001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Out Packet Data0 ACK</description>
                    <value>#010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Setup ACK</description>
                    <value>#011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Out Packet Data1 ACK</description>
                    <value>#110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Isochronous transfer end</description>
                    <value>#111</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_ATTR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_ATTR</displayName>
          <description>USB Bus Status and Attribution Register</description>
          <addressOffset>0x10</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000040</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USBRST</name>
              <description>USB Reset Status\nNote: This bit is read only.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bus no reset</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus reset when SE0 (single-ended 0) is presented more than 2.5us</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>SUSPEND</name>
              <description>Suspend Status\nNote: This bit is read only.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Bus no suspend</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Bus idle more than 3ms, either cable is plugged off or host is sleeping</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RESUME</name>
              <description>Resume Status\nNote: This bit is read only.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No bus resume</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Resume from suspend</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Time-Out Status\nNote: This bit is read only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No time-out</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>No Bus response more than 18 bits time</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PHY_EN</name>
              <description>PHY Transceiver Function Enable Bit</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PHY transceiver function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PHY transceiver function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>RWAKEUP</name>
              <description>Remote Wake-Up</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Release the USB bus from K state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force USB bus to K (USB_D+ low, USB_D- high) state, used for remote wake-up</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>USB_EN</name>
              <description>USB Controller Enable Bit</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>USB Controller Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>USB Controller Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DPPU_EN</name>
              <description>Pull-Up Resistor On USB_D+ Enable Bit</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Pull-up resistor in USB_D+ pin Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Pull-up resistor in USB_D+ pin Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PWRDN</name>
              <description>Power-Down PHY Transceiver, Low Active</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Power-down related circuit of PHY transceiver</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Turn-on related circuit of PHY transceiver</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTEM</name>
              <description>CPU Access USB SRAM Size Mode Selection</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Word mode: The size of the transfer from CPU to USB SRAM can be Word only</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Byte mode: The size of the transfer from CPU to USB SRAM can be Byte only</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_FLDET</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_FLDET</displayName>
          <description>USB Floating Detection Register</description>
          <addressOffset>0x14</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLDET</name>
              <description>Device Floating Detected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Controller is not attached into the USB host</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Controller is attached into the BUS</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_STBUFSEG</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_STBUFSEG</displayName>
          <description>Setup Token Buffer Segmentation Register</description>
          <addressOffset>0x18</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>STBUFSEG</name>
              <description>Setup Token Buffer Segmentation\nIt is used to indicate the offset address for the SETUP token with the USB Device SRAM starting address The effective starting address is\nUSB_SRAM address + {STBUFSEG[8:3], 3'b000} \nNote: It is used for SETUP token only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USBD_FN</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USBD_FN</displayName>
          <description>USB Frame Number Register</description>
          <addressOffset>0x8C</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFF000</resetMask>
          <fields>
            <field>
              <name>FN</name>
              <description>Frame Number\nThese bits contain the 11-bits frame number in the last received SOF packet.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>11</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_DRVSE0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_DRVSE0</displayName>
          <description>USB Drive SE0 Control Register</description>
          <addressOffset>0x90</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000001</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DRVSE0</name>
              <description>Drive Single Ended Zero In USB Bus\nThe Single Ended Zero (SE0) is when both lines (USB_D+ and USB_D-) are being pulled low.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>None</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Force USB PHY transceiver to drive SE0</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_BUFSEG0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_BUFSEG0</displayName>
          <description>Endpoint 0 Buffer Segmentation Register</description>
          <addressOffset>0x500</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUFSEG</name>
              <description>Endpoint Buffer Segmentation\nIt is used to indicate the offset address for each endpoint with the USB SRAM starting address The effective starting address of the endpoint is\nUSB_SRAM address + { BUFSEG[8:3], 3'b000}\nRefer to the section 5.4.4.7 for the endpoint SRAM structure and its description.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_MXPLD0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_MXPLD0</displayName>
          <description>Endpoint 0 Maximal Payload Register</description>
          <addressOffset>0x504</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MXPLD</name>
              <description>Maximal Payload\nDefine the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token). It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.\n(1) When the register is written by CPU, \nFor IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready.\nFor OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.\n(2) When the register is read by CPU,\nFor IN token, the value of MXPLD is indicated by the data length be transmitted to host\nFor OUT token, the value of MXPLD is indicated the actual data length receiving from host.\nNote: Once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_CFG0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_CFG0</displayName>
          <description>Endpoint 0 Configuration Register</description>
          <addressOffset>0x508</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>EP_NUM</name>
              <description>Endpoint Number\nThese bits are used to define the endpoint number of the current endpoint.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ISOCH</name>
              <description>Isochronous Endpoint\nThis bit is used to set the endpoint as Isochronous endpoint, no handshake.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>No Isochronous endpoint</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Isochronous endpoint</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>STATE</name>
              <description>Endpoint STATE</description>
              <bitOffset>5</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Endpoint is Disabled</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Out endpoint</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>IN endpoint</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Undefined</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DSQ_SYNC</name>
              <description>Data Sequence Synchronization\nNote: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction. Hardware will toggle automatically in IN token base on the bit.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>DATA0 PID</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>DATA1 PID</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CSTALL</name>
              <description>Clear STALL Response</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the device to clear the STALL handshake in setup stage</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Clear the device to response STALL handshake in setup stage</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>USB_CFGP0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>USB_CFGP0</displayName>
          <description>Endpoint 0 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x50C</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CLRRDY</name>
              <description>Clear Ready\nWhen the USB_MXPLD register is set by user, it means that the endpoint is ready to transmit or receive data. If the user wants to disable this transaction before the transaction start, users can set this bit to 1 to turn it off and it will be cleared to 0 automatically.\nFor IN token, write '1' to clear the IN token had ready to transmit the data to USB.\nFor OUT token, write '1' to clear the OUT token had ready to receive the data from USB.\nThis bit is write 1 only and is always 0 when it is read back.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSTALL</name>
              <description>Set STALL</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disable the device to response STALL</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set the device to respond STALL automatically</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG1</name>
          <displayName>USB_BUFSEG1</displayName>
          <description>Endpoint 1 Buffer Segmentation Register</description>
          <addressOffset>0x510</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD1</name>
          <displayName>USB_MXPLD1</displayName>
          <description>Endpoint 1 Maximal Payload Register</description>
          <addressOffset>0x514</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG1</name>
          <displayName>USB_CFG1</displayName>
          <description>Endpoint 1 Configuration Register</description>
          <addressOffset>0x518</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP1</name>
          <displayName>USB_CFGP1</displayName>
          <description>Endpoint 1 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x51C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG2</name>
          <displayName>USB_BUFSEG2</displayName>
          <description>Endpoint 2 Buffer Segmentation Register</description>
          <addressOffset>0x520</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD2</name>
          <displayName>USB_MXPLD2</displayName>
          <description>Endpoint 2 Maximal Payload Register</description>
          <addressOffset>0x524</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG2</name>
          <displayName>USB_CFG2</displayName>
          <description>Endpoint 2 Configuration Register</description>
          <addressOffset>0x528</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP2</name>
          <displayName>USB_CFGP2</displayName>
          <description>Endpoint 2 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x52C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG3</name>
          <displayName>USB_BUFSEG3</displayName>
          <description>Endpoint 3 Buffer Segmentation Register</description>
          <addressOffset>0x530</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD3</name>
          <displayName>USB_MXPLD3</displayName>
          <description>Endpoint 3 Maximal Payload Register</description>
          <addressOffset>0x534</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG3</name>
          <displayName>USB_CFG3</displayName>
          <description>Endpoint 3 Configuration Register</description>
          <addressOffset>0x538</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP3</name>
          <displayName>USB_CFGP3</displayName>
          <description>Endpoint 3 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x53C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG4</name>
          <displayName>USB_BUFSEG4</displayName>
          <description>Endpoint 4 Buffer Segmentation Register</description>
          <addressOffset>0x540</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD4</name>
          <displayName>USB_MXPLD4</displayName>
          <description>Endpoint 4 Maximal Payload Register</description>
          <addressOffset>0x544</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG4</name>
          <displayName>USB_CFG4</displayName>
          <description>Endpoint 4 Configuration Register</description>
          <addressOffset>0x548</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP4</name>
          <displayName>USB_CFGP4</displayName>
          <description>Endpoint 4 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x54C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG5</name>
          <displayName>USB_BUFSEG5</displayName>
          <description>Endpoint 5 Buffer Segmentation Register</description>
          <addressOffset>0x550</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD5</name>
          <displayName>USB_MXPLD5</displayName>
          <description>Endpoint 5 Maximal Payload Register</description>
          <addressOffset>0x554</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG5</name>
          <displayName>USB_CFG5</displayName>
          <description>Endpoint 5 Configuration Register</description>
          <addressOffset>0x558</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP5</name>
          <displayName>USB_CFGP5</displayName>
          <description>Endpoint 5 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x55C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG6</name>
          <displayName>USB_BUFSEG6</displayName>
          <description>Endpoint 6 Buffer Segmentation Register</description>
          <addressOffset>0x560</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD6</name>
          <displayName>USB_MXPLD6</displayName>
          <description>Endpoint 6 Maximal Payload Register</description>
          <addressOffset>0x564</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG6</name>
          <displayName>USB_CFG6</displayName>
          <description>Endpoint 6 Configuration Register</description>
          <addressOffset>0x568</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP6</name>
          <displayName>USB_CFGP6</displayName>
          <description>Endpoint 6 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x56C</addressOffset>
       </register>
       <register derivedFrom="USB_BUFSEG0">
          <name>USB_BUFSEG7</name>
          <displayName>USB_BUFSEG7</displayName>
          <description>Endpoint 7 Buffer Segmentation Register</description>
          <addressOffset>0x570</addressOffset>
       </register>
       <register derivedFrom="USB_MXPLD0">
          <name>USB_MXPLD7</name>
          <displayName>USB_MXPLD7</displayName>
          <description>Endpoint 7 Maximal Payload Register</description>
          <addressOffset>0x574</addressOffset>
       </register>
       <register derivedFrom="USB_CFG0">
          <name>USB_CFG7</name>
          <displayName>USB_CFG7</displayName>
          <description>Endpoint 7 Configuration Register</description>
          <addressOffset>0x578</addressOffset>
       </register>
       <register derivedFrom="USB_CFGP0">
          <name>USB_CFGP7</name>
          <displayName>USB_CFGP7</displayName>
          <description>Endpoint 7 Set Stall and Clear In/Out Ready Control Register</description>
          <addressOffset>0x57C</addressOffset>
       </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>ADC</name>
      <description>ADC Register Map</description>
      <groupName>ADC</groupName>
      <baseAddress>0x400E0000</baseAddress>
      <!-- the first addressBlock is occupied by registers. The second block is reserved -> no access permission -->
      <addressBlock>
        <offset>0x0</offset>
        <size>0x34</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x40</offset>
        <size>0x4</size>
        <usage>registers</usage>
      </addressBlock>
      <addressBlock>
        <offset>0x50</offset>
        <size>0x10</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
       <register>
          <name>ADDR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADDR0</displayName>
          <description>ADC Data Register 0</description>
          <addressOffset>0x0</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RSLT</name>
              <description>A/D Conversion Result\nThis field contains conversion result of ADC.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERRUN</name>
              <description>Overrun Flag\nIf converted data in RSLT has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone. It is cleared by hardware after ADDR register is read.\nThis is a read only bit.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data in RSLT (ADDRx[15:0], x=0~11) is recent conversion result</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in RSLT (ADDRx[15:0], x=0~11) is overwritten</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Valid Flag\nThis bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.\nThis is a read only bit</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Data in RSLT bits (ADDRx[15:0], x=0~7) is not valid</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Data in RSLT bits (ADDRx[15:0], x=0~7) is valid</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR1</name>
          <displayName>ADDR1</displayName>
          <description>ADC Data Register 1</description>
          <addressOffset>0x4</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR2</name>
          <displayName>ADDR2</displayName>
          <description>ADC Data Register 2</description>
          <addressOffset>0x8</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR3</name>
          <displayName>ADDR3</displayName>
          <description>ADC Data Register 3</description>
          <addressOffset>0xC</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR4</name>
          <displayName>ADDR4</displayName>
          <description>ADC Data Register 4</description>
          <addressOffset>0x10</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR5</name>
          <displayName>ADDR5</displayName>
          <description>ADC Data Register 5</description>
          <addressOffset>0x14</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR6</name>
          <displayName>ADDR6</displayName>
          <description>ADC Data Register 6</description>
          <addressOffset>0x18</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR7</name>
          <displayName>ADDR7</displayName>
          <description>ADC Data Register 7</description>
          <addressOffset>0x1C</addressOffset>
       </register>
       <register>
          <name>ADCR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCR</displayName>
          <description>ADC Control Register</description>
          <addressOffset>0x20</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADEN</name>
              <description>A/D Converter Enable Bit\nBefore starting A/D conversion function, this bit should be set to 1. Clear it to 0 to disable A/D converter analog circuit for saving power consumption.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADIE</name>
              <description>A/D Interrupt Enable Bit\nA/D conversion end interrupt request is generated if ADIE bit (ADCR[1]) is set to 1.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D interrupt function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D interrupt function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADMD</name>
              <description>A/D Converter Operation Mode\nWhen changing the operation mode, software should disable ADST bit (ADCR[11]) firstly.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Single conversion</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Reserved.</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Single-cycle scan</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Continuous scan</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGS</name>
              <description>Hardware Trigger Source\nSoftware should disable TRGEN (ADCR[8]) and ADST (ADCR[11]) before change TRGS.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D conversion is started by external STADC pin</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>A/D conversion is started by PWM Center-aligned trigger</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGCOND</name>
              <description>External Trigger Condition\nThese two bits decide external pin STADC trigger event is level or edge. The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and low state for edge trigger.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Low level</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>High level</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Falling edge</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Rising edge</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>TRGEN</name>
              <description>Hardware Trigger Enable Bit\nEnable or disable triggering of A/D conversion by hardware (external STADC pin or PWM Center-aligned trigger).\nADC hardware trigger function is only supported in single-cycle scan mode.\nIf hardware trigger mode, the ADST bit (ADCR[11]) can be set to 1 by the selected hardware trigger source.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PTEN</name>
              <description>PDMA Transfer Enable Bit</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>PDMA data transfer Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>PDMA data transfer in ADDR 0~11 Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DIFFEN</name>
              <description>Differential Input Mode Control</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Single-end analog input mode</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Differential analog input mode</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>ADST</name>
              <description>A/D Conversion Start\nADST bit can be set to 1 from three sources: software, PWM Center-aligned trigger and external pin STADC. ADST will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode. In continuous scan mode, A/D conversion is continuously performed until software writes 0 to this bit or chip reset.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion stops and A/D converter enter idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion starts</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>DMOF</name>
              <description>A/D Differential Input Mode Output Format</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D Conversion result will be filled in RSLT at ADDRx registers with unsigned format</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D Conversion result will be filled in RSLT at ADDRx registers with 2'complement format</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCHER</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCHER</displayName>
          <description>ADC Channel Enable Register</description>
          <addressOffset>0x24</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHEN</name>
              <description>Analog Input Channel Enable Bit\nSet CHEN[7:0] to enable the corresponding analog input channel 7 ~ 0. If DIFFEN bit (ADCR[10]) is set to 1, only the even number channels need to be enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC input channel Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC input channel Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESEL</name>
              <description>Analog Input Channel 7 Selection</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>External analog input</description>
                    <value>#00</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Internal band-gap voltage</description>
                    <value>#01</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Internal temperature sensor</description>
                    <value>#10</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Reserved.</description>
                    <value>#11</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHEN1</name>
              <description>Analog Input Channel Enable Bit 1\nSet CHEN[14:10] to enable the corresponding analog input channel 11 ~ 8. If DIFFEN bit (ADCR[10]) is set to 1, only the even number channels need to be enabled.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>ADC input channel Disabled</description>
                    <value>0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>ADC input channel Enabled</description>
                    <value>1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADCMPR0</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADCMPR0</displayName>
          <description>ADC Compare Register 0</description>
          <addressOffset>0x28</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CMPEN</name>
              <description>Compare Enable Bit\nSet this bit to 1 to enable ADC controller to compare CMPD (ADCMPR0/1[27:16]) with specified channel conversion result when converted data is loaded into ADDR register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare function Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare function Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPIE</name>
              <description>Compare Interrupt Enable Bit\nIf the compare function is enabled and the compare condition matches the setting of CMPCOND (ADCMPR0/1[2]) and CMPMATCNT (ADCMPR0/1[11:8]), CMPF0/1 bit (ADSR[1]/[2]) will be asserted, in the meanwhile, if CMPIE (ADCMPR0/1[1]) is set to 1, a compare interrupt request is generated.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Compare function interrupt Disabled</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Compare function interrupt Enabled</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCOND</name>
              <description>Compare Condition\nNote: When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8])+1), the CMPF0/1 bit (ADSR[1]/[2]) will be set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPCH</name>
              <description>Compare Channel Selection</description>
              <bitOffset>3</bitOffset>
              <bitWidth>4</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Channel 0 conversion result is selected to be compared</description>
                    <value>#0000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Channel 1 conversion result is selected to be compared</description>
                    <value>#0001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>2</name>
                    <description>Channel 2 conversion result is selected to be compared</description>
                    <value>#0010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>3</name>
                    <description>Channel 3 conversion result is selected to be compared</description>
                    <value>#0011</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>4</name>
                    <description>Channel 4 conversion result is selected to be compared</description>
                    <value>#0100</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>5</name>
                    <description>Channel 5 conversion result is selected to be compared</description>
                    <value>#0101</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>6</name>
                    <description>Channel 6 conversion result is selected to be compared</description>
                    <value>#0110</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>7</name>
                    <description>Channel 7 conversion result is selected to be compared</description>
                    <value>#0111</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>8</name>
                    <description>Channel 8 conversion result is selected to be compared</description>
                    <value>#1000</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>9</name>
                    <description>Channel 9 conversion result is selected to be compared</description>
                    <value>#1001</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>10</name>
                    <description>Channel 10 conversion result is selected to be compared</description>
                    <value>#1010</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>11</name>
                    <description>Channel 11 conversion result is selected to be compared</description>
                    <value>#1011</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPMATCNT</name>
              <description>Compare Match Count\nWhen the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND (ADCMPR0/1[2]), the internal match counter will increase 1, The comparing data must successively matched with the compare condition. Once any comparing data does not match during the comparing, the internal counter will clear to 0. When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8]) +1), the CMPF0/1 bit (ADSR[1]/[2]) will be set.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPD</name>
              <description>Comparison Data\nThe 12-bit data is used to compare with conversion result of specified channel.\nWhen DMOF bit (ADCR[31]) is set to 0, ADC comparator compares CMPD with conversion result with unsigned format. CMPD should be filled in unsigned format.\nWhen DMOF bit (ADCR[31]) is set to 1, ADC comparator compares CMPD with conversion result with 2'complement format. CMPD should be filled in 2'complement format.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>12</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADCMPR0">
          <name>ADCMPR1</name>
          <displayName>ADCMPR1</displayName>
          <description>ADC Compare Register 1</description>
          <addressOffset>0x2C</addressOffset>
       </register>
       <register>
          <name>ADSR</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADSR</displayName>
          <description>ADC Status Register</description>
          <addressOffset>0x30</addressOffset>
          <access>read-write</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ADF</name>
              <description>A/D Conversion End Flag\nA status flag that indicates the end of A/D conversion.\nADF is set to 1 at these two conditions:\n1. When A/D conversion ends in Single mode.\n2. When A/D conversion ends on all specified channels in Scan mode.\nThis flag can be cleared by writing 1 to itself.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF0</name>
              <description>Compare Flag\nWhen the selected channel A/D conversion result meets setting condition in ADCMPR0 then this bit is set to 1. And it is cleared by writing 1 to self.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion result in ADDR does not meet ADCMPR0 setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion result in ADDR meets ADCMPR0 setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CMPF1</name>
              <description>Compare Flag\nWhen the selected channel A/D conversion result meets setting condition in ADCMPR1 then this bit is set to 1. And it is cleared by writing 1 to self.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>Conversion result in ADDR does not meet ADCMPR1 setting</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>Conversion result in ADDR meets ADCMPR1 setting</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>BUSY/IDLE\nThis bit is mirror of as ADST bit (ADCR[11]).\nIt is read only.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <enumeratedValues>
                 <enumeratedValue>
                    <name>0</name>
                    <description>A/D converter is in idle state</description>
                    <value>#0</value>
                 </enumeratedValue>
                 <enumeratedValue>
                    <name>1</name>
                    <description>A/D converter is busy at conversion</description>
                    <value>#1</value>
                 </enumeratedValue>
              </enumeratedValues>
              <access>read-write</access>
            </field>
            <field>
              <name>CHANNEL</name>
              <description>Current Conversion Channel\nIt is read only.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID0</name>
              <description>Data Valid Flag\nIt is a mirror of VALID bit (ADDR0~7[17]).\nIt is read only.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERRUN0</name>
              <description>Overrun Flag\nIt is a mirror to OVERRUN bit (ADDR0~7[16]).\nIt is read only.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID1</name>
              <description>Data Valid Flag\nIt is a mirror of VALID bit (ADDR8~11[17]).\nIt is read only.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERRUN1</name>
              <description>Overrun Flag\nIt is a mirror to OVERRUN bit (ADDR8~11[16]).\nIt is read only.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
       </register>
       <register>
          <name>ADPDMA</name>
          <!-- the display name is an unrestricted string. -->
          <displayName>ADPDMA</displayName>
          <description>ADC PDMA Current Transfer Data Register</description>
          <addressOffset>0x40</addressOffset>
          <access>read-only</access>
          <resetValue>0x00000000</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>AD_PDMA</name>
              <description>ADC PDMA Current Transfer Data Register\nWhen PDMA transferring, read this register can monitor current PDMA transfer data.\nCurrent PDMA transfer data is the content of ADDR0 ~ ADDR11.\nThis is a read only register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>18</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR8</name>
          <displayName>ADDR8</displayName>
          <description>ADC Data Register 8</description>
          <addressOffset>0x50</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR9</name>
          <displayName>ADDR9</displayName>
          <description>ADC Data Register 9</description>
          <addressOffset>0x54</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR10</name>
          <displayName>ADDR10</displayName>
          <description>ADC Data Register 10</description>
          <addressOffset>0x58</addressOffset>
       </register>
       <register derivedFrom="ADDR0">
          <name>ADDR11</name>
          <displayName>ADDR11</displayName>
          <description>ADC Data Register 11</description>
          <addressOffset>0x5C</addressOffset>
       </register>
      </registers>
    </peripheral>
  </peripherals>
</device>
